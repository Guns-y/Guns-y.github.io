<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>第七章 JUC 扩展 FutureTask、ForkJoin、BlockingQueue | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ferrymana&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ferrymana&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">第七章 JUC 扩展 FutureTask、ForkJoin、BlockingQueue</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 11, 2018&nbsp;&nbsp;10:13:42</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/并发/">并发</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p>FutureTask是J.U.C中的类，是一个可删除的异步计算类。这个类提供了Future接口的的基本实现，使用相关方法启动和取消计算，查询计算是否完成，并检索计算结果。只有在计算完成时才能使用get方法检索结果;如果计算尚未完成，get方法将会阻塞。一旦计算完成，计算就不能重新启动或取消(除非使用runAndReset方法调用计算)。</p>
<p>Runnable与Callable对比</p>
<p>通常实现一个线程我们会使用继承Thread的方式或者实现Runnable接口，这两种方式有一个共同的缺陷就是在执行完任务之后无法获取执行结果。从Java1.5之后就提供了Callable与Future，这两个接口就可以实现获取任务执行结果。</p>
<p>Runnable接口：代码非常简单，只有一个方法run</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Callable泛型接口：有泛型参数，提供了一个call方法，<strong>执行后可返回传入的泛型参数类型的结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p>Future接口提供了一系列方法用于控制线程执行计算，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;<span class="comment">//取消任务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;<span class="comment">//是否被取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;<span class="comment">//计算是否完成</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;<span class="comment">//获取计算结果，在执行过程中任务被阻塞</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span><span class="comment">//timeout等待时间、unit时间单位</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());<span class="comment">//线程池提交任务</span></span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        String result = future.get();<span class="comment">//获取不到一直阻塞</span></span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-105255.png" alt="image-20190805185253727"></p>
<h4 id="FutureTask-1"><a href="#FutureTask-1" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>Future实现了RunnableFuture接口，而RunnableFuture接口继承了Runnable与Future接口，所以它既可以作为Runnable被线程中执行，又可以作为callable获得返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FutureTask支持两种参数类型，Callable和Runnable，在使用Runnable 时，还可以多指定一个返回结果类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        log.info(<span class="string">"result：&#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-105339.png" alt="image-20190805185338831"></p>
<h2 id="ForkJoin"><a href="#ForkJoin" class="headerlink" title="ForkJoin"></a>ForkJoin</h2><p>ForkJoin是Java7提供的一个并行执行任务的框架，是把大任务分割成若干个小任务，待小任务完成后将结果汇总成大任务结果的框架。主要采用的是<strong>工作窃取算法</strong>，工作窃取算法是指某个线程从其他队列里窃取任务来执行。<br><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-105350.png" alt="这里写图片描述"></p>
<p>在窃取过程中两个线程会访问同一个队列，为了减少窃取任务线程和被窃取任务线程之间的竞争，通常我们会使用双端队列来实现工作窃取算法。被窃取任务的线程永远从队列的头部拿取任务，窃取任务的线程从队列尾部拿取任务。</p>
<p>局限性：</p>
<p>1、任务只能使用fork和join作为同步机制，如果使用了其他同步机制，当他们在同步操作时，工作线程就不能执行其他任务了。比如在fork框架使任务进入了睡眠，那么在睡眠期间内在执行这个任务的线程将不会执行其他任务了。<br>2、我们所拆分的任务不应该去执行IO操作，如读和写数据文件。<br>3、任务不能抛出检查异常。必须通过必要的代码来处理他们。</p>
<p>框架核心：</p>
<p>核心有两个类：ForkJoinPool | ForkJoinTask<br>ForkJoinPool：负责来做实现，包括工作窃取算法、管理工作线程和提供关于任务的状态以及他们的执行信息。<br>ForkJoinTask:提供在任务中执行fork和join的机制。</p>
<p>使用方式：（模拟加和运算）</p>
<p>@Slf4j<br>public class ForkJoinTaskExample extends RecursiveTask<integer> {</integer></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">2</span>;<span class="comment">//设定不大于两个数相加就直接for循环，不适用框架</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinTaskExample</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">    <span class="keyword">boolean</span> canCompute = (end - start) &lt;= threshold;</span><br><span class="line">    <span class="keyword">if</span> (canCompute) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务大于阈值，就分裂成两个子任务计算（分裂算法，可依情况调优）</span></span><br><span class="line">        <span class="keyword">int</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">        ForkJoinTaskExample leftTask = <span class="keyword">new</span> ForkJoinTaskExample(start, middle);</span><br><span class="line">        ForkJoinTaskExample rightTask = <span class="keyword">new</span> ForkJoinTaskExample(middle + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行子任务</span></span><br><span class="line">        leftTask.fork();</span><br><span class="line">        rightTask.fork();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待任务执行结束合并其结果</span></span><br><span class="line">        <span class="keyword">int</span> leftResult = leftTask.join();</span><br><span class="line">        <span class="keyword">int</span> rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并子任务</span></span><br><span class="line">        sum = leftResult + rightResult;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool forkjoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成一个计算任务，计算1+2+3+4...100</span></span><br><span class="line">    ForkJoinTaskExample task = <span class="keyword">new</span> ForkJoinTaskExample(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行一个任务</span></span><br><span class="line">    Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"result:&#123;&#125;"</span>, result.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>BlockingQueue阻塞队列</p>
<p>主要应用场景：生产者消费者模型，是线程安全的 </p>
<p>阻塞情况：</p>
<p>1、当队列满了进行入队操作<br>2、当队列空了的时候进行出队列操作</p>
<p>四套方法：</p>
<p>BlockingQueue提供了四套方法，分别来进行插入、移除、检查。每套方法在不能立刻执行时都有不同的反应。 </p>
<p> <img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-105509.png" alt="image-20190805185508736"></p>
<hr>
<hr>
<hr>
<h1 id="J-U-C之FutureTask"><a href="#J-U-C之FutureTask" class="headerlink" title="J.U.C之FutureTask"></a>J.U.C之FutureTask</h1><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>由于线程是实现了Runnable接口或继承了Thread类，其执行后无法回调其线程的执行结果，因此JDK 1.5提供了一些新机制：接口Callable和Future。通过他们可以得到线程的执行结果。</p>
</blockquote>
<h4 id="Runnable与Callable对比"><a href="#Runnable与Callable对比" class="headerlink" title="Runnable与Callable对比"></a>Runnable与Callable对比</h4><ol>
<li>Runnable接口只有一个run()方法；</li>
<li>Callable是一个泛型接口，其中也只有V call()函数，其返回类型即传入的参数泛型。</li>
<li>两个接口功能相似，但后者因可以返回执行信息且支持泛型而更强大一些。</li>
</ol>
<h4 id="Future接口-1"><a href="#Future接口-1" class="headerlink" title="Future接口"></a>Future接口</h4><p>通过实现该类可以得到一个<strong>异步计算</strong>的返回结果。并提供方法接口：检查是否计算完成、等待计算的完成、取回计算的结果、判断计算是否在完成前被正常地取消。</p>
<h4 id="FutureTask类"><a href="#FutureTask类" class="headerlink" title="FutureTask类"></a>FutureTask类</h4><p>它实现了RunnableFuture接口，而RunnableFuture接口同时继承了Runnable接口和Future接口。即FutureTask类最终也是执行的Callable的方法。组合Runnable和Future的好处：可以另起线程去专门检查并调取最终计算的结果，而其他的线程可以继续其他任务（只需监听该跑腿线程即可）。</p>
<h4 id="演示例子-Callable和Future结合"><a href="#演示例子-Callable和Future结合" class="headerlink" title="演示例子-Callable和Future结合"></a>演示例子-Callable和Future结合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class FutureExample &#123;</span><br><span class="line"></span><br><span class="line">    static class MyCallable implements Callable&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            log.info(&quot;do something in callable&quot;);</span><br><span class="line">            Thread.sleep(5000);</span><br><span class="line">            return &quot;Done&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(new MyCallable());</span><br><span class="line">        log.info(&quot;do something in main&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        String result = future.get();</span><br><span class="line">        log.info(&quot;result：&#123;&#125;&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11:29:00.230 [main] INFO com.mmall.concurrency.aqs.FutureExample - do something in main</span><br><span class="line">11:29:00.230 [pool-1-thread-1] INFO com.mmall.concurrency.aqs.FutureExample - do something in callable</span><br><span class="line">11:29:05.234 [main] INFO com.mmall.concurrency.aqs.FutureExample - result：Done</span><br></pre></td></tr></table></figure>

<h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><ol>
<li>结合Callable和Future两者。</li>
<li>实现的Callable类可以被Executors的submit(xxx)提交给线程池运行。（之前提到过）</li>
<li>通过Future的get()查询并取回执行结果；若未执行结束则阻塞查询。（前面有说到）</li>
</ol>
<h4 id="演示例子-FutureTask"><a href="#演示例子-FutureTask" class="headerlink" title="演示例子-FutureTask"></a>演示例子-FutureTask</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class FutureTaskExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                log.info(&quot;do something in callable&quot;);</span><br><span class="line">                Thread.sleep(5000);</span><br><span class="line">                return &quot;Done&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        new Thread(futureTask).start();</span><br><span class="line">        log.info(&quot;do something in main&quot;);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        log.info(&quot;result：&#123;&#125;&quot;, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><p>与上个例子结果一模一样，运行速度快了25%左右：Callable和Future结合使用耗时2s 450ms，FutureTask耗时1s 890ms。</p>
<h4 id="看下源码"><a href="#看下源码" class="headerlink" title="看下源码"></a>看下源码</h4><p>get()方法的内核：返回执行完成的结果或抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns result or throws exception for completed task.</span><br><span class="line"> *</span><br><span class="line"> * @param s completed state value</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    if (s == NORMAL)</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;= CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个可以指定返回执行结果的构造函数：（内部都是调用Executors的callable方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">    this.callable = Executors.callable(runnable, result);</span><br><span class="line">    this.state = NEW;       // ensure visibility of callable</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123;</span><br><span class="line">    if (task == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123;</span><br><span class="line">    final Runnable task;</span><br><span class="line">    final T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        this.task = task;</span><br><span class="line">        this.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    public T call() &#123;</span><br><span class="line">        task.run();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个指定超时时间的get():</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public V get(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">    if (unit == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int s = state;</span><br><span class="line">    if (s &lt;= COMPLETING &amp;&amp;</span><br><span class="line">        (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class="line">        throw new TimeoutException();</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当计算失败时（不包括计算被取消）被内部的run()调用:报告其中的异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void setException(Throwable t) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦计算完成，该计算就不能被重启或取消了，除非调用runAndReset()方法：（之前概述提到）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">protected boolean runAndReset() &#123;</span><br><span class="line">    if (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return false;</span><br><span class="line">    boolean ran = false;</span><br><span class="line">    int s = state;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        if (c != null &amp;&amp; s == NEW) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                c.call(); // don&apos;t set result</span><br><span class="line">                ran = true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // runner must be non-null until state is settled to</span><br><span class="line">        // prevent concurrent calls to run()</span><br><span class="line">        runner = null;</span><br><span class="line">        // state must be re-read after nulling runner to prevent</span><br><span class="line">        // leaked interrupts</span><br><span class="line">        s = state;</span><br><span class="line">        if (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    return ran &amp;&amp; s == NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="J-U-C之ForkJoin"><a href="#J-U-C之ForkJoin" class="headerlink" title="J.U.C之ForkJoin"></a>J.U.C之ForkJoin</h1><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>ForkJoin框架是JDK 1.7提供的一种用于并行任务执行的框架。有些像Hadoop中的MapReduce机制。即将一个大任务分为（fork）多个小任务分别执行，最后将多个小任务的执行结果进行汇总（join）。</p>
<blockquote>
<p>该框架采用的工作窃取算法，即<strong>当一个线程执行完它的任务后，可以从其他线程的任务队列尾部开始自行窃取任务进行执行，最后与该队列的另一个线程接头</strong>，以充分发挥该框架的优势（消除线程等待），提高效率，促进性能提升。<br>其中，每个线程的任务队列采用双端队列进行实现。<br>缺点：1. 当一个线程的双端队列中只有一个任务时，也会发生线程竞争。2. 由于使用双端队列，系统会分配更多的资源。</p>
</blockquote>
<h4 id="执行任务的局限性"><a href="#执行任务的局限性" class="headerlink" title="执行任务的局限性"></a>执行任务的局限性</h4><ol>
<li>任务只能使用Fork或Join作为同步机制；</li>
<li>线程队列中的任务不可以有IO操作；</li>
<li>任务不能抛出检查异常。（若有则需要必要的代码进行处理）</li>
</ol>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><p>看一下注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An &#123;@link ExecutorService&#125; for running &#123;@link ForkJoinTask&#125;s.</span><br><span class="line"> * A &#123;@code ForkJoinPool&#125; provides the entry point for submissions</span><br><span class="line"> * from non-&#123;@code ForkJoinTask&#125; clients, as well as management and</span><br><span class="line"> * monitoring operations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinPool&#125; differs from other kinds of &#123;@link</span><br><span class="line"> * ExecutorService&#125; mainly by virtue of employing</span><br><span class="line"> * &lt;em&gt;work-stealing&lt;/em&gt;: all threads in the pool attempt to find and</span><br><span class="line"> * execute tasks submitted to the pool and/or created by other active</span><br><span class="line"> * tasks (eventually blocking waiting for work if none exist). This</span><br><span class="line"> * enables efficient processing when most tasks spawn other subtasks</span><br><span class="line"> * (as do most &#123;@code ForkJoinTask&#125;s), as well as when many small</span><br><span class="line"> * tasks are submitted to the pool from external clients.  Especially</span><br><span class="line"> * when setting &lt;em&gt;asyncMode&lt;/em&gt; to true in constructors, &#123;@code</span><br><span class="line"> * ForkJoinPool&#125;s may also be appropriate for use with event-style</span><br><span class="line"> * tasks that are never joined.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>实质上，ForkJoinPool是一个从非ForkJoinTask的请求中，为运行中的ForkJoinTask的子任务提供切入点的ExecutorService。它不同于其他的ExecutorService，主要是它虚拟部署了任务窃取。尤其当在构造器中设置asyncMode为true时，ForkJoinPool也可能适当地使用事件模式的任务（从未被汇总过？？）。<br><strong>ForkJoinPool主要做实现：包括工作窃取算法、工作线程的管理、任务的状态管理、任务的执行信息等。</strong></p>
<h4 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h4><p>看下注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Abstract base class for tasks that run within a &#123;@link ForkJoinPool&#125;.</span><br><span class="line"> * A &#123;@code ForkJoinTask&#125; is a thread-like entity that is much</span><br><span class="line"> * lighter weight than a normal thread.  Huge numbers of tasks and</span><br><span class="line"> * subtasks may be hosted by a small number of actual threads in a</span><br><span class="line"> * ForkJoinPool, at the price of some usage limitations.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &quot;main&quot; &#123;@code ForkJoinTask&#125; begins execution when it is</span><br><span class="line"> * explicitly submitted to a &#123;@link ForkJoinPool&#125;, or, if not already</span><br><span class="line"> * engaged in a ForkJoin computation, commenced in the &#123;@link</span><br><span class="line"> * ForkJoinPool#commonPool()&#125; via &#123;@link #fork&#125;, &#123;@link #invoke&#125;, or</span><br><span class="line"> * related methods.  Once started, it will usually in turn start other</span><br><span class="line"> * subtasks.  As indicated by the name of this class, many programs</span><br><span class="line"> * using &#123;@code ForkJoinTask&#125; employ only methods &#123;@link #fork&#125; and</span><br><span class="line"> * &#123;@link #join&#125;, or derivatives such as &#123;@link</span><br><span class="line"> * #invokeAll(ForkJoinTask...) invokeAll&#125;.  However, this class also</span><br><span class="line"> * provides a number of other methods that can come into play in</span><br><span class="line"> * advanced usages, as well as extension mechanics that allow support</span><br><span class="line"> * of new forms of fork/join processing.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A &#123;@code ForkJoinTask&#125; is a lightweight form of &#123;@link Future&#125;.</span><br><span class="line"> * The efficiency of &#123;@code ForkJoinTask&#125;s stems from a set of</span><br><span class="line"> * restrictions (that are only partially statically enforceable)</span><br><span class="line"> * reflecting their main use as computational tasks calculating pure</span><br><span class="line"> * functions or operating on purely isolated objects.  The primary</span><br><span class="line"> * coordination mechanisms are &#123;@link #fork&#125;, that arranges</span><br><span class="line"> * asynchronous execution, and &#123;@link #join&#125;, that doesn&apos;t proceed</span><br><span class="line"> * until the task&apos;s result has been computed.  Computations should</span><br><span class="line"> * ideally avoid &#123;@code synchronized&#125; methods or blocks, and should</span><br><span class="line"> * minimize other blocking synchronization apart from joining other</span><br><span class="line"> * tasks or using synchronizers such as Phasers that are advertised to</span><br><span class="line"> * cooperate with fork/join scheduling.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p><strong>ForkJoinTask：主要提供任务中fork/join的机制。</strong></p>
<blockquote>
<p>我：大家自己意会一下，但可千万不要言传哦~ 真的很容易看懂的~<br>读者：emmmmm，是挺容易的，因为它容易就容易在它容易它奶奶的腿……</p>
</blockquote>
<h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class ForkJoinTaskExample extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public static final int threshold = 2;</span><br><span class="line">    private int start;</span><br><span class="line">    private int end;</span><br><span class="line"></span><br><span class="line">    public ForkJoinTaskExample(int start, int end) &#123;</span><br><span class="line">        this.start = start;</span><br><span class="line">        this.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line"></span><br><span class="line">        //如果任务足够小就计算任务</span><br><span class="line">        boolean canCompute = (end - start) &lt;= threshold;</span><br><span class="line">        if (canCompute) &#123;</span><br><span class="line">            for (int i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果任务大于阈值，就分裂成两个子任务计算</span><br><span class="line">            int middle = (start + end) / 2;</span><br><span class="line">            ForkJoinTaskExample leftTask = new ForkJoinTaskExample(start, middle);</span><br><span class="line">            ForkJoinTaskExample rightTask = new ForkJoinTaskExample(middle + 1, end);</span><br><span class="line"></span><br><span class="line">            // 执行子任务</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line"></span><br><span class="line">            // 等待任务执行结束合并其结果</span><br><span class="line">            int leftResult = leftTask.join();</span><br><span class="line">            int rightResult = rightTask.join();</span><br><span class="line"></span><br><span class="line">            // 合并子任务</span><br><span class="line">            sum = leftResult + rightResult;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ForkJoinPool forkjoinPool = new ForkJoinPool();</span><br><span class="line"></span><br><span class="line">        //生成一个计算任务，计算1+2+3+4</span><br><span class="line">        ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);</span><br><span class="line"></span><br><span class="line">        //执行一个任务</span><br><span class="line">        Future&lt;Integer&gt; result = forkjoinPool.submit(task);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            log.info(&quot;result:&#123;&#125;&quot;, result.get());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.error(&quot;exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14:58:35.442 [main] INFO com.mmall.concurrency.aqs.ForkJoinTaskExample - result:5050</span><br></pre></td></tr></table></figure>

<h5 id="例子分析-1"><a href="#例子分析-1" class="headerlink" title="例子分析"></a>例子分析</h5><ol>
<li>该测试类需要继承<code>RecursiveTask</code>类，即在任务<code>fork</code>中需要递归地拆分任务;</li>
<li><code>ForkJoinTaskExample task = new ForkJoinTaskExample(1, 100);</code>指定<code>start</code>和<code>end</code>，其构造函数完成其任务的<code>fork</code>的具体实现，之后再将其子结果<code>join</code>并返回。</li>
<li>最后通过ForkJoinPool调用submit()执行该任务。</li>
<li>其中：在任务拆分（fork）中，声明了一个threshold（阈值），即指定任务不可拆分的界限。</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第七章 J.U.C组件拓展/">http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第七章 J.U.C组件拓展/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/并发/"># 并发</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/11/11/并发编程/慕课网java高并发/第六章 JUC之AQS/">第六章 JUC 之AQS</a>
            
            
            <a class="next" rel="next" href="/2018/11/11/并发编程/慕课网java高并发/第三章 线程安全性/">第3章 线程安全性</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
