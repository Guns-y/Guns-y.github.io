<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>第五章 线程安全策略 | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="并发">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.3">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">John Doe</h5>
          <a href="mailto:1047629166@qq.com" title="1047629166@qq.com" class="mail">
            
              <span>1</span>
            
              <span>0</span>
            
              <span>4</span>
            
              <span>7</span>
            
              <span>6</span>
            
              <span>2</span>
            
              <span>9</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/codefine" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/custom"  >
                <i class="icon icon-lg icon-plus-square"></i>
                CUSTOM
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>第五章 线程安全策略</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">第五章 线程安全策略</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-11-11T02:13:42.000Z" itemprop="datePublished" class="page-time">
  2018-11-11
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/并发/">并发</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-并发编程/慕课网java高并发/第五章 线程安全策略"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">第五章 线程安全策略</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-11-11 10:13:42" datetime="2018-11-11T02:13:42.000Z"  itemprop="datePublished">2018-11-11</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/并发/">并发</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h1 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h1><figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-013434.png" title="image-20190802082119551" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-013434.png" alt="image-20190802082119551" title class></a>
                <p>image-20190802082119551</p>
            </figure>



<p><a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-013941.png" title="image-20190802093939994" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-013941.png" alt="image-20190802093939994"></a></p>
<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-014943.png" title="image-20190802094941922" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-014943.png" alt="image-20190802094941922" title class></a>
                <p>image-20190802094941922</p>
            </figure>

<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>不可变对象一经安全发布，它就是不可变的。</p>
<h4 id="需满足的条件"><a href="#需满足的条件" class="headerlink" title="需满足的条件"></a>需满足的条件</h4><ul>
<li><p>对象创建后其状态不能被修改；</p>
</li>
<li><p>对象所有的域都是final类型；</p>
</li>
<li><p>对象是正确创建的（在对象创建期间，其this引用未逸出）；</p>
<blockquote>
<p><strong>其中可以采用的方式包括：</strong></p>
<ol>
<li>将类声明为final，不可被继承；</li>
<li>将所有的成员声明为私有的，不允许直接访问其私有成员；</li>
<li>对变量不向外提供set方法；</li>
<li>将所有成员也声明为final，只能赋值一次；</li>
<li>通过构造器初始化所有成员，进行深度拷贝;</li>
<li>在get方法中，不直接返回对象本身，而是克隆对象，并返回对象的拷贝。</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><p>可以用来修饰类、方法、变量。</p>
<ol>
<li>修饰类：该类不能被继承：如Java中的String、Integer、Long等基础类型的封装类均是。</li>
</ol>
<ul>
<li>final类中的成员变量可根据需要设定为final。</li>
<li>final类中的方法均会被隐式指为final方法。</li>
</ul>
<ol>
<li>修饰方法：场景如下</li>
</ol>
<ul>
<li><p>锁定方法不会被继承类修改；</p>
</li>
<li><p>效率：在早期的Java实现版本中，会将final方法转为内嵌调用；但若final方法过大，反而拉低效率。</p>
</li>
<li><blockquote>
<p><strong>一个类的private方法会被隐式地指为final方法。</strong></p>
</blockquote>
</li>
</ul>
<ol>
<li>修饰变量：</li>
</ol>
<ul>
<li>若修饰基础数据类型：一旦初始化就不再更改。</li>
<li>若修饰引用类型：一旦初始化之后就不能再指向另一个对象。 但可以修改其中的值。 （好吧，这是废话… ）</li>
</ul>
<figure class="highlight plain"><figcaption><span>a</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@NotThreadSafe  //非线程安全</span><br><span class="line">public class ImmutableExample1 &#123;</span><br><span class="line"></span><br><span class="line">    private final static Integer a = 1;</span><br><span class="line">    private final static String b = &quot;2&quot;;</span><br><span class="line">    private final static Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        map.put(1, 2);</span><br><span class="line">        map.put(3, 4);</span><br><span class="line">        map.put(5, 6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        map.put(1, 3);</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, map.get(1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void test(final int a) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015408.png" title="image-20190802095406237" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015408.png" alt="image-20190802095406237" title class></a>
                <p>image-20190802095406237</p>
            </figure>

<hr>
<h4 id="Collections-unmodifiableXXX方法"><a href="#Collections-unmodifiableXXX方法" class="headerlink" title="Collections.unmodifiableXXX方法"></a>Collections.unmodifiableXXX方法</h4><p>其中XXX可以是Collection、List、Set、Map等<br><strong>相应的可以通过传入对应的数据类型作为参数传入方法，即可变为不可变对象。</strong></p>
<p>看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">//调用unmodifiableMap方法</span></span><br><span class="line">        map = Collections.unmodifiableMap(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, map.get(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015523.png" title="image-20190802095459825" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015523.png" alt="image-20190802095459825" title class></a>
                <p>image-20190802095459825</p>
            </figure>

<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015527.png" title="image-20190802095526211" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015527.png" alt="image-20190802095526211" title class></a>
                <p>image-20190802095526211</p>
            </figure>

<hr>
<h4 id="Guava的ImmutableXXX类"><a href="#Guava的ImmutableXXX类" class="headerlink" title="Guava的ImmutableXXX类"></a>Guava的ImmutableXXX类</h4><p>相似的，其中XXX可以是<code>Collection</code>、<code>List</code>、<code>Set</code>、<code>Map</code>等<br><strong>这些类都提供了带初始化数据的声明方法，一旦初始化完成就成不可变对象了。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableList&lt;Integer&gt; list = ImmutableList.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableSet set = ImmutableSet.copyOf(list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map = ImmutableMap.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ImmutableMap&lt;Integer, Integer&gt; map2 = ImmutableMap.&lt;Integer, Integer&gt;builder()</span><br><span class="line">            .put(<span class="number">1</span>, <span class="number">2</span>).put(<span class="number">3</span>, <span class="number">4</span>).put(<span class="number">5</span>, <span class="number">6</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(map2.get(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：4</p>
<p><strong>例子分析：</strong></p>
<ol>
<li><code>ImmutableList</code>通过<code>of(a,b,c,xxxx)</code>方法来填充数据，其中的数据为初始化的数据。</li>
<li><code>copyOf(xx)</code>方法直接拷贝其他集合中数据。</li>
<li>通过<code>builder().put(a, b)..put(x, x).(...).build()</code>不停<code>put(x,x)</code>填充数据。</li>
</ol>
<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015618.png" title="image-20190802095616884" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015618.png" alt="image-20190802095616884" title class></a>
                <p>image-20190802095616884</p>
            </figure>

<hr>
<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015739.png" title="image-20190802095725495" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-015739.png" alt="image-20190802095725495" title class></a>
                <p>image-20190802095725495</p>
            </figure>

<hr>
<h1 id="2-线程封闭"><a href="#2-线程封闭" class="headerlink" title="2 线程封闭"></a>2 线程封闭</h1><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>线程封闭是一种较为简单的线程并发的方法。它其实把对象封装到一个线程里，该对象只对该线程是可见的。当然也就是线程安全的了。</p>
<h4 id="实现线程封闭的方法"><a href="#实现线程封闭的方法" class="headerlink" title="实现线程封闭的方法"></a>实现线程封闭的方法</h4><ol>
<li>Ad-hoc 线程封闭：依赖程序控制实现，脆弱，是最糟糕的一种方式，不推荐！</li>
<li>堆栈封闭：应用广泛，依靠各线程局部变量的堆栈拷贝副本实现，无并发问题。避免使用全局变量。</li>
<li>数据库连接对应JDBC的Connection对象。</li>
<li>ThreadLocal线程封闭：实现较好，效率较高。（以后会做源码分析……）</li>
</ol>
<h4 id="ThreadLocal测试例子"><a href="#ThreadLocal测试例子" class="headerlink" title="ThreadLocal测试例子"></a>ThreadLocal测试例子</h4><h5 id="RequestHolder-java"><a href="#RequestHolder-java" class="headerlink" title="RequestHolder.java"></a>RequestHolder.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; requestHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        requestHolder.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        requestHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法分析：</p>
<ol>
<li>该类存放需要绑定的信息。</li>
<li>其中add操作是在请求进入后端服务器，但还未进行实际处理时，调用该方法，写入相关信息。（通过filter：先拦截对应的URL，当前台访问该URL时，将相关信息写入ThreadLocal中；当URL实际被处理时，可直接从ThreadLocal中取出信息）。</li>
<li>定义移除方法，防止内存泄漏。在接口处理完之后进行处理（通过intercepter实现）。</li>
</ol>
<h5 id="HttpFilter-java"><a href="#HttpFilter-java" class="headerlink" title="HttpFilter.java"></a>HttpFilter.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"do filter, &#123;&#125;, &#123;&#125;"</span>, Thread.currentThread().getId(), request.getServletPath());</span><br><span class="line"></span><br><span class="line">        RequestHolder.add(Thread.currentThread().getId());</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法分析：</p>
<ol>
<li>因为是通过http请求，ServletRequest需转换为HttpServletRequest类型。</li>
<li>在RequestHolder中放入URL相关信息。</li>
<li>最后若该filter不是想拦截住该请求，只是做相关的数据处理，还想让其他过滤器接收到，则需最后调用filterChain.doFilter(servletRequest, servletResponse)。</li>
</ol>
<h5 id="HttpInterceptor-java"><a href="#HttpInterceptor-java" class="headerlink" title="HttpInterceptor.java"></a>HttpInterceptor.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在处理之前输出</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在完成之后删除信息、输出日志</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RequestHolder.remove();</span><br><span class="line">        log.info(<span class="string">"afterCompletion"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ThreadLocalController-java"><a href="#ThreadLocalController-java" class="headerlink" title="ThreadLocalController.java"></a>ThreadLocalController.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/threadlocal"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RequestHolder.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ConcurrencyApplication-java"><a href="#ConcurrencyApplication-java" class="headerlink" title="ConcurrencyApplication.java"></a>ConcurrencyApplication.java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span><span class="comment">//使用springboot快速进行测试</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">truepublic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueSpringApplication.run(ConcurrencyApplication.class, args);</span><br><span class="line"><span class="keyword">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span><span class="meta">@Bean</span></span><br><span class="line"><span class="function">truepublic FilterRegistrationBean <span class="title">httpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">truetrueFilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">truetrueregistrationBean.setFilter(<span class="keyword">new</span> HttpFilter());</span><br><span class="line"></span><br><span class="line">truetrueregistrationBean.addUrlPatterns(<span class="string">"/threadlocal/*"</span>);</span><br><span class="line">truetruereturn registrationBean;</span><br><span class="line"><span class="keyword">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span><span class="meta">@Override</span></span><br><span class="line"><span class="function">truepublic <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">truetrueregistry.addInterceptor(<span class="keyword">new</span> HttpInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line"><span class="keyword">true</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法分析：</p>
<ol>
<li>通过springboot创建registrationBean并指定过滤URL类型为”/threadlocal/*”。</li>
<li>重写addInterceptors -&gt; 添加拦截器，并指定拦截的路径类型。</li>
<li>ThreadLocalController.java中指定请求映射的名称和返回内容。</li>
</ol>
<p><strong>接口测试结果：(使用Postman进行接口测试)</strong></p>
<p> <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-233303.png" title="image-20190803073300869" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-233303.png" alt="image-20190803073300869"></a></p>
<p><strong>日志部分截图：</strong></p>
<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-233239.png" title="image-20190803073237701" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-233239.png" alt="image-20190803073237701" title class></a>
                <p>image-20190803073237701</p>
            </figure>

<p>可以看出例子是和日志完全对应的。<br>重复一下<em>threadlocal的实现思想</em>：<strong>当一个请求进来时，通过过滤器Filter，将数据信息（这里是线程id）存储到threadlocal中，当接口被调用处理时，可以直接从中取出来；当接口处理完成，通过拦截器Interceptor的afterCompletion把当前线程中的数据信息（这里是线程id）移除，避免内存泄漏。</strong></p>
<hr>
<hr>
<hr>
<p>1、什么是线程封闭？</p>
<p>它其实就是把对象封装到一个线程里，只有一个线程能看到这个对象，那么这个对象就算不是线程安全的，也不会出现任何线程安全方面的问题。</p>
<p>线程封闭技术有一个常见的应用：</p>
<p>数据库连接对应jdbc的Connection对象，Connection对象在实现的时候并没有对线程安全做太多的处理，jdbc的规范里也没有要求Connection对象必须是线程安全的。<br>实际在服务器应用程序中，线程从连接池获取了一个Connection对象，使用完再把Connection对象返回给连接池，由于大多数请求都是由单线程采用同步的方式来处理的，并且在Connection对象返回之前，连接池不会将它分配给其他线程。因此这种连接管理模式处理请求时隐含的将Connection对象封闭在线程里面，这样我们使用的connection对象虽然本身不是线程安全的，但是它通过线程封闭也做到了线程安全。<br>2、线程封闭的种类：</p>
<p>（1）Ad-hoc 线程封闭：</p>
<p>Ad-hoc线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。事实上，对线程封闭对象（例如，GUI应用程序中的可视化组件或数据模型等）的引用通常保存在公有变量中。</p>
<p>（2）堆栈封闭：<br>堆栈封闭其实就是方法中定义局部变量。不存在并发问题。多个线程访问一个方法的时候，方法中的局部变量都会被拷贝一份到线程的栈中（Java内存模型），所以局部变量是不会被多个线程所共享的。</p>
<h2 id="（3）ThreadLocal线程封闭："><a href="#（3）ThreadLocal线程封闭：" class="headerlink" title="（3）ThreadLocal线程封闭： "></a>（3）ThreadLocal线程封闭： </h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它是一个特别好的封闭方法，其实ThreadLocal内部维护了一个map,map的key是每个线程的名称，而map的value就是我们要封闭的对象。ThreadLocal提供了get、set、remove方法，每个操作都是基于当前线程的，所以它是线程安全的。</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-234211.png" title="image-20190803074210365" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-02-234211.png" alt="image-20190803074210365" title class></a>
                <p>image-20190803074210365</p>
            </figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal的get方法源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();<span class="comment">//当前线程对象</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);<span class="comment">//get操作基于当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、Springboot框架中使用ThreadLocal"><a href="#3、Springboot框架中使用ThreadLocal" class="headerlink" title="3、Springboot框架中使用ThreadLocal"></a>3、Springboot框架中使用ThreadLocal</h2><p>Coding：<br>（1）创建一个包含ThreadLocal对象的类，并提供基础的添加、删除、获取操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; requestHolder = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        requestHolder.set(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> requestHolder.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        requestHolder.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）创建Filter，在Filter中对ThreadLocal做添加操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ServletResponse servletResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">                         FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="comment">//打印当前线程的ID与请求路径</span></span><br><span class="line">        log.info(<span class="string">"do filter, &#123;&#125;, &#123;&#125;"</span>, Thread.currentThread().getId(), request.getServletPath());</span><br><span class="line">        <span class="comment">//将当前线程ID添加到ThreadLocal中</span></span><br><span class="line">        RequestHolder.add(Thread.currentThread().getId());</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)创建controller，在controller中获取到filter中存入的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/threadLocal"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RequestHolder.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）创建拦截器Interceptor，在拦截器中删除刚才添加的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                            Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        RequestHolder.remove();</span><br><span class="line">        log.info(<span class="string">"afterCompletion"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（5）在springboot的启动类Application中注册filter与Interceptor。要继承WebMvcConfigurerAdapter 类。（我这里的启动类名为：ConcurrencyApplication）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyApplication</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConcurrencyApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册过滤器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">httpFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean registrationBean = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">        registrationBean.setFilter(<span class="keyword">new</span> HttpFilter());</span><br><span class="line">        <span class="comment">//设置要过滤的url</span></span><br><span class="line">        registrationBean.addUrlPatterns(<span class="string">"/threadLocal/*"</span>);</span><br><span class="line">        <span class="keyword">return</span> registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> HttpInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）运行程序，访问  <a href="http://localhost:8080/threadLocal/test" target="_blank" rel="noopener">http://localhost:8080/threadLocal/test</a> 结果如下</p>
<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-03-000609.png" title="image-20190803080322001" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-03-000609.png" alt="image-20190803080322001" title class></a>
                <p>image-20190803080322001</p>
            </figure>

<blockquote>
<p>从控制台的打印日志我们可以看出，首先filter过滤器先获取到我们当前的线程ID为40、我们当前的请求路径为/threadLocal/test ，紧接着进入了我们的Interceptor的preHandle方法中，打印了preHandle字样。最后进入了我们的Interceptor的afterCompletion方法，删除了我们之前存入的值，并打印了afterCompletion字样。</p>
</blockquote>
<hr>
<h1 id="3-线程不安全类与写法"><a href="#3-线程不安全类与写法" class="headerlink" title="3 线程不安全类与写法"></a>3 线程不安全类与写法</h1><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>线程不安全类：如果一个类的对象同时被多个线程访问，若不做相应的同步或并发处理，容易出现线程不安全的现象，比如：抛出异常、逻辑处理错误等。</p>
</blockquote>
<h4 id="StringBiulder"><a href="#StringBiulder" class="headerlink" title="StringBiulder"></a>StringBiulder</h4><p>看一个例子：（借助之前的例子结构）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, stringBuilder.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stringBuilder.append(<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果分析：</strong></p>
<ol>
<li>多次运行，结果几乎未达5000，显然StringBuilder是非线程安全的。</li>
<li>通过定义stringBuilder对象，核心方法为update() -&gt; 每次拼接一个字符串，最后取其长度length。</li>
</ol>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><blockquote>
<p>例子代码结构跟上面一样，只需将StringBiulder换为StringBuffer，且其两者方法名相同。</p>
</blockquote>
<p><strong>运行结果：</strong><br>多次运行，结果均为5000。StringBuffer是线程安全的！查看StringBuffer源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuffer</span></span></span><br><span class="line"><span class="class">   <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">   <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span>&#123;XXX省略&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>源码分析：</strong></p>
<ol>
<li>几乎所有复写的方法都有toStringCache变量。为对象方便转为String类型的字段，调用Arrays.copyOfRange(value, 0, count)，return new String(toStringCache, true)：其中该构造方法是String包私有的构造方法，以确保数值分享的效率。</li>
<li>StringBuffer继承自AbstractStringBuilder，并几乎重写了所有继承来的方法。调用父辈super的append方法，即AbstractStringBuilder的方法。且StringBuffer对象一经修改，toStringCache清空为null。类似String包装类的对象，避免多线程并发问题。（以后细说String包装类…）</li>
<li>为了线程安全，几乎所有复写的方法都用synchronized进行标识，即使效率较低。</li>
<li>StringBiulder性能好，但不适用于多线程。但适用于场景为方法内的局部变量操作（上篇线程封闭的手记中说到：隐式的堆栈封闭），线程安全且性能较好。</li>
</ol>
<hr>
<h4 id="SimpleDateFormate"><a href="#SimpleDateFormate" class="headerlink" title="SimpleDateFormate"></a>SimpleDateFormate</h4><blockquote>
<p>Java提供的供日期转换的类。该例子结构仍然和上述例子相同。只需定义一个simpleDateFormat实例，核心方法换为parse（xxx:日期语句）</p>
</blockquote>
<p><strong>运行结果：</strong><br>出现异常：<code>parse exception -- java.lang.NumberFormatException: multiple points</code><br>非常简单，说明了该日期转换方法是非线程间安全的。</p>
<h5 id="正确写法：（通过堆栈封闭-gt-声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）"><a href="#正确写法：（通过堆栈封闭-gt-声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）" class="headerlink" title="正确写法：（通过堆栈封闭-&gt;声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）"></a>正确写法：（通过堆栈封闭-&gt;声明为核心方法内的局部变量，即每次声明一个新的对象进行调用）</h5><blockquote>
<p>仍然是之前的测试结构，但还是贴出来看看吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Slf</span>4j</span><br><span class="line">&gt; <span class="meta">@ThreadSafe</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatExample2</span> </span>&#123;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// 请求总数</span></span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&gt;         ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">&gt;         <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">&gt;         <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">&gt;         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">&gt;             executorService.execute(() -&gt; &#123;</span><br><span class="line">&gt;                 <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;                     semaphore.acquire();</span><br><span class="line">&gt;                     update();</span><br><span class="line">&gt;                     semaphore.release();</span><br><span class="line">&gt;                 &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&gt;                     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&gt;                 &#125;</span><br><span class="line">&gt;                 countDownLatch.countDown();</span><br><span class="line">&gt;             &#125;);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         countDownLatch.await();</span><br><span class="line">&gt;         executorService.shutdown();</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;             SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">&gt;             simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">&gt;         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&gt;             log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>运行结果：</strong> 多次运行，不会报错！是线程安全！</p>
<h4 id="Joda-Time"><a href="#Joda-Time" class="headerlink" title="Joda Time"></a>Joda Time</h4><blockquote>
<p>该类本质上并不属于Java提供。需引入jar包。例子仍然是之前的测试结构。只不过日志输出了次数及当时日期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="comment">//转换完后DateTime，调用toDate()转为Date对象。</span></span><br><span class="line">&gt;     log.info(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, i == <span class="number">4999</span> ? i+<span class="string">"--------------------------"</span> : i, DateTime.parse(<span class="string">"20180728"</span>, dateTimeFormatter).toDate());</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于调用是多并发的，调用次序是乱序，但总数一定！</span><br><span class="line"></span><br><span class="line">  由于i是从0到4999，即当i = 4999时说明已运行慢5000个，即线程安全！</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Collections部分"><a href="#Collections部分" class="headerlink" title="Collections部分"></a>Collections部分</h3><blockquote>
<p>一般情况下，我们使用ArrayList、HashSet、HashMap是在方法中定义局部变量，此时由于堆栈封闭的特性，自然不会有线程安全问题。但是，当将其定义为静态域中，且未做线程安全措施时，极有可能会导致多线程并发错误。</p>
</blockquote>
<p><strong>由于该三个集合是Java中最常见的、最重要的集合，此处仅分析说明是非线程安全的类。其详细内容我会另起手记再做说明！！</strong></p>
<h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>弄个例子：(还是之前的框架)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; list.add(i); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13:31:39.296 [main] INFO com.mmall.concurrency.commonUnsafe.ArrayListExample - size:4986</span><br></pre></td></tr></table></figure>

<p>显而易见，是非线程安全的。</p>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><p>同理，HashSet同样进行测试，结果表明同样是非线程安全的！</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>同理，HashMap同样进行测试，结果表明同样是非线程安全的！</p>
<h3 id="线程不安全的写法"><a href="#线程不安全的写法" class="headerlink" title="线程不安全的写法"></a>线程不安全的写法</h3><p><strong>先检查再执行</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aaaa)</span><br><span class="line">&#123;</span><br><span class="line">  bbbbbbbbb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个较易解释，在之前说AtomicXXX时说过：<br>在多线程并发时，可能多个线程执行到<code>if</code>语句的判断，且同时符合，然后分别作出修改。即该操作的原子性不能得到保证！故当有多线程并发问题时，考虑清楚，加锁进行处理。</p>
<hr>
<hr>
<h1 id="3-2-线程不安全的类"><a href="#3-2-线程不安全的类" class="headerlink" title="3.2 线程不安全的类"></a>3.2 线程不安全的类</h1><p>如果一个类的对象同时可以被多个线程访问，并且你不做特殊的同步或并发处理，那么它就很容易表现出线程不安全的现象。比如抛出异常、逻辑处理错误…<br>下面列举一下常见的线程不安全的类及对应的线程安全类：</p>
<p>（1）StringBuilder 与 StringBuffer</p>
<p>StringBuilder是线程不安全的，而StringBuffer是线程安全的。分析源码：StringBuffer的方法使用了synchronized关键字修饰。</p>
<hr>
<hr>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        toStringCache = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="SimpleDateFormat-与-jodatime插件"><a href="#SimpleDateFormat-与-jodatime插件" class="headerlink" title="SimpleDateFormat 与 jodatime插件"></a>SimpleDateFormat 与 jodatime插件</h5><p>SimpleDateFormat 类在处理时间的时候，如下写法是线程不安全的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是我们可以变换其为线程安全的写法：在每次转换的时候使用线程封闭，新建变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">        simpleDateFormat.parse(<span class="string">"20180208"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"parse exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外我们也可以使用jodatime插件来转换时间：其可以保证线程安全性<br>Joda 类具有不可变性，因此它们的实例无法被修改。（不可变类的一个优点就是它们是线程安全的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, i, DateTime.parse(<span class="string">"20180208"</span>, dateTimeFormatter).toDate());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList,HashSet,HashMap 等Collection类</p>
<p>像ArrayList,HashSet,HashMap 等Collection类均是线程不安全的，我们以ArrayList举例分析一下源码：<br>1、ArrayList的基本属性： </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 在声明时使用了transient 关键字，此关键字意为在采用Java默认的序列化机制的时候，被该关键字修饰的属性不会被序列化。而ArrayList实现了序列化接口，自己定义了序列化方法（在此不描述）。</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象数组：ArrayList的底层数据结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">//elementData中已存放的元素的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//默认数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>2、初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 创建一个容量为initialCapacity的空的（size==0）对象数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>();<span class="comment">//即父类protected AbstractList() &#123;&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity:"</span> + initialCapacity);</span><br><span class="line">  <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 默认初始化一个容量为10的对象数组</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>3、添加方法（重点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次添加时将数组扩容1，然后再赋值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、总结：ArrayList每次对内容进行插入操作的时候，都会做扩容处理，这是ArrayList的优点（无容量的限制），同时也是缺点，线程不安全。（以下例子取材于鱼笑笑博客）<br>一个 ArrayList ，在添加一个元素的时候，它可能会有两步来完成：</p>
<p>在 Items[Size] 的位置存放此元素；<br>增大 Size 的值。<br>在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；<br>而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。 那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。</p>
<blockquote>
<p>那么如何将其处理为线程安全的？或者说对应的线程安全类有哪些呢？接下来就涉及到我们同步容器</p>
</blockquote>
<hr>
<hr>
<h1 id="4-1同步容器"><a href="#4-1同步容器" class="headerlink" title="4-1同步容器"></a>4-1同步容器</h1><p>同步容器分两类，一种是Java提供好的类，另一类是Collections类中的相关同步方法。</p>
<p>（1）ArrayList的线程安全类：Vector,Stack</p>
<p>Vector实现了List接口，Vector实际上就是一个数组，和ArrayList非常的类似，但是内部的方法都是使用synchronized修饰过的方法。<br>Stack它的方法也是使用synchronized修饰了，继承了Vector，实际上就是栈<br>使用举例（Vector）：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"><span class="comment">//多线程调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">   list.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析：使用了synchronized修饰</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是Vector也不是完全的线程安全的，比如：<br><strong>错误[1]：</strong>删除与获取并发操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：报错java.lang.ArrayIndexOutOfBoundsException: Array index out of range </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 原因分析：同时发生获取与删除的操作。当两个线程在同一时间都判断了vector的size，假设都判断为9，而下一刻线程1执行了remove操作，随后线程2才去get，所以就出现了错误。synchronized关键字可以保证同一时间只有一个线程执行该方法，但是多个线程同时分别执行remove、add、get操作的时候就无法控制了。</span><br></pre></td></tr></table></figure>

<p><strong>错误[2]：</strong>使用foreach\iterator遍历Vector的时候进行增删操作 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报错java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer i = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1.get(i).equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line">        vector.add(<span class="number">2</span>);</span><br><span class="line">        vector.add(<span class="number">3</span>);</span><br><span class="line">        test1(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   2）HashMap的线程安全类：HashTable</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> Hashtable&lt;&gt;();</span><br><span class="line"><span class="comment">//多线程调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    map.put(i, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<p>保证安全性：使用了synchronized修饰<br>不允许空值（在代码中特殊做了判断）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap和HashTable都使用哈希表来存储键值对。在数据结构上是基本相同的，都创建了一个继承自Map.Entry的私有的内部类Entry，每一个Entry对象表示存储在哈希表中的一个键值对。</span><br></pre></td></tr></table></figure>



<blockquote>
<p> Entry对象唯一表示一个键值对，有四个属性：<br>-K key 键对象<br>-V value 值对象<br>-int hash 键对象的hash值<br>-Entry entry 指向链表中下一个Entry对象，可为null，表示当前Entry对象在链表尾部</p>
</blockquote>
<p>public synchronized V put(K key, V value) {<br>    // Make sure the value is not null<br>    if (value == null) {<br>        throw new NullPointerException();<br>    }</p>
<pre><code>// Makes sure the key is not already in the hashtable.
Entry&lt;?,?&gt; tab[] = table;
int hash = key.hashCode();
int index = (hash &amp; 0x7FFFFFFF) % tab.length;
@SuppressWarnings(&quot;unchecked&quot;)
Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];
for(; entry != null ; entry = entry.next) {
    if ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) {
        V old = entry.value;
        entry.value = value;
        return old;
    }
}

addEntry(hash, key, value, index);
return null;</code></pre><p> （3）Collections类中的相关同步方法</p>
<p>Collections类中提供了一系列的线程安全方法用于处理ArrayList等线程不安全的Collection类 </p>
<p><a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-03-010329.png" title="image-20190803090328516" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-03-010329.png" alt="image-20190803090328516"></a></p>
<p>使用方法：</p>
<p>//定义</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());</span><br><span class="line"><span class="comment">//多线程调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    list.add(i);</span><br><span class="line"></span><br><span class="line">## &#125;</span><br></pre></td></tr></table></figure>

<p> 源码分析：<br>内部操作的方法使用了synchronized修饰符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">SynchronizedCollection</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h1 id="4-2-同步容器"><a href="#4-2-同步容器" class="headerlink" title="4-2 同步容器"></a>4-2 同步容器</h1><blockquote>
<p>本节内容不仅丰富而且十分有趣实用~</p>
</blockquote>
<h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>同步容器大致分为两类：</p>
<ol>
<li>由<code>List</code>发展来的<code>Vector</code>、<code>Stack</code>；由<code>HashMap</code>发展来的<code>HashTable</code>（其中K,V均不能为null）</li>
<li><code>Collections</code>工具类提供的静态工厂方法 –&gt; 均为<code>synchronizedXXXX(List/Set/Map)</code>的模样。</li>
</ol>
</blockquote>
<p>看个例子：(好吧，这个测试的框架都快看恶心了ORZ)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = i;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    update(count);</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"size:&#123;&#125;"</span>, list.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;list.add(i);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14:10:04.044 [main] INFO com.mmall.concurrency.syncContainer.VectorExample1 - size:5000</span><br></pre></td></tr></table></figure>

<p>看一下<code>Vector</code>的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他方法同理，基本都使用synchronized进行标识。<br><strong>但是！！</strong><br><strong>同步容器不一定就是线程安全的！</strong></p>
<p>再看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.get(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="image-box">
                <a rel=第五章 线程安全策略 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-03-010729.png" title="image-20190803090726993" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-03-010729.png" alt="image-20190803090726993" title class></a>
                <p>image-20190803090726993</p>
            </figure>

<p>既然Vector的remove和get方法都抛出ArrayIndexOutOfBoundsException异常，那看一下源码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the element at the specified position in this Vector.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index index of the element to return</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> object at the specified index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ArrayIndexOutOfBoundsException if the index is out of range</span></span><br><span class="line"><span class="comment"> *            (&#123;<span class="doctag">@code</span> index &lt; 0 || index &gt;= size()&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>源码分析：</strong></p>
<ol>
<li><code>get</code>方法出现该异常一定是<code>remove</code>方法造成的。</li>
<li>数组越界情况为：<code>index &lt; 0</code> 或 <code>index &gt;= size()</code>。但既然是remove方法，那应该只能是index小于0或index不存在的情况了。</li>
<li><strong>同步容器不一定就能保证线程并发安全。</strong></li>
</ol>
<p><strong>例子情况分析：</strong>（常见的多线程间执行顺序的差异导致）<br>在其中的for循环中，当一个线程调用get方法时（其中其下标设为i），另一个线程恰好在前一时刻调用了remove方法（恰好其下标也是i），此时下标为i的数据已经不存在，便抛出ArrayIndexOutOfBoundsException异常。</p>
<p>再来看一个Vector的测试例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorExample3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// foreach</span></span><br><span class="line">        <span class="keyword">for</span>(Integer i : v1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// java.util.ConcurrentModificationException</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// iterator</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = v1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Integer i = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (i.equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(Vector&lt;Integer&gt; v1)</span> </span>&#123; <span class="comment">// for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1.get(i).equals(<span class="number">3</span>)) &#123;</span><br><span class="line">                v1.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        vector.add(<span class="number">1</span>);</span><br><span class="line">        vector.add(<span class="number">2</span>);</span><br><span class="line">        vector.add(<span class="number">3</span>);</span><br><span class="line">        test1(vector);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<ol>
<li>main函数执行test1(vector)时，抛出java.util.ConcurrentModificationException；</li>
<li>main函数执行test2(vector)时，抛出java.util.ConcurrentModificationException；</li>
<li>main函数执行test3(vector)时，程序正常结束。</li>
</ol>
<p><strong>结果分析：</strong><br>使用迭代器iterator或foreach循环（加强版for循环）会抛出并发修改异常；但一般for语句正常结束。</p>
<p>废话不多说，看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> elementData(lastRet = i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet == -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    <span class="keyword">synchronized</span> (Vector.<span class="keyword">this</span>) &#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        Vector.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor = lastRet;</span><br><span class="line">    lastRet = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>源码分析：</strong><br>由于迭代器<code>iterator</code>或<code>foreach</code>循环中的<code>remove</code>操作使得<code>modCount != expectedModCount</code>，即修改后的<code>count</code>与期望的<code>count</code>不一致，定是并发过程中<code>Vector</code>被修改；但<code>for循环</code>每次循环都会重新计算i,此时<code>Vector</code>已被更新……（好吧，我承认，我其实这里还是不太懂，<code>for</code>循环这里只是我的猜想。）<br><strong>解决方案：</strong><br>在讯循环中不要进行修改操作：</p>
<ol>
<li>先查，若有需要进行修改的对象，则做上标记</li>
<li>循环之后进行修改</li>
</ol>
<p><strong>当使用迭代器iterator迭代时，使用synchronized或Lock做同步措施（也可以使用并发容器copyOnWriteArrayList等代替ArrayList或Vector）</strong></p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>继承了Vector，其两者用法基本一致。只不过它是一个LIFO的数据结构。</p>
<h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>好吧，其实用的还是那套框架，换一下实例声明的名字就行了。</p>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15:05:24.433 [main] INFO com.mmall.concurrency.syncContainer.HashTableExample - size:5000</span><br></pre></td></tr></table></figure>

<p>既然是线程安全的，再看一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好吧，还是synchronized标识修饰方法。故HashTable是一个线程安全的同步容器。</p>
<h4 id="Collections工具类方法"><a href="#Collections工具类方法" class="headerlink" title="Collections工具类方法"></a>Collections工具类方法</h4><h5 id="synchronizedList"><a href="#synchronizedList" class="headerlink" title="synchronizedList"></a>synchronizedList</h5><p>例子：（还是原来的配方，还是熟悉的测试框架…不过实例声明换成Collections的方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;Integer&gt; list = Collections.synchronizedList(Lists.newArrayList());</span><br></pre></td></tr></table></figure>

<p>好吧，非常不幸的告诉你，它的运行结果还是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15:20:49.641 [main] INFO com.mmall.concurrency.syncContainer.CollectionsExample1 - size:5000</span><br></pre></td></tr></table></figure>

<p>不管怎样，来都来了，那看一下源码：（没错，注释已经“入党”，已经自动汉化了）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/ **</span><br><span class="line">     *返回由指定的支持的同步（线程安全）列表</span><br><span class="line">     *清单。为了保证串行访问，至关重要的是</span><br><span class="line">     * &lt;strong&gt;所有&lt;/ strong&gt;对支持列表的访问权限已完成</span><br><span class="line">     *通过返回的列表。&lt;p&gt;</span><br><span class="line">     *</span><br><span class="line">     *用户必须手动地同步返回的内容</span><br><span class="line">     *迭代时列出：</span><br><span class="line">     * &lt;pre&gt;</span><br><span class="line">     * List list = Collections.synchronizedList（<span class="keyword">new</span> ArrayList（））;</span><br><span class="line">     * ......</span><br><span class="line">     * <span class="keyword">synchronized</span>（list）&#123;</span><br><span class="line">     * Iterator i = list.iterator（）; <span class="comment">//必须在同步块中</span></span><br><span class="line">     * <span class="keyword">while</span>（i.hasNext（））</span><br><span class="line">     * foo（i.next（））;</span><br><span class="line">     *&#125;</span><br><span class="line">     * &lt;/ pre&gt;</span><br><span class="line">     *不遵循此建议可能会导致非确定性行为。</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;如果指定的列表是，则返回的列表将是可序列化的</span><br><span class="line">     *可序列化。</span><br><span class="line">     *</span><br><span class="line">     * <span class="meta">@param</span> &lt;T&gt;列表中对象的类</span><br><span class="line">     * <span class="meta">@param</span>列出要在同步列表中“包装”的列表。</span><br><span class="line">     * <span class="meta">@return</span>指定列表的同步视图。</span><br><span class="line">     * /</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">                <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">                <span class="keyword">new</span> SynchronizedList&lt;&gt;(list));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意到</strong>，这竟然还有SynchronizedRandomAccessList和SynchronizedList之分？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRandomAccessList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">SynchronizedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    SynchronizedRandomAccessList(List&lt;E&gt; list) &#123;</span><br><span class="line">        <span class="keyword">super</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可知SynchronizedRandomAccessList继承SynchronizedList，并实现了RandomAccess接口。<br>那这接口是什么鬼？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public interface RandomAccess &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没了，他就只是个接口……</p>
<blockquote>
<p>读者：求你了，看一下注释吧，老哥~<br>我：emmmm，行~~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; /**</span><br><span class="line">&gt;   * 标记接口被&lt;tt&gt; List &lt;/ tt&gt;用来指示</span><br><span class="line">&gt;   *它们支持快速（通常是恒定时间）随机访问。</span><br><span class="line">&gt;   *此接口的首要目的是允许通用算法更改它们，</span><br><span class="line">&gt;   *当被应用于随机或顺序访问多个列表时，</span><br><span class="line">&gt;   *以提供良好性能</span><br><span class="line">&gt; */</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>读者：泥垢了！！<del>~<br>我：emmmm</del></p>
</blockquote>
<h5 id="synchronizedSet"><a href="#synchronizedSet" class="headerlink" title="synchronizedSet"></a>synchronizedSet</h5><p>只是把上面的例子的实例换成Set罢了、、</p>
<h5 id="synchronizedMap"><a href="#synchronizedMap" class="headerlink" title="synchronizedMap"></a>synchronizedMap</h5><p>只是把上面的例子的实例换Map罢了、、</p>
<hr>
<hr>
<p>4-3 并发容器及安全共享策略总结</p>
<p>概述</p>
<p>Java并发容器JUC是三个单词的缩写。是JDK下面的一个包名。即Java.util.concurrency。<br>上一节我们介绍了ArrayList、HashMap、HashSet对应的同步容器保证其线程安全，这节我们介绍一下其对应的并发容器。</p>
<p>ArrayList –&gt; CopyOnWriteArrayList</p>
<p>CopyOnWriteArrayList 写操作时复制，当有新元素添加到集合中时，从原有的数组中拷贝一份出来，然后在新的数组上作写操作，将原来的数组指向新的数组。整个数组的add操作都是在锁的保护下进行的，防止并发时复制多份副本。读操作是在原数组中进行，不需要加锁</p>
<p>缺点：<br>1.写操作时复制消耗内存，如果元素比较多时候，容易导致young gc 和full gc。<br>2.不能用于实时读的场景.由于复制和add操作等需要时间，故读取时可能读到旧值。<br>能做到最终一致性，但无法满足实时性的要求，更适合读多写少的场景。<br>如果无法知道数组有多大，或者add,set操作有多少，慎用此类,在大量的复制副本的过程中很容易出错。</p>
<p>设计思想：<br>1.读写分离<br>2.最终一致性<br>3.使用时另外开辟空间，防止并发冲突</p>
<p>源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;<span class="comment">//使用对象数组来承载数据</span></span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList.class)</span><br><span class="line">        elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[].class)</span><br><span class="line">            elements = Arrays.copyOf(elements, elements.length, Object[].class);</span><br><span class="line">    &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加数据方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//使用重入锁，保证线程安全</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();<span class="comment">//获取当前数组数据</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//复制当前数组并且扩容+1</span></span><br><span class="line">        newElements[len] = e;<span class="comment">//将要添加的数据放入新数组</span></span><br><span class="line">        setArray(newElements);<span class="comment">//将原来的数组指向新的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数据方法，与普通的get没什么差别</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HashSet-–-gt-CopyOnWriteArraySetHashSet-–-gt-CopyOnWriteArraySet"><a href="#HashSet-–-gt-CopyOnWriteArraySetHashSet-–-gt-CopyOnWriteArraySet" class="headerlink" title="HashSet –&gt; CopyOnWriteArraySetHashSet –&gt; CopyOnWriteArraySet"></a>HashSet –&gt; CopyOnWriteArraySetHashSet –&gt; CopyOnWriteArraySet</h5><p>它是线程安全的，底层实现使用的是CopyOnWriteArrayList，因此它也适用于大小很小的set集合，只读操作远大于可变操作。因为他需要copy整个数组，所以包括add、remove、set它的开销相对于大一些。<br>迭代器不支持可变的remove操作。使用迭代器遍历的时候速度很快，而且不会与其他线程发生冲突。<br>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();<span class="comment">//底层使用CopyOnWriteArrayList</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素方法，基本实现原理与CopyOnWriteArrayList相同</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfAbsent</span><span class="params">(E e, Object[] snapshot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] current = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = current.length;</span><br><span class="line">        <span class="keyword">if</span> (snapshot != current) &#123;<span class="comment">//添加了元素去重操作</span></span><br><span class="line">            <span class="comment">// Optimize for lost race to another addXXX operation</span></span><br><span class="line">            <span class="keyword">int</span> common = Math.min(snapshot.length, len);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; common; i++)</span><br><span class="line">                <span class="keyword">if</span> (current[i] != snapshot[i] &amp;&amp; eq(e, current[i]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (indexOf(e, current, common, len) &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(current, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>####TreeSet –&gt; ConcurrentSkipListSet</p>
<p>它是JDK6新增的类，同TreeSet一样支持自然排序，并且可以在构造的时候自己定义比较器。</p>
<p>同其他set集合，是基于map集合的（基于ConcurrentSkipListMap），在多线程环境下，里面的contains、add、remove操作都是线程安全的。<br>多个线程可以安全的并发的执行插入、移除、和访问操作。但是对于批量操作addAll、removeAll、retainAll和containsAll并不能保证以原子方式执行，原因是addAll、removeAll、retainAll底层调用的还是contains、add、remove方法，只能保证每一次的执行是原子性的，代表在单一执行操纵时不会被打断，但是不能保证每一次批量操作都不会被打断。在使用批量操作时，还是需要手动加上同步操作的。<br>不允许使用null元素的，它无法可靠的将参数及返回值与不存在的元素区分开来。<br>源码分析：<br>//构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m = <span class="keyword">new</span> ConcurrentSkipListMap&lt;E,Object&gt;();<span class="comment">//使用ConcurrentSkipListMap实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap-–-gt-ConcurrentHashMap"><a href="#HashMap-–-gt-ConcurrentHashMap" class="headerlink" title="HashMap –&gt; ConcurrentHashMap"></a>HashMap –&gt; ConcurrentHashMap</h4><p>不允许空值，在实际的应用中除了少数的插入操作和删除操作外，绝大多数我们使用map都是读取操作。而且读操作大多数都是成功的。基于这个前提，它针对读操作做了大量的优化。因此这个类在高并发环境下有特别好的表现。<br>ConcurrentHashMap作为Concurrent一族，其有着高效地并发操作，相比Hashtable的笨重，ConcurrentHashMap则更胜一筹了。<br>在1.8版本以前，ConcurrentHashMap采用分段锁的概念，使锁更加细化，但是1.8已经改变了这种思路，而是利用CAS+Synchronized来保证并发更新的安全，当然底层采用数组+链表+红黑树的存储结构。<br>源码分析：推荐参考chenssy的博文：J.U.C之Java并发容器：ConcurrentHashMap<br>TreeMap –&gt; ConcurrentSkipListMap</p>
<p>底层实现采用SkipList跳表<br>曾经有人用ConcurrentHashMap与ConcurrentSkipListMap做性能测试，在4个线程1.6W的数据条件下，前者的数据存取速度是后者的4倍左右。但是后者有几个前者不能比拟的优点：<br>1、Key是有序的<br>2、支持更高的并发，存储时间与线程数无关<br>安全共享对象策略</p>
<p>线程限制：一个被线程限制的对象，由线程独占，并且只能被占有它的线程修改<br>共享只读：一个共享只读的U帝乡，在没有额外同步的情况下，可以被多个线程并发访问，但是任何线程都不能修改它<br>线程安全对象：一个线程安全的对象或者容器，在内部通过同步机制来保障线程安全，多以其他线程无需额外的同步就可以通过公共接口随意访问他被守护对象：被守护对象只能通过获取特定的锁来访问。</p>
<hr>
<hr>
<hr>
<h3 id="copyOnWriteArrayList"><a href="#copyOnWriteArrayList" class="headerlink" title="copyOnWriteArrayList"></a>copyOnWriteArrayList</h3><blockquote>
<p>线程写操作时复制，当有新元素添加到copyOnWriteArrayList时，它先从原有的数组中拷贝出一份，在新开辟出的新数组中写入，写完后再将原数组指向新数组。其操作都是在锁的域中，防止在多线程中复制出多个副本出来，导致原数组指向错误。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ol>
<li>由于写操作需进行复制操作，耗用内存；当元素内容过多时，该复制操作会占用非常多的内存，导致minor-GC，甚至full-GC。</li>
<li>虽然最终会保持一致性，但不能用于实时读的操作。</li>
<li>读写分离，且适合读多写少的场景。</li>
<li>若add或set的数据不清楚或过多，要慎用！</li>
<li>读时不加锁，写时加锁。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static List&lt;Integer&gt; list = new CopyOnWriteArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22:03:09.363 [main] INFO com.mmall.concurrency.concurrent.CopyOnWriteArrayListExample - size:5000</span><br></pre></td></tr></table></figure>

<p>结果验证了该类为线程安全的！</p>
<p>看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>显然是使用重入锁进行操作加锁。add方法的实现与上面的说明对应！</strong></p>
<h3 id="copyOnWriteArraySet"><a href="#copyOnWriteArraySet" class="headerlink" title="copyOnWriteArraySet"></a>copyOnWriteArraySet</h3><blockquote>
<p>对应于HashSet。</p>
</blockquote>
<p><strong>它的底层实现与copyOnWriteArrayList是一样的。特点也是一样的。当使用迭代器iterator迭代时，速度快效率高线程安全。</strong></p>
<h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><blockquote>
<p>对应于TreeSet。是JDK 1.6中新增的类，同样支持自然排序。在构造时可以自定义比较器。基于map集合，故而多线程并发环境下，它的类内插入、移除、访问方法都是线程安全的。但是对于批量操作，比如addAll()、removeAll()、retainAll()、containsAll并不能保证其操作的原子性。</p>
</blockquote>
<p>例子就不用演示了，跟上面的例子方法几乎完全一样，运行结果也显示是线程安全的！批量操作时就不能保证线程安全了！需额外增加锁机制。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><blockquote>
<p>对应于HashMap。其中需注意，key或Value不需为null。高并发环境中，表现较好。（后续会详细讲）</p>
</blockquote>
<h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><blockquote>
<p>对应于TreeMap。内部是使用SkipList即跳表的结构实现。</p>
</blockquote>
<p><strong>SkipList：</strong> 跳跃链表是一种随机化数据结构，基于并联的链表，其效率可比拟于二叉查找树(对于大多数操作需要O(log n)平均时间)，并且对并发算法友好。基本上，跳跃列表是对有序的链表增加上附加的前进链接，增加是以随机化的方式进行的，所以在列表中的查找可以快速的跳过部分列表(因此得名)。  <a href="https://blog.csdn.net/qpzkobe/article/details/80057046" target="_blank" rel="noopener">推荐阅读</a></p>
<p><strong>跳表性质：</strong></p>
<ol>
<li>由很多层结构组成；</li>
<li>每一层都是一个有序的链表；</li>
<li>最底层(Level 1)的链表包含所有元素；</li>
<li>如果一个元素出现在 Level i 的链表中，则它在 Level i 之下的链表也都会出现；</li>
<li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。<br><a href="https://www.cnblogs.com/a8457013/p/8251967.html" target="_blank" rel="noopener">推荐阅读</a></li>
</ol>
<p><strong>虽然ConcurrentSkipListMap的效率不及ConcurrentHashMap，但它也有ConcurrentHashMap不可比拟的优点：</strong></p>
<ol>
<li>ConcurrentSkipListMap中的key值是有序的。</li>
<li>支持更高的线程并发。其存取时间与线程数量是几乎没有关系的。即线程越多，越有利于ConcurrentSkipListMap的性能发挥。</li>
</ol>
<blockquote>
<p>上面介绍的几个例子就不进行例子演示了，均只是改变了变量的声明，其他内容仍然与原测试结构相同。</p>
</blockquote>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-08-03T07:49:58.323Z" itemprop="dateUpdated">2019-08-03 15:49:58</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2018/11/11/并发编程/慕课网java高并发/第五章 线程安全策略/" target="_blank" rel="external">http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第五章 线程安全策略/</a>
        
    </div>
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="John Doe">
            John Doe
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第五章 线程安全策略/&title=《第五章 线程安全策略》 — Hexo&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第五章 线程安全策略/&title=《第五章 线程安全策略》 — Hexo&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2018/11/11/Spring Boot/SpringBoot高级雷丰阳/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">SpringBoot  雷丰阳整合篇</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2018/11/10/SpringCloud/小D课堂springcloud/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">小D课堂SpringCloud笔记</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#不可变对象"><span class="post-toc-number">1.</span> <span class="post-toc-text">不可变对象</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.0.0.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#需满足的条件"><span class="post-toc-number">1.0.0.2.</span> <span class="post-toc-text">需满足的条件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#final关键字"><span class="post-toc-number">1.0.0.3.</span> <span class="post-toc-text">final关键字</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Collections-unmodifiableXXX方法"><span class="post-toc-number">1.0.0.4.</span> <span class="post-toc-text">Collections.unmodifiableXXX方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Guava的ImmutableXXX类"><span class="post-toc-number">1.0.0.5.</span> <span class="post-toc-text">Guava的ImmutableXXX类</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-线程封闭"><span class="post-toc-number">2.</span> <span class="post-toc-text">2 线程封闭</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述-1"><span class="post-toc-number">2.0.0.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#实现线程封闭的方法"><span class="post-toc-number">2.0.0.2.</span> <span class="post-toc-text">实现线程封闭的方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ThreadLocal测试例子"><span class="post-toc-number">2.0.0.3.</span> <span class="post-toc-text">ThreadLocal测试例子</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#（3）ThreadLocal线程封闭："><span class="post-toc-number">2.1.</span> <span class="post-toc-text">（3）ThreadLocal线程封闭： </span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3、Springboot框架中使用ThreadLocal"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">3、Springboot框架中使用ThreadLocal</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-线程不安全类与写法"><span class="post-toc-number">3.</span> <span class="post-toc-text">3 线程不安全类与写法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-2"><span class="post-toc-number">3.0.1.</span> <span class="post-toc-text">概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#StringBiulder"><span class="post-toc-number">3.0.1.1.</span> <span class="post-toc-text">StringBiulder</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#StringBuffer"><span class="post-toc-number">3.0.1.2.</span> <span class="post-toc-text">StringBuffer</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#SimpleDateFormate"><span class="post-toc-number">3.0.1.3.</span> <span class="post-toc-text">SimpleDateFormate</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Joda-Time"><span class="post-toc-number">3.0.1.4.</span> <span class="post-toc-text">Joda Time</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Collections部分"><span class="post-toc-number">3.0.2.</span> <span class="post-toc-text">Collections部分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ArrayList"><span class="post-toc-number">3.0.2.1.</span> <span class="post-toc-text">ArrayList</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashSet"><span class="post-toc-number">3.0.2.2.</span> <span class="post-toc-text">HashSet</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap"><span class="post-toc-number">3.0.2.3.</span> <span class="post-toc-text">HashMap</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#线程不安全的写法"><span class="post-toc-number">3.0.3.</span> <span class="post-toc-text">线程不安全的写法</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-2-线程不安全的类"><span class="post-toc-number">4.</span> <span class="post-toc-text">3.2 线程不安全的类</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-1同步容器"><span class="post-toc-number">5.</span> <span class="post-toc-text">4-1同步容器</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-2-同步容器"><span class="post-toc-number">6.</span> <span class="post-toc-text">4-2 同步容器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述-3"><span class="post-toc-number">6.0.1.</span> <span class="post-toc-text">概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Stack"><span class="post-toc-number">6.0.1.1.</span> <span class="post-toc-text">Stack</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashTable"><span class="post-toc-number">6.0.1.2.</span> <span class="post-toc-text">HashTable</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Collections工具类方法"><span class="post-toc-number">6.0.1.3.</span> <span class="post-toc-text">Collections工具类方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HashMap-–-gt-ConcurrentHashMap"><span class="post-toc-number">6.0.1.4.</span> <span class="post-toc-text">HashMap –&gt; ConcurrentHashMap</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#copyOnWriteArrayList"><span class="post-toc-number">6.0.2.</span> <span class="post-toc-text">copyOnWriteArrayList</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#copyOnWriteArraySet"><span class="post-toc-number">6.0.3.</span> <span class="post-toc-text">copyOnWriteArraySet</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ConcurrentSkipListSet"><span class="post-toc-number">6.0.4.</span> <span class="post-toc-text">ConcurrentSkipListSet</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ConcurrentHashMap"><span class="post-toc-number">6.0.5.</span> <span class="post-toc-text">ConcurrentHashMap</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ConcurrentSkipListMap"><span class="post-toc-number">6.0.6.</span> <span class="post-toc-text">ConcurrentSkipListMap</span></a></li></ol></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.lujingtao.com" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                John Doe &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第五章 线程安全策略/&title=《第五章 线程安全策略》 — Hexo&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第五章 线程安全策略/&title=《第五章 线程安全策略》 — Hexo&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADLklEQVR42u3a207rQAwFUP7/p3ueEafptj2gxl15QjTJzJpKGF++vuLr8eT6ec+zZ5/95ufbkvuTdQ9c2NjY2DdhPy6vOSk5uPwor/eWWLCxsbG3sq9Jybaay1/Gl97hJl8PNjY2NnZyKFVGcj27HxsbGxs732iPd7Zs9KcBDBsbG/sm7GrRp7f165Qmf+pPa2nY2NjYb8+elHje7edf6W9jY2NjvzH70bp6i10HkjykzRXY2NjYm9jVIHHqOKqjOUlSVE6fsLGxsVewq23UpKmQh5m8nHQ468LGxsZexK6GmXn56dRQTq9dEYmwsbGxb8jOF8gXm9xTbQNXQyY2Njb2JnZvRCbfyuTTamuhUOTCxsbGXsfOk4ffSF2qg0FJk+DFfrCxsbHXsauP9RKAJFjmLed8rRdxGxsbG3sRO2dcB7YqID/6JJRG6Q02Njb2InavuJOP2vSOtVr2ylu8UZMAGxsb+1bs3hDkvKE7H81JGgbNDAwbGxv7Vux8NKfwusEoz6TYVC6EYWNjY69gV1OFaugqt2DjPeQ7fJGKYGNjY9+cXW2dnh2OrAazvGwU7RwbGxt7BbsaePLRnGo4ydOeeTjExsbG3sSutmaTwlO+9UIvetDAwMbGxv4EdrVRmqcuUXdiUGbqBV1sbGzsrezqA3kgmSPzElX1a8DGxsbewZ4P31Rbwr2geLalgY2Njb2D3Su1543VyZ05KS8qfZtUwsbGxl7BTv6eJ5/mjF4zuLfDF4EQGxsbexG715qtpgrVdCUvZuWNiigbw8bGxr4Vuxo2zg7ZJEWr6rPRPdjY2NiL2JPgVC0D5ZX53rPl5jE2Njb2CnZ1+Qmymn7krYtyiMXGxsZexO5FvEkhvrdWryEdDe5gY2Nj35z9KF6TsNQb0zkVJrGxsbG3sieBZF4eqpb4q2/DxsbG/hz22aCSpCK91KVXhGpGb2xsbOwbsif90F4LNglIL+phrYIUNjY29iez82GaXvM4CaXJDstdDmxsbOyPYfcCTJ5y9FbMjwYbGxt7N7taVOoFql5JaH6I/9knNjY29iJ29f/2Kj5/w9lBnFFnGxsbG/se7H9wHr+D/XZaYAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.3"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.3"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.3"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.3"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.3"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
