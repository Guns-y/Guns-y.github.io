<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>第六章 JUC 之AQS | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="并发">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.3">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">John Doe</h5>
          <a href="mailto:1047629166@qq.com" title="1047629166@qq.com" class="mail">
            
              <span>1</span>
            
              <span>0</span>
            
              <span>4</span>
            
              <span>7</span>
            
              <span>6</span>
            
              <span>2</span>
            
              <span>9</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/codefine" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/custom"  >
                <i class="icon icon-lg icon-plus-square"></i>
                CUSTOM
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>第六章 JUC 之AQS</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">第六章 JUC 之AQS</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-11-11T02:13:42.000Z" itemprop="datePublished" class="page-time">
  2018-11-11
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/并发/">并发</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-并发编程/慕课网java高并发/第六章 JUC之AQS"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">第六章 JUC 之AQS</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-11-11 10:13:42" datetime="2018-11-11T02:13:42.000Z"  itemprop="datePublished">2018-11-11</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/并发/">并发</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102106.png" title="image-20190804182044480" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102106.png" alt="image-20190804182044480" title class></a>
                <p>image-20190804182044480</p>
            </figure>

<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="../../../../../Users/apple/Library/Application" title="Support/typora-user-images/image-20190804182104427.png" data-fancybox="images"><img src="../../../../../Users/apple/Library/Application" alt="image-20190804182104427" title="Support/typora-user-images/image-20190804182104427.png" class></a>
                <p>Support/typora-user-images/image-20190804182104427.png</p>
            </figure>

<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102046.png" title="image-20190804182117076" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102046.png" alt="image-20190804182117076" title class></a>
                <p>image-20190804182117076</p>
            </figure>

<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102118.png" title="image-20190804182125972" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102118.png" alt="image-20190804182125972" title class></a>
                <p>image-20190804182125972</p>
            </figure>

<hr>
<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102157.png" title="image-20190804182149683" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102157.png" alt="image-20190804182149683" title class></a>
                <p>image-20190804182149683</p>
            </figure>

<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102136.png" title="image-20190804182155883" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102136.png" alt="image-20190804182155883" title class></a>
                <p>image-20190804182155883</p>
            </figure>

<hr>
<h1 id="1-并发容器J-U-C-–-AQS组件CountDownLatch、Semaphore、CyclicBarrier"><a href="#1-并发容器J-U-C-–-AQS组件CountDownLatch、Semaphore、CyclicBarrier" class="headerlink" title="1 并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier"></a>1 并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier</h1><h3 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h3><p>AQS全名：AbstractQueuedSynchronizer，是并发容器J.U.C（java.lang.concurrent）下locks包内的一个类。它实现了一个<strong>FIFO</strong>(FirstIn、FisrtOut先进先出)的队列。底层实现的数据结构是一个<strong>双向列表</strong>。</p>
<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102424.png" title="image-20190804182423241" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102424.png" alt="image-20190804182423241" title class></a>
                <p>image-20190804182423241</p>
            </figure>

<p><strong>Sync queue</strong>：同步队列，是一个双向列表。包括head节点和tail节点。head节点主要用作后续的调度。<br><strong>Condition queue</strong>：非必须，单向列表。当程序中存在cindition的时候才会存在此列表。</p>
<h3 id="AQS设计思想"><a href="#AQS设计思想" class="headerlink" title="AQS设计思想"></a>AQS设计思想</h3><ul>
<li>使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。</li>
<li>利用int类型标识状态。在AQS类中有一个叫做state的成员变量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>基于AQS有一个同步组件，叫做ReentrantLock。在这个组件里，stste表示获取锁的线程数，假如state=0，表示还没有线程获取锁，1表示有线程获取了锁。大于1表示重入锁的数量。</p>
</li>
<li><p>继承：子类通过继承并通过实现它的方法管理其状态（acquire和release方法操纵状态）。</p>
</li>
<li><p>可以同时实现排它锁和共享锁模式（独占、共享），站在一个使用者的角度，AQS的功能主要分为两类：独占和共享。它的所有子类中，要么实现并使用了它的独占功能的api，要么使用了共享锁的功能，而不会同时使用两套api，即便是最有名的子类ReentrantReadWriteLock也是通过两个内部类读锁和写锁分别实现了两套api来实现的。</p>
</li>
</ul>
<h3 id="AQS的大致实现思路"><a href="#AQS的大致实现思路" class="headerlink" title="AQS的大致实现思路"></a>AQS的大致实现思路</h3><p>AQS内部维护了一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败就将当前线程及等待状态等信息包装成一个node节点加入到同步队列sync queue里。 </p>
<p>接着会不断的循环尝试获取锁，条件是当前节点为head的直接后继才会尝试。如果失败就会阻塞自己直到自己被唤醒。而当持有锁的线程释放锁的时候，会唤醒队列中的后继线程。</p>
<h3 id="AQS组件：CountDownLatch"><a href="#AQS组件：CountDownLatch" class="headerlink" title="AQS组件：CountDownLatch"></a>AQS组件：CountDownLatch</h3><figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102621.png" title="image-20190804182620528" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102621.png" alt="image-20190804182620528" title class></a>
                <p>image-20190804182620528</p>
            </figure>

<p>通过一个计数来保证线程是否需要被阻塞。实现一个或多个线程等待其他线程执行的场景。</p>
<p>我们定义一个CountDownLatch，通过给定的计数器为其初始化，该计数器是原子性操作，保证同时只有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态。只有其他线程调用countDown方法（每次使计数器-1），使计数器归零才能继续执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">    exec.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(threadNum);  <span class="comment">//需要被等待的线程执行的方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">countDownLatch.await();</span><br></pre></td></tr></table></figure>



<p>CountDownLatch的await方法还有重载形式，可以设置等待的时间，如果超过此时间，计数器还未清零，则不继续等待：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">countDownLatch.await(10, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">//参数1：等待的时间长度</span><br><span class="line">//参数2：等待的时间单位</span><br></pre></td></tr></table></figure>

<h3 id="AQS组件：Semaphore"><a href="#AQS组件：Semaphore" class="headerlink" title="AQS组件：Semaphore"></a>AQS组件：Semaphore</h3><ul>
<li><p>用于保证同一时间并发访问线程的数目。</p>
</li>
<li><p>信号量在操作系统中是很重要的概念，Java并发库里的Semaphore就可以很轻松的完成类似操作系统信号量的控制。Semaphore可以很容易控制系统中某个资源被同时访问的线程个数。</p>
</li>
<li><p>在数据结构中我们学过链表，链表正常是可以保存无限个节点的，而Semaphore可以实现有限大小的列表。<br>使用场景：仅能提供有限访问的资源。比如数据库连接。</p>
</li>
<li><p>Semaphore使用acquire方法和release方法来实现控制：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、普通调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">     test();<span class="comment">//需要并发控制的内容</span></span><br><span class="line">     semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、同时获取多个许可，同时释放多个许可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">     test();</span><br><span class="line">     semaphore.release(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 3、尝试获取许可，获取不到不执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (semaphore.tryAcquire()) &#123;</span><br><span class="line">        test(threadNum);</span><br><span class="line">        semaphore.release();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 4、尝试获取许可一段时间，获取不到不执行</span></span><br><span class="line"><span class="comment"> * 参数1：等待时间长度  参数2：等待时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (semaphore.tryAcquire(<span class="number">5000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">        test(threadNum);</span><br><span class="line">        semaphore.release(); </span><br><span class="line">     &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AQS组件：CyclicBarrier"><a href="#AQS组件：CyclicBarrier" class="headerlink" title="AQS组件：CyclicBarrier"></a>AQS组件：CyclicBarrier</h3><figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102759.png" title="image-20190804182758307" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-102759.png" alt="image-20190804182758307" title class></a>
                <p>image-20190804182758307</p>
            </figure>

<ul>
<li>也是一个同步辅助类，它允许一组线程相互等待，直到到达某个公共的屏障点（循环屏障）</li>
<li>通过它可以完成多个线程之间相互等待，只有每个线程都准备就绪后才能继续往下执行后面的操作。<br>每当有一个线程执行了await方法，计数器就会执行+1操作，待计数器达到预定的值，所有的线程再同时继续执行。由于计数器释放之后可以重用（reset方法），所以称之为循环屏障。</li>
<li>与CountDownLatch区别：<br>1、计数器可重复用 </li>
</ul>
<p>​       2、描述一个或多个线程等待其他线程的关系/多个线程相互等待</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共线程循环调用方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                race(threadNum);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法1：每个线程都持续等待</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">    barrier.await();</span><br><span class="line">    log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法2：每个线程只等待一段时间</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        barrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException | TimeoutException e) &#123;</span><br><span class="line">        log.warn(<span class="string">"BarrierException"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用方法3：在初始化的时候设置runnable，当线程达到屏障时优先执行runnable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">    log.info(<span class="string">"callback is running"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h1 id="2-并发容器J-U-C-–-AQS组件-锁：ReentrantLock、ReentrantReadWriteLock、StempedLock"><a href="#2-并发容器J-U-C-–-AQS组件-锁：ReentrantLock、ReentrantReadWriteLock、StempedLock" class="headerlink" title="2 并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock"></a>2 并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock</h1><p>ReentrantLock</p>
<p>java中有两类锁，一类是Synchronized，而另一类就是J.U.C中提供的锁。ReentrantLock与Synchronized都是可重入锁，本质上都是lock与unlock的操作。接下来我们介绍三种J.U.C中的锁，其中 ReentrantLock使用synchronized与之比对介绍。</p>
<p>ReentrantLock与synchronized的区别</p>
<p>可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁<br>锁的实现：synchronized是基于JVM实现的（用户很难见到，无法了解其实现），ReentrantLock是JDK实现的。<br>性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自选锁）后，二者的性能差别不大，官方推荐synchronized（写法更容易、在优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞）<br>功能区别：<br>（1）便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。<br>（2）锁的细粒度和灵活度，ReentrantLock优于synchronized<br>ReentrantLock独有的功能</p>
<p>可以指定是公平锁还是非公平锁，sync只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁）<br>提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。<br>提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现，这种机制 ReentrantLock是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。<br>要放弃synchronized？</p>
<p>从上边的介绍，看上去ReentrantLock不仅拥有synchronized的所有功能，而且有一些功能synchronized无法实现的特性。性能方面，ReentrantLock也不比synchronized差，那么到底我们要不要放弃使用synchronized呢？答案是不要这样做。</p>
<p>J.U.C包中的锁定类是用于高级情况和高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需要，或这有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized。相比较这些高级的锁定类，synchronized还是有一些优势的，比如synchronized不可能忘记释放锁。还有当JVM使用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。</p>
<h2 id="如何使用ReentrantLock？"><a href="#如何使用ReentrantLock？" class="headerlink" title="如何使用ReentrantLock？"></a>如何使用ReentrantLock？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁：使用Lock对象声明，使用ReentrantLock接口创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//使用锁：在需要被加锁的方法中使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方面：</span></span><br><span class="line"><span class="comment">//在new ReentrantLock的时候默认给了一个不公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以加参数来初始化指定使用公平锁还是不公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内置函数（部分）</p>
<p>基础特性：</p>
<p>tryLock()：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。<br>tryLock(long timeout, TimeUnit unit)：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。<br>lockInterruptbily：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。<br>isLocked：查询此锁定是否由任意线程保持<br>isHeldByCurrentThread：查询当前线程是否保持锁定状态。<br>isFair：判断是不是公平锁<br>…<br>Condition相关特性：</p>
<p>hasQueuedThread(Thread)：查询指定线程是否在等待获取此锁定<br>hasQueuedThreads()：查询是否有线程在等待获取此锁定<br>getHoldCount()：查询当前线程保持锁定的个数，也就是调用Lock方法的个数<br>…</p>
<h2 id="Condition的使用"><a href="#Condition的使用" class="headerlink" title="Condition的使用"></a>Condition的使用</h2><p>Condition可以非常灵活的操作线程的唤醒，下面是一个线程等待与唤醒的例子，其中用1234序号标出了日志输出顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = reentrantLock.newCondition();<span class="comment">//创建condition</span></span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            log.info(<span class="string">"wait signal"</span>); <span class="comment">// 1</span></span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"get signal"</span>); <span class="comment">// 4</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        log.info(<span class="string">"get lock"</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        condition.signalAll();<span class="comment">//发送信号</span></span><br><span class="line">        log.info(<span class="string">"send signal"</span>); <span class="comment">// 3</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （这里对等待队列不熟悉的，请回顾我的上一篇文章中讲解的AQS等待队列：高并发探索（十一）：并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier）<br>输出过程讲解：</p>
<p>1、线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出1号log<br>2、接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中<br>3、线程2因为线程1释放了锁，拿到了锁，输出2号log<br>4、线程2执行condition.signalAll()发送信号，输出3号log<br>5、condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列,这时线程1并没有被唤醒。<br>6、线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程1<br>7、线程1继续执行，输出4号log，并进行unlock操作。</p>
<p>读写锁：ReentrantReadWriteLock读写锁</p>
<p>在没有任何读写锁的时候才可以取得写入锁(悲观读取，容易写线程饥饿)，也就是说如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会造成等待获取写锁的线程饥饿。<br>平时使用的场景并不多。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();<span class="comment">//读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();<span class="comment">//写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="票据锁：StempedLock"><a href="#票据锁：StempedLock" class="headerlink" title="票据锁：StempedLock"></a>票据锁：StempedLock</h3><p>它控制锁有三种模式（写、读、乐观读）。一个StempedLock的状态是由版本和模式两个部分组成。锁获取方法返回一个数字作为票据（stamp），他用相应的锁状态表示并控制相关的访问。数字0表示没有写锁被锁写访问，在读锁上分为悲观锁和乐观锁。</p>
<blockquote>
<p> 乐观读：<br>如果读的操作很多写的很少，我们可以乐观的认为读的操作与写的操作同时发生的情况很少，因此不悲观的使用完全的读取锁定。程序可以查看读取资料之后是否遭到写入资料的变更，再采取之后的措施</p>
</blockquote>
<p>如何使用？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"><span class="comment">//需要上锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面看看乐观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">            <span class="keyword">double</span> currentX = x, currentY = y;  <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">            <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></span><br><span class="line">                stamp = sl.readLock();  <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                    currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">            <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                    <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></span><br><span class="line">                    <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                        stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                        x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                        y = newY;  <span class="comment">//进行状态改变</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                        sl.unlockRead(stamp);  <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                        stamp = sl.writeLock();  <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何选择锁？"><a href="#如何选择锁？" class="headerlink" title="如何选择锁？"></a>如何选择锁？</h3><p>1、当只有少量竞争者，使用synchronized<br>2、竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock<br>3、synchronized不会造成死锁，jvm会自动释放死锁。</p>
<hr>
<hr>
<hr>
<hr>
<h2 id="J-U-C之AQS—CountDownLatch"><a href="#J-U-C之AQS—CountDownLatch" class="headerlink" title="J.U.C之AQS—CountDownLatch"></a>J.U.C之AQS—CountDownLatch</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>它是一个同步辅助类，通过它可以在一个线程（线程间会轮换）执行countdown() -&gt; count值减至0的期间，保证其他线程会调用await()一直阻塞等待，最后等待的线程执行resume()，所有线程再一起执行另一个实务操作。其中有一个原子性的且不会被重置的计数器以保证上述的实现。</p>
<p>![image-20190804192550419](../../../../../Users/apple/Library/Application Support/typora-user-images/image-20190804192550419.png)</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当一个程序需在另一个条件完成后才可以继续执行后续操作。<br>如：并行计算中最后的汇总操作场</p>
<h3 id="例子演示"><a href="#例子演示" class="headerlink" title="例子演示"></a>例子演示</h3><h4 id="情景一：指定计数次数"><a href="#情景一：指定计数次数" class="headerlink" title="情景一：指定计数次数"></a>情景一：指定计数次数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//保证了方法被调用即计数执行减一</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="../../../../../Users/apple/Library/Application" title="Support/typora-user-images/image-20190804192632503.png" data-fancybox="images"><img src="../../../../../Users/apple/Library/Application" alt="image-20190804192632503" title="Support/typora-user-images/image-20190804192632503.png" class></a>
                <p>Support/typora-user-images/image-20190804192632503.png</p>
            </figure>

<p>根据结果，多线程并发期间，核心方法以乱序执行，但总数仍一定，且最后执行到测试语句“finish”。其中，countDownLatch.await()语句循环检查计数是否已经减为0，即保证了此时全部线程执行结束。</p>
<h4 id="情景二：指定计数时间"><a href="#情景二：指定计数时间" class="headerlink" title="情景二：指定计数时间"></a>情景二：指定计数时间</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await(<span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        log.info(<span class="string">"finish"</span>);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试结果：</strong></p>
<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-112634.png" title="image-20190804192710622" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-112634.png" alt="image-20190804192710622" title class></a>
                <p>image-20190804192710622</p>
            </figure>

<p>先来看一下await()的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public void await() throws InterruptedException &#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Causes the current thread to wait until the latch has counted down to</span><br><span class="line"> * zero, unless the thread is &#123;@linkplain Thread#interrupt interrupted&#125;,</span><br><span class="line"> * or the specified waiting time elapses.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If the current count is zero then this method returns immediately</span><br><span class="line"> * with the value &#123;@code true&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If the current count is greater than zero then the current</span><br><span class="line"> * thread becomes disabled for thread scheduling purposes and lies</span><br><span class="line"> * dormant until one of three things happen:</span><br><span class="line"> * &lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;The count reaches zero due to invocations of the</span><br><span class="line"> * &#123;@link #countDown&#125; method; or</span><br><span class="line"> * &lt;li&gt;Some other thread &#123;@linkplain Thread#interrupt interrupts&#125;</span><br><span class="line"> * the current thread; or</span><br><span class="line"> * &lt;li&gt;The specified waiting time elapses.</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span><br><span class="line">public boolean await(long timeout, TimeUnit unit)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>countDownLatch.await(3, TimeUnit.MILLISECONDS)</code>方法，指定<code>timeout</code>参数实现。其中，该参数指的是在<code>test</code>方法执行时开始计数，延时<code>timeout</code>的时间后<strong>或</strong>计数已经减为0后，继续执行后续方法，此例为<code>log.info(&quot;finish&quot;)</code>，即输出<code>finish</code>。<br>而无参的await()方法只有计数到0时才会继续执行后续方法。</p>
<p><strong>结果分析：</strong><br>例子中为了测试timeout，将timeout设置为1ms，而线程执行核心方法时设定休眠100ms，那么与结果是正好对应的，即finish总是第一个被输出的日志。</p>
<p><strong>但是，finish输出后就直接执行了exec.shutdown()即关闭线程池的操作了啊，怎么还会有线程日志输出？</strong></p>
<p>其实，exec.shutdown()操作：不会再接受新的线程任务，只会等待当前已经分配的线程执行完操作后再关闭，而不是在第一时间销毁所有的线程并强制关闭线程池。<strong>但是线程池还有一个立即关闭的线程池的方法 -&gt; 在第一时间销毁所有的线程并强制关闭线程池，即shutdownNow()。</strong></p>
<p>现在修改shutdown()为shutdownNow()，再进行测试，运行结果为：（部分截图）</p>
<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="../../../../../Users/apple/Library/Application" title="Support/typora-user-images/image-20190804192737368.png" data-fancybox="images"><img src="../../../../../Users/apple/Library/Application" alt="image-20190804192737368" title="Support/typora-user-images/image-20190804192737368.png" class></a>
                <p>Support/typora-user-images/image-20190804192737368.png</p>
            </figure>

<p><strong>结果分析：</strong><br>finish日志字段输出和其后200个<code>exception java.lang.InterruptedException: sleep interrupted</code>异常说明了测试的正确性。也是对应了上面await()源代码中的说明：<code>unless the thread is {@linkplain Thread#interrupt interrupted}</code>。</p>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>使用CountDownLatch中，最好是计数指定配合指定超时时间使用，避免计数因为意外的情况难以到达使得系统资源空耗或业务逻辑无法继续执行情况，以提高程序的高效性，实用性。</p>
<hr>
<h2 id="J-U-C之AQS—Semaphore"><a href="#J-U-C之AQS—Semaphore" class="headerlink" title="J.U.C之AQS—Semaphore"></a>J.U.C之AQS—Semaphore</h2><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>Semaphore字面意思就是信号量。它通过提供同步机制，控制资源可同时被并发访问的线程的个数。当信号量限定为1时，它就和单线程很相似了。Semaphore和CountDownLatch的使用有些相似，其中也有两个核心实现方法：acquire()和release()。</p>
<blockquote>
<p>通过semaphore可以实现有限结点个数的链表，虽然可重入锁reentrant也可以实现，但是semaphore的实现更为简单。</p>
</blockquote>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>常适用于仅能提供有限资源访问的场景。<br>如：数据库链接数远远小于上层应用业务并发的数量，如果不对数据库的访问进行控制，很容易出现因有些线程因无法获取到数据库链接而导致的异常。</p>
<h4 id="例子演示-1"><a href="#例子演示-1" class="headerlink" title="例子演示"></a>例子演示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);<span class="comment">//信号量声明</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//信号量获取</span></span><br><span class="line">                    test(threadNum);</span><br><span class="line">                    semaphore.release();<span class="comment">//信号量释放</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, threadNum);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-113005.png" title="image-20190804193003788" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-113005.png" alt="image-20190804193003788" title class></a>
                <p>image-20190804193003788</p>
            </figure>

<p><strong>例子说明：</strong><br>仔细的童鞋应该已经根据运行结果发现了：相同的信号量的输出是在同一时刻的！这也就对应了semaphore的含义。semaphore的使用也十分简单，方法执行前声明并制定允许的并发访问的数量，并用semaphore.acquire()和semaphore.release()分别前后包裹着test()方法即可。</p>
<p><strong>看一下semaphore的源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">  sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实semaphore.acquire()和semaphore.release()都是可以制定获取/释放信号量的数量的。而且都是使用的sync的方法获取或释放。那再看一下sync是什么鬼？</p>
<blockquote>
<p>读者：等等！！你不是说只是看一看源码吗？看看就得了，怎么还一直分析起来了？<br>我：大爷，来都来了，不进去逛逛？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** All mechanics via AbstractQueuedSynchronizer subclass */</span><br><span class="line">private final Sync sync;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Synchronization implementation for semaphore.  Uses AQS state</span><br><span class="line"> * to represent permits. Subclassed into fair and nonfair</span><br><span class="line"> * versions.</span><br><span class="line"> */</span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer &#123;</span><br><span class="line">  xx省略一万字xx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sync是其中的内部类，semaphore果然是使用了AQS框架！！使用了AQS的state字段来实现信号量的允许值（state字段之前提到过）。还分为公平和非公平两个版本！！</p>
<p><strong>那sync的方法是怎么实现的呢？</strong> 再看看源码：</p>
<blockquote>
<p>读者：公子！停停停！STOP!别看了，我有点恶心了~<br>我：emmm？我裤子都脱了，你让我停？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public final void acquireSharedInterruptibly(int arg)</span><br><span class="line">        throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">protected int tryAcquireShared(int arg) &#123;</span><br><span class="line">    throw new UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doAcquireSharedInterruptibly(int arg)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final Node node = addWaiter(Node.SHARED);</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head) &#123;</span><br><span class="line">                int r = tryAcquireShared(arg);</span><br><span class="line">                if (r &gt;= 0) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = null; // help GC</span><br><span class="line">                    failed = false;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean releaseShared(int arg) &#123;</span><br><span class="line">    if (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void doReleaseShared() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * Ensure that a release propagates, even if there are other</span><br><span class="line">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="line">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="line">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="line">     * ensure that upon release, propagation continues.</span><br><span class="line">     * Additionally, we must loop in case a new node is added</span><br><span class="line">     * while we are doing this. Also, unlike other uses of</span><br><span class="line">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="line">     * fails, if so rechecking.</span><br><span class="line">     */</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h != tail) &#123;</span><br><span class="line">            int ws = h.waitStatus;</span><br><span class="line">            if (ws == Node.SIGNAL) &#123;</span><br><span class="line">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</span><br><span class="line">                    continue;            // loop to recheck cases</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (ws == 0 &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</span><br><span class="line">                continue;                // loop on failed CAS</span><br><span class="line">        &#125;</span><br><span class="line">        if (h == head)                   // loop if head changed</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * CAS waitStatus field of a node.</span><br><span class="line"> */</span><br><span class="line">private static final boolean compareAndSetWaitStatus(Node node,</span><br><span class="line">                                                     int expect,</span><br><span class="line">                                                     int update) &#123;</span><br><span class="line">    return unsafe.compareAndSwapInt(node, waitStatusOffset,</span><br><span class="line">                                    expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>hasQueuedPredecessors()</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读者：公子！咱们走吧，咱不看了吧~<br>我：呕~ 呕呕呕<del>扶我起来，我还能…（话音未落，倒地身亡</del>）</p>
</blockquote>
<p>在<code>acquire()</code>中，调用<code>sync</code>的<code>acquireSharedInterruptibly()</code>其中指定参数（默认为1）：在共享模式中获取，首先检查线程状态，再至少调用一次<code>tryAcquireShared()</code>查询判断当前对象的<code>state</code>允许在共享模式中被获取，不允许则执行<code>doAcquireSharedInterruptibly(args)</code>，其中调用<code>addWaiter(Node.SHARED)</code>（参数指明为在共享模式下）进行声明：添加等待获取的结点，并循环遍历当前等待结点的前一结点，如果是<code>head</code>结点且此时再次查询当前对象的<code>state</code>允许在共享模式中被获取，那么设置队列的<code>head</code>并检查是否成功的对象正处于队列中，若是则传递消息以尝试给下一个队列结点传信号。如果不是<code>head</code>结点则调用<code>cancelAcquire(node)</code>，取消获取信号量。</p>
<p>在<code>release()</code>中，当参数存在时，调用<code>sync.releaseShared(permits)</code>，再调用<code>tryReleaseShared(args)</code>查询是否允许释放，若是则调用<code>doReleaseShared()</code>：即使有其他进行中的请求/释放信号量的进程，也要确保释放的消息传递，循环遍历以防止在这个过程中有新的结点加入；一般释放信号量的过程是当<code>head</code>需要信号量时，尝试释放head的继承结点。由于结合了CAS，需循环是否CAS重置状态失败了，若是则重新检查。</p>
<h4 id="如果并发数太多了，但是资源还有限，这时候怎么搞？"><a href="#如果并发数太多了，但是资源还有限，这时候怎么搞？" class="headerlink" title="如果并发数太多了，但是资源还有限，这时候怎么搞？"></a>如果并发数太多了，但是资源还有限，这时候怎么搞？</h4><p>semaphore还有一个叫做tryAcquire的方法。<br>看下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class SemaphoreExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private final static int threadCount = 2000;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        final Semaphore semaphore = new Semaphore(3);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; threadCount; i++) &#123;</span><br><span class="line">            final int threadNum = i;</span><br><span class="line">            exec.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (semaphore.tryAcquire()) &#123; // 尝试获取一个许可</span><br><span class="line">                        test(threadNum);</span><br><span class="line">                        semaphore.release(); // 释放一个许可</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test(int threadNum) throws Exception &#123;</span><br><span class="line">        log.info(&quot;&#123;&#125;&quot;, threadNum);</span><br><span class="line">        Thread.sleep(1000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-113129.png" title="image-20190804193127071" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-113129.png" alt="image-20190804193127071" title class></a>
                <p>image-20190804193127071</p>
            </figure>

<p>为什么只有三个线程执行了测试方法？是不是测试方法中的线程休眠时间太长了？现在改成500ms。</p>
<p>再次运行：</p>
<p>![image-20190804193157841](../../../../../Users/apple/Library/Application Support/typora-user-images/image-20190804193157841.png)</p>
<p><strong>例子就不演示了，通过指定时间，准确指定可以并发请求的数量，大大减轻了控制的操作。再配合在核心方法中修改线程休眠时间来控制线程并发访问数量，最少的数量是semaphore和并发请求中的最小值（但一般情况下还是semaphore小，即最小是semaphore声明值</strong></p>
<hr>
<h2 id="J-U-C之AQS—CyclicBarrier"><a href="#J-U-C之AQS—CyclicBarrier" class="headerlink" title="J.U.C之AQS—CyclicBarrier"></a>J.U.C之AQS—CyclicBarrier</h2><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>CyclicBarrier也是JDK提供的辅助类。它允许一组线程相互等待，直到到达一个公共的屏障点（CommonBarrierPoint）。通过它可以使多个线程间相互等待，只有当每个线程都准备就绪后才能各自继续执行后面的操作。</p>
<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120348.png" title="image-20190804200345419" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120348.png" alt="image-20190804200345419" title class></a>
                <p>image-20190804200345419</p>
            </figure>

<h4 id="与CountDownLatch的比较："><a href="#与CountDownLatch的比较：" class="headerlink" title="与CountDownLatch的比较："></a>与CountDownLatch的比较：</h4><ol>
<li>CountDownLatch是实现<strong>一个或多个线程需要等待其他线程完成某项操作</strong>之后才会才会继续执行。而CyclicBarrier是实现<strong>多个线程间相互等待，直到所有线程都满足条件</strong>后继续执行后续操作。</li>
<li>同时通过计数器实现，该类不过是加一操作；</li>
<li>当线程调用await()时，进入等待状态；</li>
<li>当达到指定值时都会执行一定的操作：CountDownLatch是计数到达0或超时时间过期会执行下一步操作；CyclicBarrier是加一操作计数达到设定初始值或超时时间过期时，等待的线程会继续执行后续的操作。</li>
<li>当CountDownLatch计数到0后，就不可再使用了；但CyclicBarrier计数到设定值后，可以复用，可以reset重新计数使用。（呼应名字：循环屏障）</li>
<li>使用场景相似：CyclicBarrier和CountDownLatch都可用于多线程计算数据，最后汇总计算。但CyclicBarrier可以处理对付更加复杂的场景，例如：若一次并发执行后出现错误，接着可reset计数器，重新执行一次。</li>
</ol>
<h4 id="演示例子-1"><a href="#演示例子-1" class="headerlink" title="演示例子-1"></a>演示例子-1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">        barrier.await();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h5><figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120440.png" title="image-20190804200432697" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120440.png" alt="image-20190804200432697" title class></a>
                <p>image-20190804200432697</p>
            </figure>

<h5 id="结果分析："><a href="#结果分析：" class="headerlink" title="结果分析："></a>结果分析：</h5><ol>
<li>当线程0和1都已经到达ready后，才会continue。</li>
<li>当上一层执行结束后，紧接着开始下一层的执行。</li>
</ol>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>看一下该类的内部成员：</p>
<figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120455.png" title="image-20190804200453607" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120455.png" alt="image-20190804200453607" title class></a>
                <p>image-20190804200453607</p>
            </figure>

<p>带有阻塞是操作指令参数的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;@code CyclicBarrier&#125; that will trip when the</span></span><br><span class="line"><span class="comment"> * given number of parties (threads) are waiting upon it, and which</span></span><br><span class="line"><span class="comment"> * will execute the given barrier action when the barrier is tripped,</span></span><br><span class="line"><span class="comment"> * performed by the last thread entering the barrier.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param parties the number of threads that must invoke &#123;@link #await&#125;</span></span><br><span class="line"><span class="comment"> *        before the barrier is tripped</span></span><br><span class="line"><span class="comment"> * @param barrierAction the command to execute when the barrier is</span></span><br><span class="line"><span class="comment"> *        tripped, or &#123;@code null&#125; if there is no action</span></span><br><span class="line"><span class="comment"> * @throws IllegalArgumentException if &#123;@code parties&#125; is less than 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">public CyclicBarrier(int parties, Runnable barrierAction) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带有超时时间参数的await()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置当前屏障无效，并唤醒每个线程。(持锁时有效)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重置当前屏障计数：先加锁，再设置当前屏障代无效并创建新一代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建新一代屏障：更新屏障闸的state字段并唤醒每个线程（持锁时有效）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await()中真正的实现方法==&gt;dowait():</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//使用重入锁。</span></span><br><span class="line">    lock.lock();<span class="comment">//锁内操作保安全</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count为parties即聚集个数（互相等待的个数）</span></span><br><span class="line">        <span class="comment">//当index减为0，即所有线程都执行了该dowait()方法，都已执行完毕。</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//如果有执行命令则运行，并返回方法。</span></span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)<span class="comment">//执行命令为null，则破除屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//操作结束释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Conditin：放闸前所处的等待状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final Condition trip = lock.newCondition();</span><br></pre></td></tr></table></figure>

<h4 id="演示例子-2"><a href="#演示例子-2" class="headerlink" title="演示例子-2"></a>演示例子-2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//只等待2000ms，之后的线程就会被抛弃了。</span></span><br><span class="line">            <span class="comment">// 因线程的condition改变为broken（因超时而强行打破屏障继续执行）而产生了BrokenBarrierException，</span></span><br><span class="line">            <span class="comment">// 或因线程被中断而产生线程中断异常而产生的需要try-catch</span></span><br><span class="line">            barrier.await(<span class="number">2000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"BarrierException"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果：（部分截取）"><a href="#运行结果：（部分截取）" class="headerlink" title="运行结果：（部分截取）"></a>运行结果：（部分截取）</h5><figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120643.png" title="image-20190804200641684" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120643.png" alt="image-20190804200641684" title class></a>
                <p>image-20190804200641684</p>
            </figure>

<h4 id="演示例子-3"><a href="#演示例子-3" class="headerlink" title="演示例子-3"></a>演示例子-3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参的构造函数，在dowait()方法执行时若存在则优先执行该Runnable指令再返</span></span><br><span class="line">    <span class="comment">// 回（该时执行不到打破屏障代码段），之后再打破屏障并继续执行后续操作。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"callback is running"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    race(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">(<span class="keyword">int</span> threadNum)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; is ready"</span>, threadNum);</span><br><span class="line">        barrier.await();</span><br><span class="line">        log.info(<span class="string">"&#123;&#125; continue"</span>, threadNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="运行结果：（截取部分）"><a href="#运行结果：（截取部分）" class="headerlink" title="运行结果：（截取部分）"></a>运行结果：（截取部分）</h5><figure class="image-box">
                <a rel=第六章 JUC 之AQS href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120629.png" title="image-20190804200626835" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-04-120629.png" alt="image-20190804200626835" title class></a>
                <p>image-20190804200626835</p>
            </figure>

<hr>
<hr>
<hr>
<h1 id="并发容器J-U-C-–-AQS组件-锁：ReentrantLock、ReentrantReadWriteLock、StempedLock"><a href="#并发容器J-U-C-–-AQS组件-锁：ReentrantLock、ReentrantReadWriteLock、StempedLock" class="headerlink" title="并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock"></a>并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock</h1><p>ReentrantLock</p>
<p>java中有两类锁，一类是Synchronized，而另一类就是J.U.C中提供的锁。ReentrantLock与Synchronized都是可重入锁，本质上都是lock与unlock的操作。接下来我们介绍三种J.U.C中的锁，其中 ReentrantLock使用synchronized与之比对介绍。</p>
<p>ReentrantLock与synchronized的区别</p>
<p>可重入性：两者的锁都是可重入的，差别不大，有线程进入锁，计数器自增1，等下降为0时才可以释放锁<br>锁的实现：synchronized是基于JVM实现的（用户很难见到，无法了解其实现），ReentrantLock是JDK实现的。<br>性能区别：在最初的时候，二者的性能差别差很多，当synchronized引入了偏向锁、轻量级锁（自选锁）后，二者的性能差别不大，官方推荐synchronized（写法更容易、在优化时其实是借用了ReentrantLock的CAS技术，试图在用户态就把问题解决，避免进入内核态造成线程阻塞）<br>功能区别：<br>（1）便利性：synchronized更便利，它是由编译器保证加锁与释放。ReentrantLock是需要手动释放锁，所以为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。<br>（2）锁的细粒度和灵活度，ReentrantLock优于synchronized<br>ReentrantLock独有的功能</p>
<p>可以指定是公平锁还是非公平锁，sync只能是非公平锁。（所谓公平锁就是先等待的线程先获得锁）<br>提供了一个Condition类，可以分组唤醒需要唤醒的线程。不像是synchronized要么随机唤醒一个线程，要么全部唤醒。<br>提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现，这种机制 ReentrantLock是一种自选锁，通过循环调用CAS操作来实现加锁。性能比较好的原因是避免了进入内核态的阻塞状态。<br>要放弃synchronized？</p>
<p>从上边的介绍，看上去ReentrantLock不仅拥有synchronized的所有功能，而且有一些功能synchronized无法实现的特性。性能方面，ReentrantLock也不比synchronized差，那么到底我们要不要放弃使用synchronized呢？答案是不要这样做。</p>
<p>J.U.C包中的锁定类是用于高级情况和高级用户的工具，除非说你对Lock的高级特性有特别清楚的了解以及有明确的需要，或这有明确的证据表明同步已经成为可伸缩性的瓶颈的时候，否则我们还是继续使用synchronized。相比较这些高级的锁定类，synchronized还是有一些优势的，比如synchronized不可能忘记释放锁。还有当JVM使用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这些信息对调试非常有价值，它们可以标识死锁以及其他异常行为的来源。</p>
<h2 id="如何使用ReentrantLock？-1"><a href="#如何使用ReentrantLock？-1" class="headerlink" title="如何使用ReentrantLock？"></a>如何使用ReentrantLock？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建锁：使用Lock对象声明，使用ReentrantLock接口创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//使用锁：在需要被加锁的方法中使用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分析一下源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方面：</span></span><br><span class="line"><span class="comment">//在new ReentrantLock的时候默认给了一个不公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以加参数来初始化指定使用公平锁还是不公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内置函数（部分）</p>
<p>基础特性：</p>
<p>tryLock()：仅在调用时锁定未被另一个线程保持的情况下才获取锁定。<br>tryLock(long timeout, TimeUnit unit)：如果锁定在给定的时间内没有被另一个线程保持且当前线程没有被中断，则获取这个锁定。<br>lockInterruptbily：如果当前线程没有被中断的话，那么就获取锁定。如果中断了就抛出异常。<br>isLocked：查询此锁定是否由任意线程保持<br>isHeldByCurrentThread：查询当前线程是否保持锁定状态。<br>isFair：判断是不是公平锁<br>…<br>Condition相关特性：</p>
<p>hasQueuedThread(Thread)：查询指定线程是否在等待获取此锁定<br>hasQueuedThreads()：查询是否有线程在等待获取此锁定<br>getHoldCount()：查询当前线程保持锁定的个数，也就是调用Lock方法的个数<br>…<br>Condition的使用</p>
<p>Condition可以非常灵活的操作线程的唤醒，下面是一个线程等待与唤醒的例子，其中用1234序号标出了日志输出顺序</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    Condition condition = reentrantLock.newCondition();<span class="comment">//创建condition</span></span><br><span class="line">    <span class="comment">//线程1</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            log.info(<span class="string">"wait signal"</span>); <span class="comment">// 1</span></span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"get signal"</span>); <span class="comment">// 4</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="comment">//线程2</span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        reentrantLock.lock();</span><br><span class="line">        log.info(<span class="string">"get lock"</span>); <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        condition.signalAll();<span class="comment">//发送信号</span></span><br><span class="line">        log.info(<span class="string">"send signal"</span>); <span class="comment">// 3</span></span><br><span class="line">        reentrantLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（这里对等待队列不熟悉的，请回顾我的上一篇文章中讲解的AQS等待队列：高并发探索（十一）：并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier）<br>输出过程讲解：</p>
<p>1、线程1调用了reentrantLock.lock()，线程进入AQS等待队列，输出1号log<br>2、接着调用了awiat方法，线程从AQS队列中移除，锁释放，直接加入condition的等待队列中<br>3、线程2因为线程1释放了锁，拿到了锁，输出2号log<br>4、线程2执行condition.signalAll()发送信号，输出3号log<br>5、condition队列中线程1的节点接收到信号，从condition队列中拿出来放入到了AQS的等待队列,这时线程1并没有被唤醒。<br>6、线程2调用unlock释放锁，因为AQS队列中只有线程1，因此AQS释放锁按照从头到尾的顺序，唤醒线程1<br>7、线程1继续执行，输出4号log，并进行unlock操作。</p>
<p>读写锁：ReentrantReadWriteLock读写锁</p>
<p>在没有任何读写锁的时候才可以取得写入锁(悲观读取，容易写线程饥饿)，也就是说如果一直存在读操作，那么写锁一直在等待没有读的情况出现，这样我的写锁就永远也获取不到，就会造成等待获取写锁的线程饥饿。 </p>
<p>平时使用的场景并不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = lock.readLock();<span class="comment">//读锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = lock.writeLock();<span class="comment">//写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>票据锁：StempedLock</p>
<p>它控制锁有三种模式（写、读、乐观读）。一个StempedLock的状态是由版本和模式两个部分组成。锁获取方法返回一个数字作为票据（stamp），他用相应的锁状态表示并控制相关的访问。数字0表示没有写锁被锁写访问，在读锁上分为悲观锁和乐观锁。</p>
<p>乐观读：<br>如果读的操作很多写的很少，我们可以乐观的认为读的操作与写的操作同时发生的情况很少，因此不悲观的使用完全的读取锁定。程序可以查看读取资料之后是否遭到写入资料的变更，再采取之后的措施。</p>
<p>如何使用？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"><span class="comment">//需要上锁的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamp = lock.writeLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面看看乐观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//获得一个乐观读锁</span></span><br><span class="line">            <span class="keyword">double</span> currentX = x, currentY = y;  <span class="comment">//将两个字段读入本地局部变量</span></span><br><span class="line">            <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">//检查发出乐观读锁后同时是否有其他写锁发生？</span></span><br><span class="line">                stamp = sl.readLock();  <span class="comment">//如果没有，我们再次获得一个读悲观锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    currentX = x; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                    currentY = y; <span class="comment">// 将两个字段读入本地局部变量</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面是悲观读锁案例</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; <span class="comment">// upgrade</span></span><br><span class="line">            <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line">            <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123; <span class="comment">//循环，检查当前状态是否符合</span></span><br><span class="line">                    <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp); <span class="comment">//将读锁转为写锁</span></span><br><span class="line">                    <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123; <span class="comment">//这是确认转为写锁是否成功</span></span><br><span class="line">                        stamp = ws; <span class="comment">//如果成功 替换票据</span></span><br><span class="line">                        x = newX; <span class="comment">//进行状态改变</span></span><br><span class="line">                        y = newY;  <span class="comment">//进行状态改变</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果不能成功转换为写锁</span></span><br><span class="line">                        sl.unlockRead(stamp);  <span class="comment">//我们显式释放读锁</span></span><br><span class="line">                        stamp = sl.writeLock();  <span class="comment">//显式直接进行写锁 然后再通过循环再试</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlock(stamp); <span class="comment">//释放读锁或写锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何选择锁？-1"><a href="#如何选择锁？-1" class="headerlink" title="如何选择锁？"></a>如何选择锁？</h3><p>1、当只有少量竞争者，使用synchronized<br>2、竞争者不少但是线程增长的趋势是能预估的，使用ReetrantLock<br>3、synchronized不会造成死锁，jvm会自动释放死锁。</p>
<hr>
<h2 id="J-U-C之AQS—RentrantLock-Part-1"><a href="#J-U-C之AQS—RentrantLock-Part-1" class="headerlink" title="J.U.C之AQS—RentrantLock-Part-1"></a>J.U.C之AQS—RentrantLock-Part-1</h2><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>RentrantLock即重入锁，是JDK中J.U.C提供的最重要的锁。<br>通过自旋锁实现RentrantLock：循环调用CAS操作实现枷锁，即<strong>阻止线程进入内核态被阻塞</strong>，故而效率较高。</p>
<ol>
<li>可重入性：两者都具有可重入性。</li>
<li>锁的实现：RentrantLock是JDK中源码实现；Synchronized的锁机制是由JVM的JMM机制管理实现。</li>
<li>性能区别：Synchronized关键字优化前，其性能很差；但优化后（借鉴了RentrantLock中的CAS机制：在用户态加锁解锁），引入了偏向锁、自旋锁后，两者性能几无差异。（更推荐synchronized）。</li>
<li>功能区别：(1).synchronized关键字使用更加简洁简单，由编译器保证实现；RentrantLock需声明锁，并加锁，在finally中解锁。(2).RentrantLock锁粒度更细，灵活度高。</li>
</ol>
<blockquote>
<p>公平锁即按照线程的请求的先后顺序给与锁；非公平锁即按照对锁的争夺成功的线程加锁。</p>
</blockquote>
<h4 id="特有功能："><a href="#特有功能：" class="headerlink" title="特有功能："></a>特有功能：</h4><ol>
<li>RentrantLock可以指定该lock是公平锁或非公平锁（而synchronized只能是非公平锁）；</li>
<li>通过方法提供Condition类，可以分组唤醒需要唤醒的线程。</li>
<li>提供能够中断等待锁的线程的机制 –&gt; lock.lockInterruptibly()</li>
</ol>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>当需要用到上面RentrantLock的特有功能时，必须使用RentrantLock。</p>
<h4 id="演示例子"><a href="#演示例子" class="headerlink" title="演示例子"></a>演示例子</h4><h5 id="RentrantLock"><a href="#RentrantLock" class="headerlink" title="RentrantLock"></a>RentrantLock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ThreadSafe</span><br><span class="line">public class LockExample2 &#123;</span><br><span class="line"></span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line"></span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static int count = 0;</span><br><span class="line"></span><br><span class="line">    private final static Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;count:&#123;&#125;&quot;, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void add() &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例子分析："><a href="#例子分析：" class="headerlink" title="例子分析："></a>例子分析：</h5><p>简简单单，只是在核心方法执行前加锁，在之后的finally中解锁。</p>
<h5 id="RentrantReadWriteLock"><a href="#RentrantReadWriteLock" class="headerlink" title="RentrantReadWriteLock"></a>RentrantReadWriteLock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class LockExample3 &#123;</span><br><span class="line"></span><br><span class="line">    private final Map&lt;String, Data&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    private final Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    private final Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line">    public Data get(String key) &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.get(key);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; getAllKeys() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.keySet();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Data put(String key, Data value) &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            return map.put(key, value);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h5><ol>
<li><p>其中使用了RentrantReadWriteLock，该锁是读写分离锁，即读操作和写操作分别持有一把锁。</p>
</li>
<li><p>而且由于该RentrantReadWriteLock的读锁是一种悲观锁，即只有当其他操作都执行完后才会进行写操作。那么，但实际应用中读操作是远远多于写操作的（一般情况下），那么可能会导致写操作产生线程饥饿。</p>
<blockquote>
<p><strong>悲观锁</strong>：对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度；因为悲观，认为自己的数据很容易在并发中产生错误，所以在整个数据处理过程中，将数据处于锁定状态.<br><strong>乐观锁</strong>：大多是基于数据版本记录机制实现；读取出数据时，将此版本号（version字段）一同读出，之后更新时，对此版本号加一；若提交的数据版本大于数据库表当前版本号，则予以更新，否则认为是过期数据。<br><strong>线程饥饿</strong>：通常是因为线程优先级过低，导致该线程等待被执行的时间过久，甚至执行操作已经无意义。</p>
</blockquote>
</li>
<li><p>因此，该类实际中用到的不多。</p>
</li>
</ol>
<h5 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class StampedLockExample &#123;</span><br><span class="line"></span><br><span class="line">    class Point &#123;</span><br><span class="line">        private double x, y;</span><br><span class="line">        private final StampedLock sl = new StampedLock();</span><br><span class="line"></span><br><span class="line">        void move(double deltaX, double deltaY) &#123; // an exclusively locked method</span><br><span class="line">            long stamp = sl.writeLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                x += deltaX;</span><br><span class="line">                y += deltaY;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sl.unlockWrite(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //下面是乐观读锁案例</span><br><span class="line">        double distanceFromOrigin() &#123; // A read-only method</span><br><span class="line">            long stamp = sl.tryOptimisticRead(); //获得一个乐观读锁</span><br><span class="line">            double currentX = x, currentY = y;  //将两个字段读入本地局部变量</span><br><span class="line">            if (!sl.validate(stamp)) &#123; //检查发出乐观读锁后同时是否有其他写锁发生？</span><br><span class="line">                stamp = sl.readLock();  //如果没有，我们再次获得一个读悲观锁</span><br><span class="line">                try &#123;</span><br><span class="line">                    currentX = x; // 将两个字段读入本地局部变量</span><br><span class="line">                    currentY = y; // 将两个字段读入本地局部变量</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //下面是悲观读锁案例</span><br><span class="line">        void moveIfAtOrigin(double newX, double newY) &#123; // upgrade</span><br><span class="line">            // Could instead start with optimistic, not read mode</span><br><span class="line">            long stamp = sl.readLock();</span><br><span class="line">            try &#123;</span><br><span class="line">                while (x == 0.0 &amp;&amp; y == 0.0) &#123; //循环，检查当前状态是否符合</span><br><span class="line">                    long ws = sl.tryConvertToWriteLock(stamp); //将读锁转为写锁</span><br><span class="line">                    if (ws != 0L) &#123; //这是确认转为写锁是否成功</span><br><span class="line">                        stamp = ws; //如果成功 替换票据</span><br><span class="line">                        x = newX; //进行状态改变</span><br><span class="line">                        y = newY;  //进行状态改变</span><br><span class="line">                        break;</span><br><span class="line">                    &#125; else &#123; //如果不能成功转换为写锁</span><br><span class="line">                        sl.unlockRead(stamp);  //我们显式释放读锁</span><br><span class="line">                        stamp = sl.writeLock();  //显式直接进行写锁 然后再通过循环再试</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sl.unlock(stamp); //释放读锁或写锁</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="例子分析"><a href="#例子分析" class="headerlink" title="例子分析"></a>例子分析</h5><p>这个例子是JDK源码中提供的参考例子。相对于RentrantReadWriteLock，StampedLock的有三种控制锁的模式：写锁，读锁，乐观读锁(!!)。由于提供了乐观锁的实现机制，那么即使是在读操作占比很高的情况中，系统仍然可以保持较好性能和高IO吞吐量。</p>
<h6 id="StampedLock源码分析"><a href="#StampedLock源码分析" class="headerlink" title="StampedLock源码分析"></a>StampedLock源码分析</h6><p>先看顶部注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * A capability-based lock with three modes for controlling read/write</span><br><span class="line"> * access.  The state of a StampedLock consists of a version and mode.</span><br><span class="line"> * Lock acquisition methods return a stamp that represents and</span><br><span class="line"> * controls access with respect to a lock state; &quot;try&quot; versions of</span><br><span class="line"> * these methods may instead return the special value zero to</span><br><span class="line"> * represent failure to acquire access. Lock release and conversion</span><br><span class="line"> * methods require stamps as arguments, and fail if they do not match</span><br><span class="line"> * the state of the lock. ……</span><br><span class="line"> *</span><br><span class="line"> *  &lt;li&gt;&lt;b&gt;Optimistic Reading.&lt;/b&gt; Method &#123;@link #tryOptimisticRead&#125;</span><br><span class="line"> *   returns a non-zero stamp only if the lock is not currently held</span><br><span class="line"> *   in write mode. Method &#123;@link #validate&#125; returns true if the lock</span><br><span class="line"> *   has not been acquired in write mode since obtaining a given</span><br><span class="line"> *   stamp.  This mode can be thought of as an extremely weak version</span><br><span class="line"> *   of a read-lock, that can be broken by a writer at any time.  The</span><br><span class="line"> *   use of optimistic mode for short read-only code segments often</span><br><span class="line"> *   reduces contention and improves throughput.  However, its use is</span><br><span class="line"> *   inherently fragile.  Optimistic read sections should only read</span><br><span class="line"> *   fields and hold them in local variables for later use after</span><br><span class="line"> *   validation. Fields read while in optimistic mode may be wildly</span><br><span class="line"> *   inconsistent, so usage applies only when you are familiar enough</span><br><span class="line"> *   with data representations to check consistency and/or repeatedly</span><br><span class="line"> *   invoke method &#123;@code validate()&#125;.  For example, such steps are</span><br><span class="line"> *   typically required when first reading an object or array</span><br><span class="line"> *   reference, and then accessing one of its fields, elements or</span><br><span class="line"> *   methods. &lt;/li&gt;</span><br><span class="line"> *</span><br><span class="line">     * Algorithmic notes:</span><br><span class="line">     *</span><br><span class="line">     * The design employs elements of Sequence locks</span><br><span class="line">     * (as used in linux kernels; see Lameter&apos;s</span><br><span class="line">     * http://www.lameter.com/gelato2005.pdf</span><br><span class="line">     * and elsewhere; see</span><br><span class="line">     * Boehm&apos;s http://www.hpl.hp.com/techreports/2012/HPL-2012-68.html)</span><br><span class="line">     * and Ordered RW locks (see Shirako et al</span><br><span class="line">     * http://dl.acm.org/citation.cfm?id=2312015)</span><br><span class="line">     *</span><br><span class="line">     * Conceptually, the primary state of the lock includes a sequence</span><br><span class="line">     * number that is odd when write-locked and even otherwise.</span><br><span class="line">     * However, this is offset by a reader count that is non-zero when</span><br><span class="line">     * read-locked.  The read count is ignored when validating</span><br><span class="line">     * &quot;optimistic&quot; seqlock-reader-style stamps.  Because we must use</span><br><span class="line">     * a small finite number of bits (currently 7) for readers, a</span><br><span class="line">     * supplementary reader overflow word is used when the number of</span><br><span class="line">     * readers exceeds the count field. We do this by treating the max</span><br><span class="line">     * reader count value (RBITS) as a spinlock protecting overflow</span><br><span class="line">     * updates.</span><br><span class="line">     *</span><br><span class="line">     * Waiters use a modified form of CLH lock used in</span><br><span class="line">     * AbstractQueuedSynchronizer (see its internal documentation for</span><br><span class="line">     * a fuller account), where each node is tagged (field mode) as</span><br><span class="line">     * either a reader or writer. Sets of waiting readers are grouped</span><br><span class="line">     * (linked) under a common node (field cowait) so act as a single</span><br><span class="line">     * node with respect to most CLH mechanics.  By virtue of the</span><br><span class="line">     * queue structure, wait nodes need not actually carry sequence</span><br><span class="line">     * numbers; we know each is greater than its predecessor.  This</span><br><span class="line">     * simplifies the scheduling policy to a mainly-FIFO scheme that</span><br><span class="line">     * incorporates elements of Phase-Fair locks (see Brandenburg &amp;</span><br><span class="line">     * Anderson, especially http://www.cs.unc.edu/~bbb/diss/).  In</span><br><span class="line">     * particular, we use the phase-fair anti-barging rule: If an</span><br><span class="line">     * incoming reader arrives while read lock is held but there is a</span><br><span class="line">     * queued writer, this incoming reader is queued.  (This rule is</span><br><span class="line">     * responsible for some of the complexity of method acquireRead,</span><br><span class="line">     * but without it, the lock becomes highly unfair.) Method release</span><br><span class="line">     * does not (and sometimes cannot) itself wake up cowaiters. This</span><br><span class="line">     * is done by the primary thread, but helped by any other threads</span><br><span class="line">     * with nothing better to do in methods acquireRead and</span><br><span class="line">     * acquireWrite.</span><br><span class="line">     *</span><br><span class="line">     * These rules apply to threads actually queued. All tryLock forms</span><br><span class="line">     * opportunistically try to acquire locks regardless of preference</span><br><span class="line">     * rules, and so may &quot;barge&quot; their way in.  Randomized spinning is</span><br><span class="line">     * used in the acquire methods to reduce (increasingly expensive)</span><br><span class="line">     * context switching while also avoiding sustained memory</span><br><span class="line">     * thrashing among many threads.  We limit spins to the head of</span><br><span class="line">     * queue. A thread spin-waits up to SPINS times (where each</span><br><span class="line">     * iteration decreases spin count with 50% probability) before</span><br><span class="line">     * blocking. If, upon wakening it fails to obtain lock, and is</span><br><span class="line">     * still (or becomes) the first waiting thread (which indicates</span><br><span class="line">     * that some other thread barged and obtained lock), it escalates</span><br><span class="line">     * spins (up to MAX_HEAD_SPINS) to reduce the likelihood of</span><br><span class="line">     * continually losing to barging threads.</span><br><span class="line">     *</span><br><span class="line">     * Nearly all of these mechanics are carried out in methods</span><br><span class="line">     * acquireWrite and acquireRead, that, as typical of such code,</span><br><span class="line">     * sprawl out because actions and retries rely on consistent sets</span><br><span class="line">     * of locally cached reads.</span><br><span class="line">     *</span><br><span class="line">     * As noted in Boehm&apos;s paper (above), sequence validation (mainly</span><br><span class="line">     * method validate()) requires stricter ordering rules than apply</span><br><span class="line">     * to normal volatile reads (of &quot;state&quot;).  To force orderings of</span><br><span class="line">     * reads before a validation and the validation itself in those</span><br><span class="line">     * cases where this is not already forced, we use</span><br><span class="line">     * Unsafe.loadFence.</span><br><span class="line">     *</span><br><span class="line">     * The memory layout keeps lock state and queue pointers together</span><br><span class="line">     * (normally on the same cache line). This usually works well for</span><br><span class="line">     * read-mostly loads. In most other cases, the natural tendency of</span><br><span class="line">     * adaptive-spin CLH locks to reduce memory contention lessens</span><br><span class="line">     * motivation to further spread out contended locations, but might</span><br><span class="line">     * be subject to future improvements.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>看来这个类还是有、东西的。不过内容太多了，也不知从何看起。目前先了解一下大致情况，以后继续慢慢了解~</p>
<blockquote>
<p>答应我，不要吐~ 还是翻回去从头好好看一下，其中有用到AQS的CLH队列哦~</p>
<h2 id="J-U-C之AQS—RentrantLock-Part-2"><a href="#J-U-C之AQS—RentrantLock-Part-2" class="headerlink" title="J.U.C之AQS—RentrantLock-Part-2"></a>J.U.C之AQS—RentrantLock-Part-2</h2></blockquote>
<h4 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">public ReentrantLock() &#123;</span><br><span class="line">    sync = new NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Sync object for non-fair locks</span><br><span class="line"> */</span><br><span class="line">static final class NonfairSync extends Sync &#123;</span><br><span class="line">    private static final long serialVersionUID = 7316153563782823691L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Performs lock.  Try immediate barge, backing up to normal</span><br><span class="line">     * acquire on failure.</span><br><span class="line">     */</span><br><span class="line">    final void lock() &#123;</span><br><span class="line">        if (compareAndSetState(0, 1))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        else</span><br><span class="line">            acquire(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        return nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Atomically sets synchronization state to the given updated</span><br><span class="line"> * value if the current state value equals the expected value.</span><br><span class="line"> * This operation has memory semantics of a &#123;@code volatile&#125; read</span><br><span class="line"> * and write.</span><br><span class="line"> *</span><br><span class="line"> * @param expect the expected value</span><br><span class="line"> * @param update the new value</span><br><span class="line"> * @return &#123;@code true&#125; if successful. False return indicates that the actual</span><br><span class="line"> *         value was not equal to the expected value.</span><br><span class="line"> */</span><br><span class="line">protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">    // See below for intrinsics setup to support this</span><br><span class="line">    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Sets the thread that currently owns exclusive access.</span><br><span class="line"> * A &#123;@code null&#125; argument indicates that no thread owns access.</span><br><span class="line"> * This method does not otherwise impose any synchronization or</span><br><span class="line"> * &#123;@code volatile&#125; field accesses.</span><br><span class="line"> * @param thread the owner thread</span><br><span class="line"> */</span><br><span class="line">protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">    exclusiveOwnerThread = thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span><br><span class="line"> * by invoking at least once &#123;@link #tryAcquire&#125;,</span><br><span class="line"> * returning on success.  Otherwise the thread is queued, possibly</span><br><span class="line"> * repeatedly blocking and unblocking, invoking &#123;@link</span><br><span class="line"> * #tryAcquire&#125; until success.  This method can be used</span><br><span class="line"> * to implement method &#123;@link Lock#lock&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param arg the acquire argument.  This value is conveyed to</span><br><span class="line"> *        &#123;@link #tryAcquire&#125; but is otherwise uninterpreted and</span><br><span class="line"> *        can represent anything you like.</span><br><span class="line"> */</span><br><span class="line">public final void acquire(int arg) &#123;</span><br><span class="line">    if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">    boolean failed = true;</span><br><span class="line">    try &#123;</span><br><span class="line">        boolean interrupted = false;</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            final Node p = node.predecessor();</span><br><span class="line">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = null; // help GC</span><br><span class="line">                failed = false;</span><br><span class="line">                return interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        if (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Convenience method to interrupt current thread.</span><br><span class="line"> */</span><br><span class="line">static void selfInterrupt() &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void interrupt() &#123;</span><br><span class="line">    if (this != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    synchronized (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        if (b != null) &#123;</span><br><span class="line">            interrupt0();           // Just to set the interrupt flag</span><br><span class="line">            b.interrupt(this);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private native void interrupt0();</span><br></pre></td></tr></table></figure>

<h4 id="配合的Condition"><a href="#配合的Condition" class="headerlink" title="配合的Condition"></a>配合的Condition</h4><p>在下篇手记-介绍Condition中有详细分析~</p>
<h4 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h4><ol>
<li>synchronized关键字：它是由JVM实现，并有很多内存监控工具提供帮助，并通过这些工具配合synchronized的内存标识，进行内存层面的“debug”或观察；当运行时出现异常，JVM会自动解锁并进行处理。</li>
<li>ReentrantLock、ReentrantReadWriteLock、StampedLock是对象层面的锁，需要手动指定加锁与解锁操作（放在finally中）。</li>
<li>StampedLock：因为加入乐观锁，故对吞吐量有较大的优化，尤其是读多写少时。但使用起来较复杂，API内容较多。</li>
<li>当线程较少推荐使用synchronized关键字，简单效率高；当线程较多，且线程并发的增长有一定趋势时（可预估），推荐使用ReentrantLock。</li>
</ol>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-08-05T10:49:55.458Z" itemprop="dateUpdated">2019-08-05 18:49:55</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2018/11/11/并发编程/慕课网java高并发/第六章 JUC之AQS/" target="_blank" rel="external">http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第六章 JUC之AQS/</a>
        
    </div>
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="John Doe">
            John Doe
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/并发/">并发</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第六章 JUC之AQS/&title=《第六章 JUC 之AQS》 — Hexo&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第六章 JUC之AQS/&title=《第六章 JUC 之AQS》 — Hexo&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2018/11/11/并发编程/慕课网java高并发/第一章 并发基础/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">第1章 并发基础</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2018/11/11/并发编程/慕课网java高并发/第四章 安全发布对象/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">第4章 安全发布对象</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-并发容器J-U-C-–-AQS组件CountDownLatch、Semaphore、CyclicBarrier"><span class="post-toc-number">1.</span> <span class="post-toc-text">1 并发容器J.U.C – AQS组件CountDownLatch、Semaphore、CyclicBarrier</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AQS简介"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">AQS简介</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AQS设计思想"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">AQS设计思想</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AQS的大致实现思路"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">AQS的大致实现思路</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AQS组件：CountDownLatch"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">AQS组件：CountDownLatch</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AQS组件：Semaphore"><span class="post-toc-number">1.0.5.</span> <span class="post-toc-text">AQS组件：Semaphore</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#AQS组件：CyclicBarrier"><span class="post-toc-number">1.0.6.</span> <span class="post-toc-text">AQS组件：CyclicBarrier</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-并发容器J-U-C-–-AQS组件-锁：ReentrantLock、ReentrantReadWriteLock、StempedLock"><span class="post-toc-number">2.</span> <span class="post-toc-text">2 并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何使用ReentrantLock？"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">如何使用ReentrantLock？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Condition的使用"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">Condition的使用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#票据锁：StempedLock"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">票据锁：StempedLock</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何选择锁？"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">如何选择锁？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#J-U-C之AQS—CountDownLatch"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">J.U.C之AQS—CountDownLatch</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#概述"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用场景"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">使用场景</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#例子演示"><span class="post-toc-number">2.3.3.</span> <span class="post-toc-text">例子演示</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#情景一：指定计数次数"><span class="post-toc-number">2.3.3.1.</span> <span class="post-toc-text">情景一：指定计数次数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#情景二：指定计数时间"><span class="post-toc-number">2.3.3.2.</span> <span class="post-toc-text">情景二：指定计数时间</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#小总结"><span class="post-toc-number">2.3.4.</span> <span class="post-toc-text">小总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#J-U-C之AQS—Semaphore"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">J.U.C之AQS—Semaphore</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述-1"><span class="post-toc-number">2.4.0.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用场景-1"><span class="post-toc-number">2.4.0.2.</span> <span class="post-toc-text">使用场景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#例子演示-1"><span class="post-toc-number">2.4.0.3.</span> <span class="post-toc-text">例子演示</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#如果并发数太多了，但是资源还有限，这时候怎么搞？"><span class="post-toc-number">2.4.0.4.</span> <span class="post-toc-text">如果并发数太多了，但是资源还有限，这时候怎么搞？</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#J-U-C之AQS—CyclicBarrier"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">J.U.C之AQS—CyclicBarrier</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述-2"><span class="post-toc-number">2.5.0.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#与CountDownLatch的比较："><span class="post-toc-number">2.5.0.2.</span> <span class="post-toc-text">与CountDownLatch的比较：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#演示例子-1"><span class="post-toc-number">2.5.0.3.</span> <span class="post-toc-text">演示例子-1</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#源码分析"><span class="post-toc-number">2.5.0.4.</span> <span class="post-toc-text">源码分析</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#演示例子-2"><span class="post-toc-number">2.5.0.5.</span> <span class="post-toc-text">演示例子-2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#演示例子-3"><span class="post-toc-number">2.5.0.6.</span> <span class="post-toc-text">演示例子-3</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#并发容器J-U-C-–-AQS组件-锁：ReentrantLock、ReentrantReadWriteLock、StempedLock"><span class="post-toc-number">3.</span> <span class="post-toc-text">并发容器J.U.C – AQS组件 锁：ReentrantLock、ReentrantReadWriteLock、StempedLock</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何使用ReentrantLock？-1"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">如何使用ReentrantLock？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何选择锁？-1"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">如何选择锁？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#J-U-C之AQS—RentrantLock-Part-1"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">J.U.C之AQS—RentrantLock-Part-1</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#概述-3"><span class="post-toc-number">3.2.0.1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#特有功能："><span class="post-toc-number">3.2.0.2.</span> <span class="post-toc-text">特有功能：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#适用场景"><span class="post-toc-number">3.2.0.3.</span> <span class="post-toc-text">适用场景</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#演示例子"><span class="post-toc-number">3.2.0.4.</span> <span class="post-toc-text">演示例子</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#J-U-C之AQS—RentrantLock-Part-2"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">J.U.C之AQS—RentrantLock-Part-2</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#源码学习"><span class="post-toc-number">3.3.0.1.</span> <span class="post-toc-text">源码学习</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#配合的Condition"><span class="post-toc-number">3.3.0.2.</span> <span class="post-toc-text">配合的Condition</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#小总结："><span class="post-toc-number">3.3.0.3.</span> <span class="post-toc-text">小总结：</span></a></li></ol></li></ol></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.lujingtao.com" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                John Doe &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第六章 JUC之AQS/&title=《第六章 JUC 之AQS》 — Hexo&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第六章 JUC之AQS/&title=《第六章 JUC 之AQS》 — Hexo&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADJElEQVR42u3aS27bQBAFQN3/0grgbWDqvR4JMFvFlUGTw6kxkE5/Ho/4ev5cv915Ble72v8rX995fOLCxsbGvgk72e71h5MN5c8nh3W9z+TosbGxsfexr4PW9abzQDULfgky/yI2Njb2N7MTZLvpNkC2fx5sbGxs7Ha5JKj8mh7Ex5EnPNjY2Njfw27/059vNK/M52/NEhtsbGzsrey20fuXf/5gfxsbGxv7T7JPSvNtUGlbuUkAG+4fGxsbexE7STOSf/9nrd92uKdtKrwQYWNjY69gzwrxs8bwrLXQ7jMqV2FjY2MvYicBI/9A+27bWm4bGFHcxsbGxr45O08qZoFk9tu2iZuHUmxsbOyt7DyMvSEBGJWN8uejA8LGxsZexD4p3LQJQNvEbcc0Z6EOGxsbexP7fDimpZ6Et+QIiroaNjY29gr2rK07axWfJCFtnf/FatjY2Ng3Z7fFmvMyUJJItLz2oLGxsbE3sWf4WYScIdtBomFvBBsbG/vm7Bm1DXJ5w3jWWp6VtLCxsbG3svOyzqzE076VwGajQtjY2Nib2G0ykG/xPPFoR3aKAIaNjY19c/YsSMzGcfLnz5vEL1bDxsbGXsdu2wD5ME3eQsjLRrMyFjY2NvZu9hsWemuAaUtFeSqCjY2NvY99kga0oWhWHsqP4G0FJmxsbOxbsZOFPlHimbWW8/28+BY2Njb2anbbDE6ate3h5usPB4mwsbGxv4zdNoDzlsBsnujkaLCxsbH3sU9gedg4OazrINeOFmFjY2PvZrcfy0d82pZt/vWjZ7CxsbEXsWfjL+3S7UHkIbBtHmNjY2PvZg9HGIODyMPheWBrC2TY2NjYO9h5uSfBzJ5P3s3jcB2rsbGxsW/IfpbXSVHpPFi2Qz9RfxsbGxv75uzZoEx756R41Aaqk4YENjY29n3Zs1QhKfq3LeR67OakzISNjY29jj0rM82oeYCctQGwsbGxsfPm60lZ/71HUAc/bGxs7K9kz4pESSk/uX9S9noxrIONjY29gt2O4MxGZ84DWLLzKO/AxsbGXsRuSzPtAc22m7910k7GxsbGvjn7H5FKRSgo2XIoAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.3"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.3"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.3"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.3"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.3"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
