<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>第3章 线程安全性 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ferrymana&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ferrymana&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">第3章 线程安全性</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 11, 2018&nbsp;&nbsp;10:13:42</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/并发/">并发</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="1线程安全性"><a href="#1线程安全性" class="headerlink" title="1线程安全性"></a>1线程安全性</h1><p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-062856.png" alt="image-20190801142855084"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-062907.png" alt="image-20190801142905922"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-064811.png" alt="image-20190801144809566"></p>
<hr>
<p>![image-20190801152050268](../../../../../Users/apple/Library/Application Support/typora-user-images/image-20190801152050268.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal  = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">//同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//变量声明：计数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();<span class="comment">//创建线程池</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);<span class="comment">//定义信号量，给出允许并发的数目</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);<span class="comment">//定义计数器闭锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;clientTotal;i++)&#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//判断进程是否允许被执行</span></span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();<span class="comment">//释放进程</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"excption"</span>,e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();<span class="comment">//保证信号量减为0</span></span><br><span class="line">        executorService.shutdown();<span class="comment">//关闭线程池</span></span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>,count.get());<span class="comment">//变量取值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count.incrementAndGet();<span class="comment">//变量操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">说到原子性，一共有两个方面需要学习一下，一个是JDK中已经提供好的Atomic包，他们均使用了CAS完成线程的原子性操作，另一个是使用锁的机制来处理线程之间的原子性。 锁包括：synchronized、Lock</span><br></pre></td></tr></table></figure>

<h2 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h2><p>上边的示例代码就是通过AtomicInteger类保证了线程的原子性。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么它是如何保证原子性的呢？ 我们接下来分析一下它的源码。 示例中，对count变量的+1操作，采用的是incrementAndGet方法，此方法的源码中调用了一个名为unsafe.getAndAddInt的方法</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">        count.getAndIncrement();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此方法中，方法参数为要操作的对象Object var1、期望底层当前的数值为var2、要修改的数值var4。 定义的var5为真正从底层取出来的值。 采用do.. while循环的方式去获取底层数值并与期望值进行比较，比较成功才将值进行修改。 而这个比较再进行修改的方法就是compareAndSwapInt就是我们所说的CAS，它是一系列的接口，比如下面罗列的几个接口。 使用native修饰，是底层的方法。 CAS取的是compareAndSwap三个单词的首字母.</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> JNI在某些情况下可能带来很大的开销和性能损失:</p>
</blockquote>
<ul>
<li><p>调用 JNI 方法是很笨重的操作, 特别是在多次重复调用的情况下.</p>
</li>
<li><p>Native 方法不会被 JVM 内联, 也不会被 JIT compiled 优化 , 因为方法已经被编译过了.</p>
</li>
<li><p>Java 数组可能会被拷贝一份,以传递给 native 方法, 执行完之后再拷贝回去. 其开销与数组的长度是线性相关的.</p>
</li>
<li><p>如果传递一个对象给方法,或者需要一个回调,那么 Native 方法可能会自己调用JVM。 访问Java对象的属性、方法和类型时, Native代码需要类似reflection的东西。签名由字符串指定,通从JVM中查询。这非常缓慢并且容易出错。</p>
</li>
<li><p>Java 中的字符串(String) 也是对象, 有 length 属性,并且是编码过的. 读取或者创建字符串都需要一次时间复杂度为 O(n) 的复制操作.</p>
<p>再分析其函数的调用：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>其中var1为当前传入的对象即count，var2是当前count的值，var4即为incrementAndGet()方法的默认加数，为1，var5是调用的另一个JNI的方法得到底层当前的count值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure>

<p> Volatile关键字很熟悉，简述是保证了线程之间操作的对象的值互相透明、可见性。**</p>
<p>（Volatile关键字的详述又该是一个大文章了！过阵子再写！）<br>那么现在应该就懂了，<strong>用底层得到的值不断循环比较当前的值，如果两者相等就加一并再用JNI底层方法写入主内存。</strong><br>AtomicInteger类就是使用了该方法即<strong>CAS原理</strong>来保证线程安全的。（CAS原理也是一个大块头。。）<br>同理，AtomicXXX类（XXX是属于Java的Object，例如Long、Double等）都是该方法保证的！</p>
<p> ConpareAndSet概述</p>
<p>该方法和ConpareAndSwap有些相似，但还有不同：ConpareAndSet(a,b)更多的是用在AtomicBoolean类中（Boolean要求false与true的转换同一时间只能被一个线程调用，且false(true)只能转换为true(false)，其中的参数a,b即为只能相互转换的数，<strong>顺序为：当为a的时候更新为b</strong>）。</p>
<h2 id="longAdder"><a href="#longAdder" class="headerlink" title="longAdder"></a>longAdder</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static LongAdder longAdder = new LongAdder();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">longAdder.increment();</span><br></pre></td></tr></table></figure>

<p>那么问题来了，为什么有了AtomicLong还要新增一个LongAdder呢？<br>原因是：CAS底层实现是在一个死循环中不断地尝试修改目标值，直到修改成功。 如果竞争不激烈的时候，修改成功率很高，否则失败率很高。 在失败的时候，这些重复的原子性操作会耗费性能。</p>
<blockquote>
<p>知识点： 对于普通类型的long、double变量，JVM允许将64位的读操作或写操作拆成两个32位的操作。</p>
<h2 id="LongAdder类的实现核心是将热点数据分离，比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，-而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。-当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。-这相当于将AtomicLong的单点的更新压力分担到各个节点上。-在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。-而在高并发的时候通过分散提高了性能。"><a href="#LongAdder类的实现核心是将热点数据分离，比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数，-而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。-当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。-这相当于将AtomicLong的单点的更新压力分担到各个节点上。-在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。-而在高并发的时候通过分散提高了性能。" class="headerlink" title="LongAdder类的实现核心是将热点数据分离，比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数， 而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。 当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。 这相当于将AtomicLong的单点的更新压力分担到各个节点上。 在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。 而在高并发的时候通过分散提高了性能。"></a>LongAdder类的实现核心是将热点数据分离，比如说它可以将AtomicLong内部的内部核心数据value分离成一个数组，每个线程访问时，通过hash等算法映射到其中一个数字进行计数， 而最终的计数结果则为这个数组的求和累加，其中热点数据value会被分离成多个单元的cell，每个cell独自维护内部的值。 当前对象的实际值由所有的cell累计合成，这样热点就进行了有效地分离，并提高了并行度。 这相当于将AtomicLong的单点的更新压力分担到各个节点上。 在低并发的时候通过对base的直接更新，可以保障和AtomicLong的性能基本一致。 而在高并发的时候通过分散提高了性能。</h2></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">由于AtomicLong的底层是CAS原理，即通过死循环不断地比较当前值与主内存的值，那么当线程并发量较少时其比较成功的概率是高的，但放并发量很大时，比较成功概率就会很低，越低则死循环持续的时间越久，占用的系统资源越大，系统运行的效率越低。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LongAdder的实现思想为：热点数据分离：将AtomicLong的核心数据value分离为一个数组，每个线程访问时通过hash等算法预测到其中的一个数字进行计数，最终的计数结果为该数组各部分的求和。热点数据value会被分为多个部分的shell，每个shell独自维护各自的值，而当前对象的实际值为各部分shell的累加和。保证热点数据的有效分离，提高并行度。LongAdder类实际是在AtomicLong的基础上进行了优化：在低并发时不做分离，同AtomicLong是对base的直接CAS更新，但是高并发时将单点的压力分摊到各部分的shell上以提高性能。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>缺点：如果在统计的时候，如果有并发更新，可能会有统计数据有误差。 实际使用中在处理高并发计数的时候优先使用LongAdder，而不是AtomicLong在线程竞争很低的时候，使用AtomicLong会简单效率更高一些。 比如序列号生成（准确性 </p>
</blockquote>
<h2 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference<integer></integer></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; count = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        count.compareAndSet(<span class="number">0</span>, <span class="number">2</span>);<span class="comment">//2</span></span><br><span class="line">        count.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//no</span></span><br><span class="line">        count.compareAndSet(<span class="number">1</span>, <span class="number">3</span>);<span class="comment">//no</span></span><br><span class="line">        count.compareAndSet(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//4</span></span><br><span class="line">        count.compareAndSet(<span class="number">3</span>, <span class="number">5</span>);<span class="comment">//no</span></span><br><span class="line">        log.info(<span class="string">"count=&#123;&#125;"</span>, count);<span class="comment">//4 </span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h2 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h2><blockquote>
<h1 id="AtomicReferenceFieldUpdater的核心为：原子性地去更新某一个类的实例中指定的某一个字段，而该字段必须使用volatile标识且不能被static标识进行声明。"><a href="#AtomicReferenceFieldUpdater的核心为：原子性地去更新某一个类的实例中指定的某一个字段，而该字段必须使用volatile标识且不能被static标识进行声明。" class="headerlink" title="AtomicReferenceFieldUpdater的核心为：原子性地去更新某一个类的实例中指定的某一个字段，而该字段必须使用volatile标识且不能被static标识进行声明。"></a><strong>AtomicReferenceFieldUpdater的核心为：原子性地去更新某一个类的实例中指定的某一个字段，而该字段必须使用volatile标识且不能被static标识进行声明。</strong></h1></blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明更新的类为AtomicExample5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;AtomicExample5&gt; updater =</span><br><span class="line">            <span class="comment">//newUpdater()的第一个参数为该指明的类的class，第二参数为作用的字段区域的名字filedName（该字段必须被volatile标识声明）</span></span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(AtomicExample5.class, <span class="string">"count"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加get方法</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        AtomicExample5 example5 = <span class="keyword">new</span> AtomicExample5();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 1, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updater.compareAndSet(example5, <span class="number">100</span>, <span class="number">120</span>)) &#123;</span><br><span class="line">            log.info(<span class="string">"update success 2, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"update failed, &#123;&#125;"</span>, example5.getCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20190801152246345](../../../../../Users/apple/Library/Application Support/typora-user-images/image-20190801152246345.png)</p>
<p>$ 手记小总结$ </p>
<p>AtomicReference与AtomicReferenceFieldUpdater都是用于原子性地修改更新，都是线程安全的。 但是后者是通过指定类的实例中的某一个字段，且该字段必须使用volatile标识且非static标识进行声明。<br>这两个类实际中用到的都不是很多…</p>
<h2 id="AtomicStampReference与CAS的ABA问题"><a href="#AtomicStampReference与CAS的ABA问题" class="headerlink" title="AtomicStampReference与CAS的ABA问题"></a>AtomicStampReference与CAS的ABA问题</h2><ul>
<li>问题分析</li>
</ul>
<blockquote>
<p>CAS算法实现一个重要前提：<strong>需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。</strong> </p>
</blockquote>
<p>^_^什么是ABA问题？ </p>
<ul>
<li><p>CAS操作的时候，其他线程将变量的值A改成了B，但是随后又改成了A，本线程在CAS方法中使用期望值A与当前变量进行比较的时候，发现变量的值未发生改变，于是CAS就将变量的值进行了交换操作。 但是实际上变量的值已经被其他的变量改变过，这与设计思想是不符合的。 所以就有了AtomicStampReference。</p>
<p>其实还有另外一种情况：</p>
</li>
</ul>
<p><strong>A最开始的内存地址是X，然后失效了，有分配了B，恰好内存地址是X，这时候通过CAS操作也成功了</strong>，但是在像Java这种有GC机制的语言中，若A失效就被GC处理了，不会发生这种情况。 若是在像C/C++没有GC机制的语言中是有可能出现的。</p>
<ul>
<li>解决方案：</li>
</ul>
<ol>
<li>像各种乐观锁的实现中通常都会用版本戳version(保持递增加一规则)来对记录或对象标记，在CAS时加上对该版本戳的比较。</li>
<li>在Java语言中，AtomicStampedReference也是使用类似的机制做解决方案。</li>
</ol>
<p>其核心方法为</p>
<p>其中设定stamp值的原子性方法为：由于是非阻塞方法，即使两个参数对应，请求也会不合逻辑地失败。 但最终当没有其他线程请求时就会成功。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value of both the reference and stamp</span></span><br><span class="line"><span class="comment"> * to the given update values if the</span></span><br><span class="line"><span class="comment"> * current reference is &#123;<span class="doctag">@code</span> ==&#125; to the expected reference</span></span><br><span class="line"><span class="comment"> * and the current stamp is equal to the expected stamp.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedReference the expected value of the reference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newReference the new value for the reference</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedStamp the expected value of the stamp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newStamp the new value for the stamp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AtomicStampReference的处理思想是，每次变量更新的时候，将变量的版本号+1，之前的ABA问题中，变量经过两次操作以后，变量的版本号就会由1变成3，也就是说只要线程对变量进行过操作， 变量的版本号就会发生更改。 从而解决了ABA问题。</p>
<p>解释一下上边的源码：<br>类中维护了一个volatile修饰的Pair类型变量current，Pair是一个私有的静态类，current可以理解为底层数值。<br>compareAndSet方法的参数部分分别为期望的引用、新的引用、期望的版本号、新的版本号。 </p>
<p>return的逻辑为判断了期望的引用和版本号是否与底层的引用和版本号相符，并且排除了新的引用和新的版本号与底层的值相同的情况（即不需要修改）的情况（return代码部分3、4行）。 条件成立，执行casPair方法，调用CAS操作。</p>
<h2 id="AtomicLongArray"><a href="#AtomicLongArray" class="headerlink" title="AtomicLongArray"></a>AtomicLongArray</h2><p>这个类实际上维护了一个Array数组，我们在对数值进行更新的时候，会多一个索引值让我们更新。</p>
<blockquote>
<p>原子性，提供了互斥访问，同一时刻只能有一个线程来对它进行操作。 那么在java里，保证同一时刻只有一个线程对它进行操作的，除了Atomic包之外，还有锁的机制。 JDK提供锁主要分为两种：synchronized和Lock。 接下来我们了解一下synchronized。</p>
</blockquote>
<hr>
<h2 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h2><p>这个类中值得一提的是它包含了一个名为compareAndSet的方法，这个方法可以做到的是控制一个boolean变量在一件事情执行之前为false，事情执行之后变为true。 或者也可以理解为可以控制某一件事只让一个线程执行，并仅能执行一次。<br>他的源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean compareAndSet(boolean expect, boolean update) &#123;</span><br><span class="line">    int e = expect ? 1 : 0;</span><br><span class="line">    int u = update ? 1 : 0;</span><br><span class="line">    return unsafe.compareAndSwapInt(this, valueOffset, e, u);</span><br><span class="line">&#125;</span><br><span class="line">--------------------- </span><br><span class="line"> ！</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//是否发生过</span><br><span class="line">    private static AtomicBoolean isHappened = new AtomicBoolean(false);</span><br><span class="line">    // 请求总数</span><br><span class="line">    public static int clientTotal = 5000;</span><br><span class="line">    // 同时并发执行的线程数</span><br><span class="line">    public static int threadTotal = 200;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        final Semaphore semaphore = new Semaphore(threadTotal);</span><br><span class="line">        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);</span><br><span class="line">        for (int i = 0; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    test();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    log.error(&quot;exception&quot;, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(&quot;isHappened:&#123;&#125;&quot;, isHappened.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void test() &#123;</span><br><span class="line">        if (isHappened.compareAndSet(false, true)) &#123;//控制某有一段代码只执行一次</span><br><span class="line">            log.info(&quot;execute&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-原子性-synchronized"><a href="#2-原子性-synchronized" class="headerlink" title="2 原子性-synchronized"></a>2 原子性-synchronized</h1><p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-074531.png" alt="image-20190801154530298"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample1 example1 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        SynchronizedExample1 example2 = <span class="keyword">new</span> SynchronizedExample1();</span><br><span class="line">        </span><br><span class="line">      ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test2(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example2.test2(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Slf4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample2.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                log.info(<span class="string">"test1 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修饰一个静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"test2 &#123;&#125; - &#123;&#125;"</span>, j, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedExample2 example1 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        SynchronizedExample2 example2 = <span class="keyword">new</span> SynchronizedExample2();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example1.test1(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example2.test1(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Java 语言中主要的同步手段就是 synchronized 关键字，它强制实行互斥，确保执行 synchronized 块的线程的动作，能够被后来执行受相同锁保护的 synchronized 块的其他线程看到。<br>在使用得当的时候，内在锁可以让程序做到线程安全，但是在使用锁定保护短的代码路径，而且线程频繁地争用锁的时候，锁定可能成为相当繁重的操作。<a href="https://www.ibm.com/developerworks/cn/java/j-jtp04186/" target="_blank" rel="noopener">参考学习</a></p>
<blockquote>
<p>内在锁synchronized关键字的实现依赖于JVM，因此<strong>在这个关键字作用的对象的作用范围内都是同一时刻只能有一个线程进行操作。</strong></p>
</blockquote>
<p>它是一种同步锁，作用对象有四种：</p>
<ol>
<li>修饰代码块：指用大括号括起来的代码，被称为“同步代码块”，作用于调用该代码块的对象。</li>
<li>修饰方法：指整个方法，被称为同步方法，作用于调用该方法的对象。</li>
<li>修饰静态方法：指整个静态方法，由于静态方法可以被理解为类级别的对象，因此它作用于该类的所有的对象。</li>
<li>修饰类：指整个类，作用于该类的所有的对象。</li>
</ol>
<h4 id="引申拓展：另一种锁Lock"><a href="#引申拓展：另一种锁Lock" class="headerlink" title="引申拓展：另一种锁Lock"></a>引申拓展：另一种锁Lock</h4><p>JDK提供的基于源码的锁，依赖于特殊的CPU指令、代码实现。其代表为ReentrantLock.<br>后续将会单独做一篇手记。</p>
<h4 id="线程安全中原子性方式的简单对比"><a href="#线程安全中原子性方式的简单对比" class="headerlink" title="线程安全中原子性方式的简单对比"></a>线程安全中原子性方式的简单对比</h4><ol>
<li>synchronized：是不可中断锁，适合竞争不激烈的场景，其可读性较好。</li>
<li>Lock：可通过unlock进行锁的中断，在竞争激烈时仍可以保持常态，同步多样化。</li>
<li>Atomic包：竞争激烈时也可以保持常态，性能比Lock好，但缺点是只能通过CAS同步一个值。</li>
</ol>
<blockquote>
<p><a href="https://www.jianshu.com/p/d53bf830fa09" target="_blank" rel="noopener">https://www.jianshu.com/p/d53bf830fa09</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/zjy15203167987/article/details/82531772" target="_blank" rel="noopener">https://blog.csdn.net/zjy15203167987/article/details/82531772</a></p>
</blockquote>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-080748.png" alt="image-20190801160746548"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-080806.png" alt="image-20190801160757286"></p>
<h2 id="3-可见vcolatile"><a href="#3-可见vcolatile" class="headerlink" title="3 可见vcolatile"></a>3 可见vcolatile</h2><p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-080916.png" alt="image-20190801160914371"></p>
<hr>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-080946.png" alt="image-20190801160944292"></p>
<hr>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081038.png" alt="image-20190801161036219"></p>
<hr>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081120.png" alt="image-20190801161118659"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081138.png" alt="image-20190801161137226"></p>
<hr>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081359.png" alt="image-20190801161357427"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountExample4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">5000</span>;</span><br><span class="line">    <span class="comment">// 同时并发执行的线程数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal ; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    add();</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">"exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        log.info(<span class="string">"count:&#123;&#125;"</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">// 1、count</span></span><br><span class="line">        <span class="comment">// 2、+1</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">// 3、count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在单线程执行此操作绝对没有问题，但是在多线程环境中，假设有两个线程A、B同时执行count++操作，某一刻A与B同时读取主存中count的值，然后在自己线程对应的工作空间中对count+<span class="number">1</span>，最后又同时将count+<span class="number">1</span>的值写回主存。到此，count+<span class="number">1</span>的值被写回主存两遍，所以导致最终的count值小了<span class="number">1</span>。在整体程序执行过程中，该事件发生一次或多次，自然结果就不正确。 </span><br><span class="line">那么<span class="keyword">volatile</span>适合做什么呢？其实它比较适合做状态标记量（不会涉及到多线程同时读写的操作），而且要保证两点： </span><br><span class="line">（<span class="number">1</span>）对变量的写操作不依赖于当前值 </span><br><span class="line">（<span class="number">2</span>）该变量没有包含在具有其他变量的不变的式子中 </span><br><span class="line">例如：</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程一：</span></span><br><span class="line">context = loadContext();</span><br><span class="line">inited = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程二：</span></span><br><span class="line"><span class="keyword">while</span>（!inited）&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingWithConfig(context);</span><br></pre></td></tr></table></figure>

<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-082330.png" alt="image-20190801162328034"></p>
<h4 id="Volatile概述"><a href="#Volatile概述" class="headerlink" title="Volatile概述"></a>Volatile概述</h4><p>指一个线程对主内存的修改，可以及时地被其他线程观察到。</p>
<blockquote>
<p>导致共享变量在线程间不可见的原因有：</p>
<ol>
<li>多线程交叉进行。</li>
<li>重排序结合多线程运行。</li>
<li>共享变量更新后的值未及时进行工作内存与主内存的更新。</li>
</ol>
</blockquote>
<p>Java内存模型对synchronized关键字有两条规定。</p>
<ol>
<li>线程解锁前必须把共享变量的最新值刷新到主内存。</li>
<li>线程加锁时，将清空工作内存中共享变量的值。那么工作内存需要时只能从工作内存中取值。</li>
</ol>
<p><strong>工作原理：此时的加锁和解锁用的是一个锁，即多线程之间共享synchronized一个锁。</strong></p>
<h4 id="可见性之volatile关键字"><a href="#可见性之volatile关键字" class="headerlink" title="可见性之volatile关键字"></a>可见性之volatile关键字</h4><p><strong>工作原理：通过加入内存屏障和禁止重排序优化来实现，即通过内存屏障保证了禁止重排序优化</strong><br><code>内存屏障</code>从以下两点进行说明：</p>
<ol>
<li><p>对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将本地工作内存中的值刷新到主内存。</p>
</li>
<li><p>对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存读取共享变量的值。</p>
<blockquote>
<p>即强迫从主内存中的共享变量进行交互。</p>
</blockquote>
</li>
</ol>
<p>** volatile使用的场景</p>
<p>场景需具备的条件：</p>
<ol>
<li>对变量的写操作不依赖与当前值</li>
<li>该变量没有包含在具有其他变量的不变的式子中。</li>
</ol>
<p>因此，</p>
<ol>
<li><strong>volatile适合作为状态标记量(boolean型)</strong></li>
<li><strong>适用于doublecheck场景。</strong>（例子会在之后手记中添上……）</li>
</ol>
<p>**</p>
<h1 id="4-有序性"><a href="#4-有序性" class="headerlink" title="4 有序性"></a>4 有序性</h1><p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081727.png" alt="image-20190801161725846"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081736.png" alt="image-20190801161735392"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081857.png" alt="image-20190801161855638"></p>
<hr>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-01-081910.png" alt="image-20190801161909005"></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java中保证有序性</span><br><span class="line"></span><br><span class="line">java提供了 volatile、synchronized、Lock可以用来保证有序性 </span><br><span class="line">另外，java内存模型具备一些先天的有序性，即不需要任何手段就能得到保证的有序性。通常被我们成为happens-before原则（先行发生原则）。如果两个线程的执行顺序无法从happens-before原则推导出来，那么就不能保证它们的有序性，虚拟机就可以对它们进行重排序。</span><br><span class="line"></span><br><span class="line">【以下规则来自于《深入理解java虚拟机》】</span><br><span class="line"></span><br><span class="line">程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</span><br><span class="line">锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作</span><br><span class="line">volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作（重要）</span><br><span class="line">传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</span><br><span class="line">——————————————————————————————————————————————</span><br><span class="line">线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作</span><br><span class="line">线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</span><br><span class="line">线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</span><br><span class="line">对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</span><br></pre></td></tr></table></figure>

<h4 id="问题导出"><a href="#问题导出" class="headerlink" title="问题导出"></a>问题导出</h4><ol>
<li>Java内存模型中，允许编译器和翻译器对指令进行重排序，但是重排序的过程不会影响到<strong>单线程</strong>程序的运行，却会影响到多线程并发执行的正确性。</li>
<li>Java中的volatile通过<code>内存屏障</code>也可以一定程度上禁止指令的重排序。</li>
<li>synchronized和Lock机制都是通过线程阻塞对于主内存来讲其同一时刻只有一个线程可以访问操作，保证了有序性。</li>
<li>Java内存模型实际存在先天的有序性：不需要通过任何手段即可保证一定的有序性，即happens-before原则。</li>
</ol>
<blockquote>
<p>如果两个操作的次序无法从happens-before原则中得到保证，那么该两个操作不能保证自己的有序性：即被JVM随意地进行重排序。</p>
</blockquote>
<h4 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h4><blockquote>
<p>前四条较为重要，后四条浅显易懂</p>
</blockquote>
<ol>
<li>程序次序规则：<strong>单线程内</strong>，按照代码顺序，书写在前面的操作先行发生与书写在后面的操作。（此时的JVM只会对非数据依赖的指令进行重排序）</li>
<li>锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。</li>
<li><strong>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。</strong></li>
<li>传递规则：若操作A先行发生于操作B，B又先行发生于操作C，那么操作A先行发生于操作C。</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始。</li>
</ol>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第三章 线程安全性/">http://yoursite.com/2018/11/11/并发编程/慕课网java高并发/第三章 线程安全性/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/并发/"># 并发</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/11/11/并发编程/慕课网java高并发/第七章 J.U.C组件拓展/">第七章 JUC 扩展 FutureTask、ForkJoin、BlockingQueue</a>
            
            
            <a class="next" rel="next" href="/2018/11/10/SpringCloud/小D课堂springcloud/">小D课堂SpringCloud笔记</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
