<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>面试总结 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ferrymana&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ferrymana&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">面试总结</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 14, 2019&nbsp;&nbsp;21:39:20</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/面试/">面试</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="面试题目总结"><a href="#面试题目总结" class="headerlink" title="面试题目总结"></a>面试题目总结</h1><p>#1 hashMap底层？</p>
<p> <strong>JDK1.8中，HashMap采用位桶+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树</strong>，这样大大减少了查找时间。</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-14-140432.png" alt="image-20191014220432201"></p>
<hr>
<p>简单说下HashMap的实现原理：</p>
<p>首先有一个每个元素都是链表（可能表述不准确）的数组，当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，所以说数组存放的是链表。而当链表长度太长时，链表就转换为红黑树，这样大大提高了查找的效率。</p>
<pre><code>当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中</code></pre><p>即HashMap的原理图是：</p>
<p> <img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-14-140557.png" alt="image-20191014220556475"></p>
<h1 id="2-为什么jdk1-8要用红黑树实现？"><a href="#2-为什么jdk1-8要用红黑树实现？" class="headerlink" title="2 为什么jdk1.8要用红黑树实现？"></a>2 为什么jdk1.8要用红黑树实现？</h1><p>在Jdk1.8版本后，Java对HashMap做了改进，在链表长度大于8的时候，将后面的数据存在红黑树中，以加快检索速度</p>
<hr>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-14-141311.png" alt="image-20191014221310856"></p>
<hr>
<h1 id="3-为什么HashMap线程不安全，在多线程操作情况下什么时候线程不安全？"><a href="#3-为什么HashMap线程不安全，在多线程操作情况下什么时候线程不安全？" class="headerlink" title="3 为什么HashMap线程不安全，在多线程操作情况下什么时候线程不安全？"></a>3 为什么HashMap线程不安全，在多线程操作情况下什么时候线程不安全？</h1><p>HashMap在put的时候，插入的元素超过了容量（由负载因子决定）的范围就会触发扩容操作，就是rehash，这个会重新将原数组的内容重新hash到新的扩容数组中，在多线程的环境下，存在同时其他的元素也在进行put操作，如果hash值相同，可能出现同时在同一数组下用链表表示，造成闭环，导致在get时会出现死循环，所以HashMap是线程不安全的。</p>
<blockquote>
<p> <a href="https://blog.csdn.net/loveliness_peri/article/details/81092360" target="_blank" rel="noopener">https://blog.csdn.net/loveliness_peri/article/details/81092360</a></p>
</blockquote>
<hr>
<h1 id="4-如何实现HashMap的同步？怎么解决线程不安全？"><a href="#4-如何实现HashMap的同步？怎么解决线程不安全？" class="headerlink" title="4 如何实现HashMap的同步？怎么解决线程不安全？"></a>4 如何实现HashMap的同步？怎么解决线程不安全？</h1><p>答：</p>
<p>　　第一种方法：</p>
<p>　　 直接使用Hashtable，但是当一个线程访问HashTable的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以，效率很低，现在基本不会选择它了。</p>
<p>　　第二种方法： HashMap可以通过下面的语句进行同步，</p>
<pre><code>Collections.synchronizeMap(hashMap);</code></pre><p>1<br>　　HashMap可以通过Map m = Collections.synchronizedMap(new HashMap())来达到同步的效果。（从源码中看出 synchronizedMap()方法返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized来保证对Map的操作是线程安全的，故效率其实也不高。）</p>
<p>　　具体而言，该方法返回一个同步的Map，该Map封装了底层的HashMap的所有方法，使得底层的HashMap即使是在多线程的环境中也是安全的。</p>
<p>　　第三种方法：</p>
<p>　　直接使用JDK 5 之后的 ConcurrentHashMap，如果使用Java 5或以上的话，请使用ConcurrentHashMap。</p>
<h1 id="5-认初始容量是16，如果我改成7，容量会变成7么？？为什么？"><a href="#5-认初始容量是16，如果我改成7，容量会变成7么？？为什么？" class="headerlink" title="5 认初始容量是16，如果我改成7，容量会变成7么？？为什么？"></a>5 认初始容量是16，如果我改成7，容量会变成7么？？为什么？</h1><hr>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-14-142107.png" alt="image-20191014222107185"></p>
<hr>
<h1 id="6数组和链表的区别？"><a href="#6数组和链表的区别？" class="headerlink" title="6数组和链表的区别？"></a>6数组和链表的区别？</h1><p>** 数组和链表的区别整理如下： **</p>
<p> 数组静态分配内存，链表动态分配内存；<br>数组在内存中连续，链表不连续；<br>数组元素在栈区，链表元素在堆区；<br>数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)；<br>数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)</p>
<hr>
<h1 id="7-常见的线程池有哪些"><a href="#7-常见的线程池有哪些" class="headerlink" title="7 常见的线程池有哪些?"></a>7 常见的线程池有哪些?</h1><p>java中的有哪些线程池？</p>
<p>1.newCachedThreadPool创建一个可缓存线程池程</p>
<p>2.newFixedThreadPool 创建一个定长线程池</p>
<p>3.newScheduledThreadPool 创建一个定长线程池</p>
<p>4.newSingleThreadExecutor 创建一个单线程化的线程池</p>
<pre><code>//缓存线程池，线程池的大小由jvm决定，如果有空闲线程会回收
Executors.newCachedThreadPool();
//单线程线程池，可保证任务执行的顺序就是任务提交的顺序
Executors.newSingleThreadExecutor();
//固定大小线程池（服务端推荐使用）
Executors.newFixedThreadPool(size);
//周期性线程池，可周期性执行任务
Executors.newScheduledThreadPool(size);</code></pre><hr>
<h1 id="8-Java线程池中的7个参数"><a href="#8-Java线程池中的7个参数" class="headerlink" title="8 Java线程池中的7个参数"></a>8 Java线程池中的7个参数</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数理解：</p>
<ul>
<li><p>corePollSize：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。</p>
</li>
<li><p>maximumPoolSize：最大线程数。表明线程中最多能够创建的线程数量。</p>
</li>
<li><p>keepAliveTime：空闲的线程保留的时间。</p>
</li>
<li><p>TimeUnit：空闲线程的保留时间单位。</p>
</li>
</ul>
<ul>
<li><p>BlockingQueue<runnable>：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选。</runnable></p>
</li>
<li><p>ThreadFactory：线程工厂，用来创建线程</p>
</li>
<li><p>RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略。有以下取值:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</span><br></pre></td></tr></table></figure>

<h1 id="9-newCachedThreadPool最大可开启的线程数是多少？"><a href="#9-newCachedThreadPool最大可开启的线程数是多少？" class="headerlink" title="9 newCachedThreadPool最大可开启的线程数是多少？"></a>9 newCachedThreadPool最大可开启的线程数是多少？</h1><p>这种类型的线程池特点是：</p>
<p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。<br>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</p>
<p>newCachedThreadPool无上限线程池，   动态根据代码添加线程，   如果线程空闲60秒没有被使用，会自动关闭</p>
<hr>
<h1 id="10-如何实现其他线程和主线程的同步？"><a href="#10-如何实现其他线程和主线程的同步？" class="headerlink" title="10 如何实现其他线程和主线程的同步？"></a>10 如何实现其他线程和主线程的同步？</h1><p>  <strong>Synchronized 同步</strong></p>
<p>1、方法同步。给方法增加synchronized修饰符就可以成为同步方法，可以是静态方法、非静态方法，但不能是抽象方法、接口方法。小示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void aMethod() &#123; </span><br><span class="line">    // do something </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public static synchronized void anotherMethod() &#123; </span><br><span class="line">    // do something </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用块同步，示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;  <span class="comment">//与上面示例不同于关键字使用</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">               System.out.print(<span class="string">" "</span> + i);</span><br><span class="line">           &#125;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Runnable r = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">       Thread t1 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">       Thread t2 = <span class="keyword">new</span> Thread(r);</span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>Volatile 同步</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.volatile关键字为域变量的访问提供了一种免锁机制</span><br></pre></td></tr></table></figure>

<pre><code>b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新

c.因此每次使用该域就要重新计算，而不是使用寄存器中的值 

d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量</code></pre><p>  <strong>重入锁同步</strong></p>
<p>ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力。 ReenreantLock类的常用方法有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock() : 创建一个ReentrantLock实例 </span><br><span class="line">lock() : 获得锁 </span><br><span class="line">unlock() : 释放锁</span><br></pre></td></tr></table></figure>

<p>  <strong>阻塞队列同步</strong></p>
<p>BlockingQueue<e>定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时：</e></p>
<p>　　add()方法会抛出异常</p>
<p>　　offer()方法返回false</p>
<p>　　put()方法会阻塞</p>
<p> <strong>原子变量同步</strong></p>
<p>AtomicInteger类常用方法：</p>
<p>AtomicInteger(int initialValue) : 创建具有给定初始值的新的</p>
<p>AtomicIntegeraddAddGet(int dalta) : 以原子方式将给定值与当前值相加</p>
<p>get() : 获取当前值</p>
<hr>
<h1 id="11-volatile关键字的特性有哪些？"><a href="#11-volatile关键字的特性有哪些？" class="headerlink" title="11 volatile关键字的特性有哪些？"></a>11 volatile关键字的特性有哪些？</h1><p>1 . 保证了不同线程对该变量操作的内存可见性;</p>
<p>2 . 禁止指令重排序</p>
<h1 id="12-Java使用阻塞队列BlockingQueue实现线程同步"><a href="#12-Java使用阻塞队列BlockingQueue实现线程同步" class="headerlink" title="12 Java使用阻塞队列BlockingQueue实现线程同步"></a>12 Java使用阻塞队列BlockingQueue实现线程同步</h1><p>详细阐述了多个任务之间的协同合作，需要使用wait、notify、notifyAll或者lock、condition、await、signal、signalAll方法来进行同步。实现起来比较复杂。因此java提供了同步队列（阻塞队列BlockingQueue）。<br>同步队列要求只能有一个任务对其进行操作（因此无需再对其使用同步操作，同步队列内部是同步的。）。当队列是空时，会导致取该队列的线程阻塞；当队列满（设置固定大小的队列）时，会导致写该队列的线程阻塞。<br>java的JUC（java.util.concurrent）包提供了BlockingQueue接口，并为其提供了三个实现：LinkedBlockingQueue（无界队列）、ArrayBlockingQueue（有固定大小的队列）、 SynchronousQueue（大小为1的队列</p>
<p> 从上表可以很明显看出每个方法的作用，这个不用多说。我想说的是：</p>
<ul>
<li><p>add(e) remove() element() 方法不会阻塞线程。当不满足约束条件时，会抛出IllegalStateException 异常。例如：当队列被元素填满后，再调用add(e)，则会抛出异常。</p>
</li>
<li><p>offer(e) poll() peek() 方法即不会阻塞线程，也不会抛出异常。例如：当队列被元素填满后，再调用offer(e)，则不会插入元素，函数返回false。</p>
</li>
<li><p>要想要实现阻塞功能，需要调用put(e) take() 方法。当不满足约束条件时，会阻塞线程。</p>
</li>
<li><p>BlockingQueue  阻塞算法</p>
</li>
</ul>
<h1 id="13-建mysql表的时候会考虑一些什么"><a href="#13-建mysql表的时候会考虑一些什么" class="headerlink" title="13 建mysql表的时候会考虑一些什么"></a>13 建mysql表的时候会考虑一些什么</h1><ol>
<li><strong>char与varchar</strong></li>
</ol>
<p>char ：长度固定，比较适合存储很短（比如门牌号码101，201）、固定长度（比如使用uuid作为主键）、十分频繁改变的column的字段；char(M)类型的数据列里，每个值都占用M个字节，如果某个长度小于M，MySQL就会在它的右边用空格字符补足。（在检索操作中那些填补出来的空格字符将被去掉）</p>
<p>varchar：可变长度，占用长度为字符数+1(用来存储位置)<br>总结：char 因固定长度，所以在处理速度上要比varchar快速很多，但是相对较费存储空间；所以对存储空间要求不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例<br> <img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-065958.png" alt="image-20191015145958173"></p>
<ol start="6">
<li><strong>索引</strong></li>
</ol>
<p>对于那些在查询中很少使用或者参考的列不应该创建索引。费空间</p>
<p>对于那些只有很少数据值的列也不应该增加索引。映射太少</p>
<p>对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 </p>
<p>当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。</p>
<h1 id="14-mysql索引"><a href="#14-mysql索引" class="headerlink" title="14 mysql索引"></a>14 mysql索引</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX indexName ON mytable(username(length));</span><br></pre></td></tr></table></figure>

<p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL.一个表只能有一个主键。</p>
<p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<p>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</p>
<p>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</p>
<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<p>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</p>
<p>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</p>
<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>
<p>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</p>
<p><strong>最左前缀</strong></p>
<ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>还有一个就是生效原则 比如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <strong>索引算法有 BTree Hash</strong></p>
<p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name like &apos;jack%&apos;; </span><br><span class="line">如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like &apos;%jack&apos;; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>
<p>BTree索引是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">select * from user where name like &apos;jack%&apos;; </span><br><span class="line">如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like &apos;%jack&apos;; </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>
<h1 id="15-写sql语句的时候where会考虑什么？"><a href="#15-写sql语句的时候where会考虑什么？" class="headerlink" title="15 写sql语句的时候where会考虑什么？"></a>15 写sql语句的时候where会考虑什么？</h1><p>不要在Where 字句中对列使用函数，那样会导致索引失效， </p>
<hr>
<h1 id="16-hashtable和concurrenthashmap有什么区别"><a href="#16-hashtable和concurrenthashmap有什么区别" class="headerlink" title="16 hashtable和concurrenthashmap有什么区别?"></a>16 hashtable和concurrenthashmap有什么区别?</h1><p>ConcurrentHashMap采用了更细粒度的锁来提高在并发情况下的效率。ConcurrentHashMap将Hash表默认分为16个桶（每一个桶可以被看作是一个Hashtable），大部分操作都没有用到锁，而对应的put、remove等操作也只需要锁住当前线程需要用到的桶，而不需要锁住整个数据。采用这种设计方式以后，在大并发的情况下，同时可以有16个线程来访问数据。显然，大大提高了并发性。<br>————————————————</p>
<p>Hashtable通过使用synchronized修饰方法的方式来实现多线程同步，因此，Hashtable的同步会锁住整个数组。在高并发的情况下，性能会非常差，Java5中引入了java.util.concurrent.ConcurrentHashMap作为高吞吐量的线程安全HashMap实现，它采用了锁分离的技术允许多个修改操作并发进行。它们在多线程锁的使用方式如图4所示。<br>————————————————</p>
<ol>
<li><p><strong>底层数据结构</strong>： JDK1.7 的 ConcurrentHashMap 底层采用 <code>分段数组+链表</code> 实现，而 JDK1.8 的 ConcurrentHashMap 实现跟 HashMap1.8 的数据结构一样，都是 <code>数组+链表/红黑二叉树</code>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似，都是采用 <code>数组+链表</code> 的形式。数组是 HashMap 的主体，链表则是为了解决哈希冲突而存在的；</p>
</li>
<li><p><strong>实现线程安全的方式</strong>： ① 在 JDK1.7 的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段( Segment )，每一把锁只锁容器其中的一部分数据，这样多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高了并发访问率。 到了 JDK1.8，摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作，（JDK1.6 以后对 synchronized 锁做了很多的优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable (同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。一个线程访问同步方法时，当其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程就不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈，效率就越低</p>
<p>————————————————</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-071322.png" alt="image-20191015151322256"></p>
</li>
</ol>
<hr>
<h1 id="17-lock和synchronized的区别"><a href="#17-lock和synchronized的区别" class="headerlink" title="17  lock和synchronized的区别"></a>17  lock和synchronized的区别</h1><p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-071428.png" alt="image-20191015151428472"></p>
<p>　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，synchronized是在<a href="https://www.baidu.com/s?wd=JVM&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y4Pj7WnW-BuH99PhmkPvPb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHRLPHfznWn4Pjb1PWm4rjT3n0" target="_blank" rel="noopener">JVM</a>层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，<a href="https://www.baidu.com/s?wd=JVM&tn=44039180_cpr&fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y4Pj7WnW-BuH99PhmkPvPb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHRLPHfznWn4Pjb1PWm4rjT3n0" target="_blank" rel="noopener">JVM</a>会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock()放到finally{} 中；</p>
<p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<p>　　3）Lock可以让等待锁的线程响应中断，线程可以中断去干别的事务，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p>
<p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p>
<p>　　5）Lock可以提高多个线程进行读操作的效率。</p>
<p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p>
<hr>
<p>*<em>二、ReentrantLock获取锁定与三种方式：　　*</em></p>
<p>*<em>a) lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁　　*</em></p>
<p>*<em>b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；　　*</em></p>
<p>*<em>c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；　　*</em></p>
<p><strong>d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断</strong></p>
<p><strong>2.ReentrantLock</strong></p>
<p>　　ReentrantLock，意思是“可重入锁”，关于可重入锁的概念在下一节讲述。ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。下面通过一些实例看具体看一下如何使用ReentrantLock。</p>
<h1 id="18-TCP和UDP区别"><a href="#18-TCP和UDP区别" class="headerlink" title="18  TCP和UDP区别"></a>18  TCP和UDP区别</h1><p>  <strong>区别：</strong> </p>
<p>1） TCP是面向连接的，可靠性高；UDP是基于非连接的，可靠性低<br>2） 由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，同时过程复杂，也使其易于攻击；UDP没有建立连接的过程，因而实时性较强，也稍安全<br>3） 在传输相同大小的数据时，TCP首部开销20字节；UDP首部开销8字节，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP在IP协议的基础上添加了序号机制、确认机制、超时重传机制等，保证了传输的可靠性，不会出现丢包或乱序，而UDP有丢包，故TCP开销大，UDP开销较小<br>4） 每条TCP连接只能时点到点的；UDP支持一对一、一对多、多对一、多对多的交互通信</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-072518.png" alt="image-20191015152518189"></p>
<hr>
<ul>
<li>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，是专门为了在不可靠的网络中提供一个可靠的端对端字节流而设计的，面向字节流。</li>
<li>UDP（用户数据报协议）是iso参考模型中一种无连接的传输层协议，提供简单不可靠的非连接传输层服务，面向报文</li>
</ul>
<hr>
<h1 id="19-TCP-UDP-应用场景选择"><a href="#19-TCP-UDP-应用场景选择" class="headerlink" title="19 TCP UDP 应用场景选择"></a>19 TCP UDP 应用场景选择</h1><ul>
<li>对实时性要求高和高速传输的场合下使用UDP;在可靠性要求低，追求效率的情况下使用UDP;</li>
<li>需要传输大量数据且对可靠性要求高的情况下使用TCP</li>
</ul>
<hr>
<h1 id="20-TCP协议如何保证可靠传输"><a href="#20-TCP协议如何保证可靠传输" class="headerlink" title="20 TCP协议如何保证可靠传输"></a>20 TCP协议如何保证可靠传输</h1><p>1、应用数据被分割成TCP认为最适合发送的数据块。<br>2、超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。<br>3、TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。<br>4、校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。<br>5、TCP的 接收端会丢弃重复的数据。<br>6、流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>7、拥塞控制：当网络拥塞时，减少数据的发送。<br>————————————————</p>
<h1 id="21-javaGC"><a href="#21-javaGC" class="headerlink" title="21 javaGC"></a>21 javaGC</h1><p><strong>一、什么是GC：</strong></p>
<p>每个程序员都遇到过内存溢出的情况，程序运行时，内存空间是有限的，那么如何及时的把不再使用的对象清除将内存释放出来，这就是GC要做的事。</p>
<p><strong>1、GC的对象</strong></p>
<p>需要进行回收的对象就是已经没有存活的对象，判断一个对象是否存活常用的有两种办法：引用计数和可达分析。</p>
<p>在Java语言中，GC Roots包括：</p>
<p>虚拟机栈中引用的对象。</p>
<p>方法区中类静态属性实体引用的对象。</p>
<p>方法区中常量引用的对象。</p>
<p>本地方法栈中JNI引用的对象。</p>
<hr>
<p><strong>2、什么时候触发GC</strong></p>
<p>(1)程序调用System.gc时可以触发</p>
<p>(2)系统自身来决定GC触发的时机（根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程）</p>
<p>GC又分为 minor GC 和 Full GC (也称为 Major GC )</p>
<p>Minor GC触发条件：当Eden区满时，触发Minor GC。</p>
<p>Full GC触发条件：</p>
<p>  a.调用System.gc时，系统建议执行Full GC，但是不必然执行</p>
<p>  b.老年代空间不足</p>
<p>  c.方法去空间不足</p>
<p>  d.通过Minor GC后进入老年代的平均大小大于老年代的可用内存</p>
<p>  e.由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</p>
<p><strong>二   GC常用算法</strong></p>
<p>GC常用算法有：<strong>标记-清除算法</strong>，<strong>标记-压缩算法</strong>，<strong>复制算法</strong>，<strong>分代收集算法。</strong></p>
<p>目前主流的JVM（HotSpot）采用的是分代收集算法。</p>
<p><strong>三、垃圾收集器</strong></p>
<p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
<ul>
<li>1.Serial收集器</li>
</ul>
<p>串行收集器是最古老，最稳定以及效率高的收集器<br>可能会产生较长的停顿，只使用一个线程去回收<br>-XX:+UseSerialGC</p>
<p>新生代、老年代使用串行回收<br>新生代复制算法<br>老年代标记-压缩</p>
<ol start="2">
<li>*&amp; 并行收集器</li>
</ol>
<p>2.1 ParNew</p>
<p>-XX:+UseParNewGC（new代表新生代，所以适用于新生代）</p>
<p>新生代并行<br>老年代串行<br>Serial收集器新生代的并行版本<br>在新生代回收时使用复制算法<br>多线程，需要多核支持<br>-XX:ParallelGCThreads 限制线程数量<br>————————————————</p>
<ul>
<li>2.2 Parallel收集器</li>
</ul>
<p>类似ParNew<br>新生代复制算法<br>老年代标记-压缩<br>更加关注吞吐量<br>-XX:+UseParallelGC  </p>
<p>使用Parallel收集器+ 老年代串行<br>-XX:+UseParallelOldGC </p>
<p>使用Parallel收集器+ 老年代并行</p>
<ol start="3">
<li><strong>CMS收集器</strong></li>
</ol>
<p>Concurrent Mark Sweep 并发标记清除（应用程序线程和GC线程交替执行）<br>使用标记-清除算法<br>并发阶段会降低吞吐量（停顿时间减少，吞吐量降低）<br>老年代收集器（新生代使用ParNew）<br>-XX:+UseConcMarkSweepGC<br>CMS运行过程比较复杂，着重实现了标记的过程，可分为</p>
<ol>
<li>初始标记（会产生全局停顿）</li>
</ol>
<p>根可以直接关联到的对象<br>速度快</p>
<ol start="2">
<li>并发标记（和用户线程一起） </li>
</ol>
<p>主要标记过程，标记全部对象</p>
<ol start="3">
<li><p>重新标记 （会产生全局停顿）</p>
</li>
<li><p><strong>. G1收集器</strong></p>
<p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。</p>
<p>与CMS收集器相比G1收集器有以下特点：</p>
<p>(1) 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p>
<p>————————————————</p>
</li>
</ol>
<hr>
<h1 id="22-重载和重写的区别"><a href="#22-重载和重写的区别" class="headerlink" title="22 重载和重写的区别"></a>22 重载和重写的区别</h1><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载 Overload"></a>重载 Overload</h3><p>表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p>
<h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写 Override"></a>重写 Override</h3><p>表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</p>
<hr>
<h1 id="23-排序O-N2-，什么排序O-NlogN-，什么排序稳定，什么排序不稳定"><a href="#23-排序O-N2-，什么排序O-NlogN-，什么排序稳定，什么排序不稳定" class="headerlink" title="23 排序O(N2)，什么排序O(NlogN)，什么排序稳定，什么排序不稳定"></a>23 排序O(N2)，什么排序O(NlogN)，什么排序稳定，什么排序不稳定</h1><p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-073905.png" alt="image-20191015153904887"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-074013.png" alt="image-20191015154012404"></p>
<hr>
<h1 id="24-数据结构中散列表说一下？Hash冲突有什么解决方法？"><a href="#24-数据结构中散列表说一下？Hash冲突有什么解决方法？" class="headerlink" title="24 数据结构中散列表说一下？Hash冲突有什么解决方法？"></a>24 数据结构中散列表说一下？Hash冲突有什么解决方法？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开放定址法:  当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</span><br><span class="line"></span><br><span class="line">再哈希法：   当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚</span><br><span class="line">            集，但是增加计算时间，同时需要准备许多哈希函数。</span><br><span class="line"></span><br><span class="line">链地址法：   将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中</span><br><span class="line"></span><br><span class="line">建立公共溢出区：采用一个溢出表存储产生冲突的关键字。如果公共溢出区还产生冲突，再采用处理冲突方法处理。</span><br></pre></td></tr></table></figure>

<p>散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。</p>
<hr>
<p>散列表（也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<hr>
<h1 id="23-你说get是幂等的，幂等是你怎么理解？"><a href="#23-你说get是幂等的，幂等是你怎么理解？" class="headerlink" title="23 你说get是幂等的，幂等是你怎么理解？"></a>23 你说get是幂等的，幂等是你怎么理解？</h1><p> <strong>幂等</strong>:<br>                        对于同一种行为，如果执行不论多少次，最终的结果都是一致相同的，就称这种行为是幂等的。</p>
<p>​                        (个人理解：不管是一次,还是多次操作，我们返回同样的结果,且不修改状态信息,接口可重复调用)</p>
<p>​            <strong>非幂等</strong>:<br>​                       对于同一种行为，如果最终的结果与执行的次数有关，每次执行后结果都不相同，就称这种行为为非幂等。譬如：累加</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-074459.png" alt="image-20191015154458471"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-074507.png" alt="image-20191015154506375"></p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-10-15-074516.png" alt="image-20191015154516415"></p>
<hr>
<p>#25HashMap的扩容机制—resize()</p>
<p><strong>虽然在hashmap的原理里面有这段，但是这个单独拿出来讲rehash或者resize()也是极好的。</strong></p>
<p><strong>什么时候扩容：</strong>当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值(知道这个阈字怎么念吗？不念fa值，念yu值四声)—即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。</p>
<p><strong>扩容(resize)</strong>就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然<a href="http://lib.csdn.net/base/17" target="_blank" rel="noopener">Java</a>里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<hr>
<h1 id="26-http协议状态码301和302的区别"><a href="#26-http协议状态码301和302的区别" class="headerlink" title="26  http协议状态码301和302的区别"></a>26  http协议状态码301和302的区别</h1><p>301 redirect: 301 代表永久性转移(Permanently Moved)<br>302 redirect: 302 代表暂时性转移(Temporarily Moved )</p>
<p>301：请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p>
<p>302：服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。</p>
<h1 id="27-TIME-WAIT"><a href="#27-TIME-WAIT" class="headerlink" title="27 TIME_WAIT"></a>27 TIME_WAIT</h1><p>  <strong>什么时候会TIME_WAIT</strong></p>
<p>TCP在关闭的时候有个四次挥手的过程，主动关闭方在四次挥手的最后一个ACK发送之后会变成TIME_WAIT状态。</p>
<p>在JDK1.7中ConcurrentHashMap采用了数组+Segment+分段锁的方式实现。</p>
<p>DK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用CAS操作，这里我简要介绍下CAS。</p>
<h1 id="28-抽象类和接口的含义以及区别"><a href="#28-抽象类和接口的含义以及区别" class="headerlink" title="28 抽象类和接口的含义以及区别"></a>28 抽象类和接口的含义以及区别</h1><p><strong>抽象类是什么：</strong></p>
<p>抽象类不能创建实例，它只能作为父类被继承。抽象类是从多个具体类中抽象出来的父类，它具有更高层次的抽象。从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为其子类的模板，从而避免了子类的随意性。</p>
<p>(1) 抽象方法只作声明，而不包含实现，可以看成是没有实现体的虚方法</p>
<p>(2) 抽象类不能被实例化</p>
<p>(3) 抽象类可以但不是必须有抽象属性和抽象方法，但是一旦有了抽象方法，就一定要把这个类声明为抽象类</p>
<p>(4) 具体派生类必须覆盖基类的抽象方法</p>
<p>(5) 抽象派生类可以覆盖基类的抽象方法，也可以不覆盖。如果不覆盖，则其具体派生类必须覆盖它们</p>
<p><strong>接口是什么：</strong></p>
<p>(1) 接口不能被实例化</p>
<p>(2) 接口只能包含方法声明</p>
<p>(3) 接口的成员包括方法、属性、索引器、事件</p>
<p>(4) 接口中不能包含常量、字段(域)、构造函数、析构函数、静态成员</p>
<p><strong>接口和抽象类的区别：</strong></p>
<p>（1）抽象类可以有构造方法，接口中不能有构造方法。</p>
<p>（2）抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
<p>（3）抽象类中可以包含静态方法，接口中不能包含静态方法</p>
<p>（4） 一个类可以实现多个接口，但只能继承一个抽象类。</p>
<p>（5）接口可以被多重实现，抽象类只能被单一继承</p>
<p>（6）如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法</p>
<h1 id="29-怎么优化sql"><a href="#29-怎么优化sql" class="headerlink" title="29  怎么优化sql"></a>29  怎么优化sql</h1><p>1.1 查看SQL执行频率</p>
<p>1.2 定位执行效率比较低的SQL语句</p>
<p>1.3 通过EXPLAIN分析慢SQL</p>
<p>1.4 通过show profile分析SQL</p>
<figure class="highlight plain"><figcaption><span>a</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。    </span><br><span class="line">    </span><br><span class="line">2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：    </span><br><span class="line">select id from t where num is null    </span><br><span class="line">可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：    </span><br><span class="line">select id from t where num=0    </span><br><span class="line">    </span><br><span class="line">3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。    </span><br><span class="line">    </span><br><span class="line">4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：    </span><br><span class="line">select id from t where num=10 or num=20    </span><br><span class="line">可以这样查询：    </span><br><span class="line">select id from t where num=10    </span><br><span class="line">union all    </span><br><span class="line">select id from t where num=20    </span><br><span class="line">    </span><br><span class="line">5.in 和 not in 也要慎用，否则会导致全表扫描，如：    </span><br><span class="line">select id from t where num in(1,2,3)    </span><br><span class="line">对于连续的数值，能用 between 就不要用 in 了：    </span><br><span class="line">select id from t where num between 1 and 3    </span><br><span class="line">    </span><br><span class="line">6.下面的查询也将导致全表扫描：    </span><br><span class="line">select id from t where name like &apos;%abc%&apos;    </span><br><span class="line">    </span><br><span class="line">7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：    </span><br><span class="line">select id from t where num/2=100    </span><br><span class="line">应改为:    </span><br><span class="line">select id from t where num=100*2    </span><br><span class="line">    </span><br><span class="line">8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：    </span><br><span class="line">select id from t where substring(name,1,3)=&apos;abc&apos;--name以abc开头的id    </span><br><span class="line">应改为:    </span><br><span class="line">select id from t where name like &apos;abc%&apos;    </span><br><span class="line">    </span><br><span class="line">9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。    </span><br><span class="line">    </span><br><span class="line">10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，    </span><br><span class="line">否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。    </span><br><span class="line">    </span><br><span class="line">11.不要写一些没有意义的查询，如需要生成一个空表结构：    </span><br><span class="line">select col1,col2 into #t from t where 1=0    </span><br><span class="line">这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：    </span><br><span class="line">create table #t(...)    </span><br><span class="line">    </span><br><span class="line">12.很多时候用 exists 代替 in 是一个好的选择：    </span><br><span class="line">select num from a where num in(select num from b)    </span><br><span class="line">用下面的语句替换：    </span><br><span class="line">select num from a where exists(select 1 from b where num=a.num)    </span><br><span class="line">    </span><br><span class="line">13.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，    </span><br><span class="line">如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。    </span><br><span class="line">    </span><br><span class="line">14.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，    </span><br><span class="line">因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。    </span><br><span class="line">一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。    </span><br><span class="line">    </span><br><span class="line">15.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。    </span><br><span class="line">这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。    </span><br><span class="line">    </span><br><span class="line">16.尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，    </span><br><span class="line">其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。    </span><br><span class="line">    </span><br><span class="line">17.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。    </span><br><span class="line">    </span><br><span class="line">18.避免频繁创建和删除临时表，以减少系统表资源的消耗。</span><br><span class="line"></span><br><span class="line">19.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。    </span><br><span class="line">    </span><br><span class="line">20.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，    </span><br><span class="line">以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</span><br></pre></td></tr></table></figure>

<hr>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/10/14/面试总结/">http://yoursite.com/2019/10/14/面试总结/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/面试/"># 面试</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2019/10/14/数据结构算法/数据结构与算法 总结笔记/6 排序算法/归并排序/"></a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
