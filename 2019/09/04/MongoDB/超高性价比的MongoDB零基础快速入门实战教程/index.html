<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>超高性价比的 MongoDB 快速入门教程 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ferrymana&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ferrymana&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">超高性价比的 MongoDB 快速入门教程</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 4, 2019&nbsp;&nbsp;19:58:54</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/MongoDB/">MongoDB</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="超高性价比的-MongoDB-快速入门教程"><a href="#超高性价比的-MongoDB-快速入门教程" class="headerlink" title="超高性价比的 MongoDB 快速入门教程"></a>超高性价比的 MongoDB 快速入门教程</h1><p>在上一篇 《<a href="https://gitbook.cn/gitchat/activity/5d426151f2d9120aaf32fb9b" target="_blank" rel="noopener">MongoDB 实战教程：数据库与集合的 CRUD<br>操作篇</a>》<br>中，我们学习了MongoDB 与 NoSQL 的关系、 MongoDB<br>的安装、数据类型、MongoShell、创建数据库、显式创建集合和隐式创建集合，还学习了如何更改集合名称以及删除数据库和集合的方法，并对每种操作都进行了实例演示。</p>
<p>在本篇 chat 中我们将学习流式聚合操作，并深入了解语句的执行效率。然后深入学习能够提高数据服务可用性的复制集。接着了解 MongoDB<br>的水平扩展能力，学习 MongoDB 数据的备份与还原方法，并为数据服务开启访问控制。</p>
<h2 id="基础篇-一-文档的-CRUD-操作"><a href="#基础篇-一-文档的-CRUD-操作" class="headerlink" title="基础篇 一 文档的 CRUD 操作"></a>基础篇 一 文档的 CRUD 操作</h2><p>CRUD 操作指的是对文档进行 <code>create</code>，<code>read</code>，<code>update</code> and <code>delete</code> 操作，即增删改查。文档 CRUD<br>操作的内容将分为 <code>Create Operations</code>, <code>Read Operations</code>, <code>Update Operations</code>, <code>Delete
Operations</code> 和 <code>Cursor</code> 等 5 个部分进行介绍。</p>
<h3 id="Create-Operations"><a href="#Create-Operations" class="headerlink" title="Create Operations"></a>Create Operations</h3><p>创建操作或者插入操作会向集合添加新的文档。之前有提到过，如果插入时集合不存在，插入操作会创建对应的集合。MongoDB 提供了 3 个插入文档的方法：</p>
<ul>
<li><a href="http://www.mongoing.com/docs/reference/method/db.collection.insert.html#db.collection.insert" target="_blank" rel="noopener"><code>db.collection.insert()</code></a></li>
<li><a href="http://www.mongoing.com/docs/reference/method/db.collection.insertOne.html#db.collection.insertOne" target="_blank" rel="noopener"><code>db.collection.insertOne()</code></a></li>
<li><a href="http://www.mongoing.com/docs/reference/method/db.collection.insertMany.html#db.collection.insertMany" target="_blank" rel="noopener"><code>db.collection.insertMany()</code></a></li>
</ul>
<h4 id="插入单个文档"><a href="#插入单个文档" class="headerlink" title="插入单个文档"></a>插入单个文档</h4><p>其中，<code>db.collection.insertOne()</code> 用于向集合插入单个文档。而 <code>db.collection.insertMany()</code> 和<br><code>db.collection.insert()</code> 可以向集合插入多个文档。<code>db.collection.insertOne()</code> 示例如下：</p>
<p>​<br>    &gt; db.zenrust.insertOne({<br>    … nickname: “Rust 之禅”,<br>    … name: “zenrust”,<br>    … types: “订阅号”,<br>    … descs:”超酷人生，我用 Rust”<br>    … })</p>
<p>自动命令执行后会返回一个结果文档，文档输出如下：</p>
<p>​<br>    {<br>        “acknowledged” : true,<br>        “insertedId” : ObjectId(“5d157fe26fcb85935e9cb786”)<br>    }</p>
<p>这说明文档插入成功。其中，<code>acknowledged</code> 代表本次操作的操作状态，状态值包括 <code>true</code> 和 <code>false</code>。<code>insertedId</code><br>即该文档的 <code>_id</code>。</p>
<blockquote>
<p>提示：示例中的省略号是 MongoShell<br>的换行标识符。换行标识符对命令输入和执行并没有影响，所以本文也不会注重风格的统一，即示例中有时会带有换行符，有时则不带有换行符。</p>
</blockquote>
<h4 id="插入多个文档"><a href="#插入多个文档" class="headerlink" title="插入多个文档"></a>插入多个文档</h4><p><code>db.collection.insertMany()</code> 示例如下：</p>
<p>​<br>    &gt; db.zenrust.insertMany([<br>    … {nickname: “Rust 之禅”, name: “zenrust”, types: “订阅号”, descs: “超酷人生，我用 Rust”},<br>    … {nickname: “进击的 Coder”, name: “FightingCoder”, types: “订阅号”, descs: “分享爬虫技术和机器学习方面的编程经验”}<br>    … ])</p>
<p>由于本次插入了 2 个文档，所以返回的结果文档会显示两个 <code>_id</code>。返回文档内容如下：</p>
<p>​<br>    {<br>        “acknowledged” : true,<br>        “insertedIds” : [<br>            ObjectId(“5d1582136fcb85935e9cb787”),<br>            ObjectId(“5d1582136fcb85935e9cb788”)<br>        ]<br>    }</p>
<p><code>db.collection.insert()</code> 示例如下：</p>
<p>​<br>    &gt; db.zenrust.insert({title: “全面认识 RUST，掌控未来的雷电”})</p>
<p>示例演示的是单个文档的插入，实际上插入多个文档也是没问题的。<code>db.collection.insert()</code> 插入单个文档时返回的是一个带有操作状态的<br><code>WriteResult</code> 对象：<code>WriteResult({ &quot;nInserted&quot; : 1 })</code> 。其中，<code>nInserted</code><br>表明了插入文档的总数。但如果插入操作遇到错误，那么 <code>WriteResult</code> 对象将包含错误提示信息。</p>
<p><code>db.collection.insert()</code> 插入多个文档的示例如下：</p>
<p>​<br>    &gt; db.zenrust.insert([{nickname: “进击的 Coder”}, {nickname: “Rust 之禅”}])<br>    BulkWriteResult({<br>        “writeErrors” : [ ],<br>        “writeConcernErrors” : [ ],<br>        “nInserted” : 2,<br>        “nUpserted” : 0,<br>        “nMatched” : 0,<br>        “nModified” : 0,<br>        “nRemoved” : 0,<br>        “upserted” : [ ]<br>    })</p>
<p>可以看到，<code>db.collection.insert()</code> 插入多个文档和插入单个文档得到的返回结果是不同的。</p>
<h3 id="Read-Operations"><a href="#Read-Operations" class="headerlink" title="Read Operations"></a>Read Operations</h3><p>MongoDB 提供了 <code>db.collection.find()</code> 方法从集合中读取文档。在开始练习之前，需要准备用于练习的基础数据。在<br>MongoShell 中执行以下文档插入操作：</p>
<p>​<br>    &gt; db.inven.insertMany([<br>       { name: “詹姆斯”, number: 6, attribute: { h: 203, w: 222, p: “前锋” }, status: “A” },<br>       { name: “韦德”, number: 3, attribute: { h: 193, w: 220, p: “得分后卫” }, status: “R” },<br>       { name: “科比”, number: 24, attribute: { h: 198, w: 212, p: “得分后卫” }, status: “R” },<br>       { name: “姚明”, number: 11, attribute: { h: 226, w: 308, p: “中锋” }, status: “R” },<br>       { name: “乔丹”, number: 23, attribute: { h: 198, w: 216, p: “得分后卫” }, status: “R” }<br>    ])</p>
<h4 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h4><p>将一个空位当作为查询过滤器参数传递给 <code>db.collection.find()</code> 方法就可以得到所有文档，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({})</p>
<p>或者什么都不传，直接使用 <code>find()</code>，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find()</p>
<p>这等效于 SQL 中的 <code>SELECT * FROM inven</code>。</p>
<h4 id="指定等式条件"><a href="#指定等式条件" class="headerlink" title="指定等式条件"></a>指定等式条件</h4><p>如果要指定相等条件，可以使用 <code>{&lt;field1&gt;: &lt;value1&gt;, ...}</code> 这样的过滤表达式，例如过滤出已退役球员（”R”<br>代表退役）的查询语句如下：</p>
<p>​<br>    &gt; db.inven.find({status: “R”})<br>    { “_id” : ObjectId(“5d159e794d3d891430a2512e”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a2512f”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25130”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25131”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p>这等效于 SQL 中的 <code>SELECT * FROM inven WHERE status = &quot;R&quot;</code>。</p>
<h4 id="根据嵌套文档字段查询"><a href="#根据嵌套文档字段查询" class="headerlink" title="根据嵌套文档字段查询"></a>根据嵌套文档字段查询</h4><p>我们还可以根据嵌入式文档中的字段进行查询，例如过滤出球员属性中身高为 <code>193</code> 的球员，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({“attribute.h”: 193})<br>    { “_id” : ObjectId(“5d159e794d3d891430a2512e”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }</p>
<p>要注意的是，访问嵌入式文档中的字段时使用的并不是 <code>attribute.h</code>，而是使用 <code>&quot;attribute.h&quot;</code>。</p>
<h4 id="查询与投影操作"><a href="#查询与投影操作" class="headerlink" title="查询与投影操作"></a>查询与投影操作</h4><p>查询的情况非常复杂，MongoDB 提供了多种查询操作符来应对这些问题。MongoDB 提供的查询操作符分为以下几类：</p>
<ul>
<li>比较查询操作符</li>
<li>逻辑查询操作符</li>
<li>元素查询操作符</li>
<li>评估查询操作符</li>
<li>地理空间查询操作符</li>
<li>数组查询操作符</li>
<li>按位查询操作符</li>
</ul>
<p>接下来，我们将学习每一种查询操作符的规则和语法。</p>
<h5 id="比较查询操作符"><a href="#比较查询操作符" class="headerlink" title="比较查询操作符"></a>比较查询操作符</h5><p>比较是最常见的操作之一，它分为同类型比较和非同类型比较。在面对不同的 BSON 类型值时，比较的并不是值的大小，而是值的类型，即按类比较。MongoDB<br>使用以下比较顺序，顺序从低到高：</p>
<ul>
<li>MinKey (internal type)</li>
<li>Null</li>
<li>Numbers (ints, longs, doubles, decimals)</li>
<li>Symbol, String</li>
<li>Object</li>
<li>Array</li>
<li>BinData</li>
<li>ObjectId</li>
<li>Boolean</li>
<li>Date</li>
<li>Timestamp</li>
<li>Regular Expression</li>
<li>MaxKey (internal type)</li>
</ul>
<p>同类型比较的情况则稍微复杂一些。数字类型比较的是值的大小，例如 <code>5</code> 大于 <code>3</code>。字符串类型比较的是其值的二进制，例如 <code>R</code> 大于 <code>A</code> 是因为<br><code>R</code> 的二进制值 <code>0101 0010</code> 大于 <code>A</code> 的二进制值 <code>0100
0001</code>。数组的小于比较或者升序排序比较的是数组中的最小元素，大于比较或降序排序比较的是数组中的最大元素。我们可以通过一个例子来了解这些知识。准备如下数据：</p>
<p>​<br>    &gt; db.arrs.insertMany([<br>    … {name: “James”, attr: [5, 6, 7]},<br>    … {name: “Wade”, attr: [1, 7, 8]},<br>    … {name: “Kobe”, attr: [1, 9, 9]},<br>    … {name: “Bosh”, attr: [2, 9, 9]}<br>    … ])</p>
<p>假设要将文档按 <code>name</code> 升序排序，即字符串升序排序。对应示例如下：</p>
<p>​<br>    &gt; db.arrs.find().sort({name: 1})<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4f”), “name” : “Bosh”, “attr” : [ 2, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4c”), “name” : “James”, “attr” : [ 5, 6, 7 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4e”), “name” : “Kobe”, “attr” : [ 1, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4d”), “name” : “Wade”, “attr” : [ 1, 7, 8 ] }</p>
<p>排序结果为 <code>Bosh- James - Kobe - Wade</code>，那么字符串降序排序的结果一定是 <code>Wade - Kobe - James -
Bosh</code>。对应示例如下：</p>
<p>​<br>    &gt; db.arrs.find().sort({name: -1})<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4d”), “name” : “Wade”, “attr” : [ 1, 7, 8 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4e”), “name” : “Kobe”, “attr” : [ 1, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4c”), “name” : “James”, “attr” : [ 5, 6, 7 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4f”), “name” : “Bosh”, “attr” : [ 2, 9, 9 ] }</p>
<p>现有：<code>[ 5, 6, 7 ], [ 1, 7, 8 ], [ 1, 9, 9 ], [ 2, 9, 9 ]</code> 4<br>个数组，上面提到，数组升序排序比较的是最小元素。4 个数组中最小的值分别是 <code>5, 1, 1, 2</code>，其中数组 <code>[1, 7, 8]</code> 和数组 <code>[1,
9, 9]</code> 的最小值相同，则比较第二小的值，即 <code>7, 9</code>。那么正确的升序排序结果因该是 <code>[ 1, 7, 8 ], [ 1, 9, 9 ], [ 2,
9, 9 ], [5, 6, 7]</code>。数组升序排序命令如下：</p>
<p>​<br>    &gt; db.arrs.find().sort({attr: 1})<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4d”), “name” : “Wade”, “attr” : [ 1, 7, 8 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4e”), “name” : “Kobe”, “attr” : [ 1, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4f”), “name” : “Bosh”, “attr” : [ 2, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1eb7fef91d329d7e731d4c”), “name” : “James”, “attr” : [ 5, 6, 7 ] }</p>
<p>排序结果与分析结果一致。数组降序排序比较的是最大元素。4 个数组中最大的值分别是 <code>7, 8, 9, 9</code>，其中数组 <code>[1, 9, 9]</code> 和 <code>[2,
9, 9]</code> 的最大值和第二大的值相同，则比较第三大的值，即 <code>1, 2</code>。那么正确的降序排序结果应该是 <code>[2, 9, 9], [1, 9, 9],
[1, 7, 8], [5, 6, 7]</code>。数组降序排序命令如下：</p>
<p>​<br>    &gt; db.els.find().sort({attr: -1})<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df74fff”), “name” : “Kobe”, “attr” : [ 1, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df75000”), “name” : “Bosh”, “attr” : [ 2, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df74ffe”), “name” : “Wade”, “attr” : [ 1, 7, 8 ] }<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df74ffd”), “name” : “James”, “attr” : [ 5, 6, 7 ] }</p>
<p>排序结果和分析结果并不同，这是为什么呢？难道不是按最大元素比较大小吗？</p>
<p>文档中并没有提到，但我们可以通过例子寻找答案。准备以下数据：</p>
<p>​<br>    &gt; db.parts.insertMany([<br>    … {name: 1, attr: [9, 9, 0, 5]},<br>    … {name: 2, attr: [9, 9, 0, 1]},<br>    … {name: 3, attr: [9, 0, 9, 0]},<br>    … {name: 4, attr: [9, 8, 7, 6]},<br>    … {name: 5, attr: [5, 2, 3, 6]},<br>    … {name: 6, attr: [9, 0, 0, 0]},<br>    … {name: 7, attr: [30, 0]},<br>    … {name: 8, attr: [22, 0]},<br>    … {name: 9, attr: [30, 5]},<br>    … {name: 10, attr: [30, 3]}<br>    … ])</p>
<p>数组降序排序示例如下：</p>
<p>​<br>    &gt; db.parts.find().sort({attr: -1})<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb121”), “name” : 7, “attr” : [ 30, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb123”), “name” : 9, “attr” : [ 30, 5 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb124”), “name” : 10, “attr” : [ 30, 3 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb122”), “name” : 8, “attr” : [ 22, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11b”), “name” : 1, “attr” : [ 9, 9, 0, 5 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11c”), “name” : 2, “attr” : [ 9, 9, 0, 1 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11d”), “name” : 3, “attr” : [ 9, 0, 9, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11e”), “name” : 4, “attr” : [ 9, 8, 7, 6 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb120”), “name” : 6, “attr” : [ 9, 0, 0, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11f”), “name” : 5, “attr” : [ 5, 2, 3, 6 ] }</p>
<p>数组升序排序示例如下：</p>
<p>​<br>    &gt; db.parts.find().sort({attr: 1})<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11b”), “name” : 1, “attr” : [ 9, 9, 0, 5 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11c”), “name” : 2, “attr” : [ 9, 9, 0, 1 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11d”), “name” : 3, “attr” : [ 9, 0, 9, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb120”), “name” : 6, “attr” : [ 9, 0, 0, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb121”), “name” : 7, “attr” : [ 30, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb122”), “name” : 8, “attr” : [ 22, 0 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11f”), “name” : 5, “attr” : [ 5, 2, 3, 6 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb124”), “name” : 10, “attr” : [ 30, 3 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb123”), “name” : 9, “attr” : [ 30, 5 ] }<br>    { “_id” : ObjectId(“5d1eef27882bacc4ec4cb11e”), “name” : 4, “attr” : [ 9, 8, 7, 6 ] }</p>
<p>根据以上结果，我们可以推测出排序规律： <strong>如果被比较的值相同，那么就按照插入顺序（即 ObjectId）排序</strong> 。降序排序比较的是最大元素，即 `30</p>
<ul>
<li><p>30 - 30 - 22 -9 - 9 - 9 - 9 - 9 - 6<code>，其中</code>30<code>和</code>9` 均有重复。可以发现：</p>
<ul>
<li>第一个 <code>30</code> 对应的 <code>name</code> 值为 <code>7</code>，第二个 <code>30</code> 对应的 <code>name</code> 值为 <code>9</code>，第三个 <code>30</code> 对应的 <code>name</code> 值为 <code>10</code>；</li>
<li>第一个 <code>9</code> 对应的 <code>name</code> 值为 <code>1</code>，第二个 <code>9</code> 对应的 <code>name</code> 值为 <code>2</code>，第三个 <code>9</code> 对应的 <code>name</code> 值为 <code>3</code>，第四个 <code>9</code> 对应的 <code>name</code> 值为 <code>4</code>，第五个 <code>9</code> 对应的 <code>name</code> 值为 <code>6</code>；</li>
</ul>
</li>
</ul>
<p>升序排序比较的是最小元素，即 <code>0 - 0 - 0 - 0 - 0 - 0 - 2 - 3 - 5 - 6</code>，其中重复的只有 <code>0</code>。<code>0</code> 对应的<br><code>name</code> 值依次为 <code>1, 2, 3, 6, 7, 8</code><br>。无论是升序排序还是降序排序，实际得到的结果与我们推测出来的规律相同，这说明我们推测出来的规律是正确的。其他类型的比较或排序规则可查阅官方文档<br>[comparison-sort-order](<a href="https://docs.mongodb.com/manual/reference/bson-type-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/bson-type-</a><br>comparison-order/#comparison-sort-order) 。</p>
<p>MongoDB 提供了一系列用于比较的比较符，它们分别是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/eq/#op._S_eq" target="_blank" rel="noopener"><code>$eq</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配等于指定值的值</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/gt/#op._S_gt" target="_blank" rel="noopener"><code>$gt</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配大于指定值的值</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/gte/#op._S_gte" target="_blank" rel="noopener"><code>$gte</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配大于或等于指定值的值</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/in/#op._S_in" target="_blank" rel="noopener"><code>$in</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配数组中指定的任何值</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/lt/#op._S_lt" target="_blank" rel="noopener"><code>$lt</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配小于指定值的值</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/lte/#op._S_lte" target="_blank" rel="noopener"><code>$lte</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配小于或等于指定值的值</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/ne/#op._S_ne" target="_blank" rel="noopener"><code>$ne</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配所有不等于指定值的值</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/nin/#op._S_nin" target="_blank" rel="noopener"><code>$nin</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>不匹配数组中指定的任何值</td>
</tr>
</tbody></table>
<p>其中，<code>$eq</code>， <code>$gte</code>， <code>$lt</code>， <code>$lte</code>， <code>$gt</code>，<code>$ne</code> 的语法是相同的。以 <code>$eq</code> 为例，其语法格式如下：</p>
<p>​<br>    { <field>: { $eq: <value> } }</value></field></p>
<p>假设要匹配集合 <code>els</code> 中名称为 <code>James</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.els.find({name: {$eq: “James”}})<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df74ffd”), “name” : “James”, “attr” : [ 5, 6, 7 ] }</p>
<p>这等效于 SQL 中的 <code>SELECT * FROM els WHERE name = &quot;James&quot;</code>。</p>
<p><code>$in</code> 和 <code>$nin</code> 的语法相同。以 <code>$in</code> 为例，其格式如下：</p>
<p>​<br>    { field: { $in: [<value1>, <value2>, … <valuen> ] } }</valuen></value2></value1></p>
<p>假设要过滤出集合 <code>els</code> 中文档字段 <code>attr</code> 中包含 <code>6</code> 或者 <code>9</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.els.find({attr: {$in: [6, 9]}})<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df74ffd”), “name” : “James”, “attr” : [ 5, 6, 7 ] }<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df74fff”), “name” : “Kobe”, “attr” : [ 1, 9, 9 ] }<br>    { “_id” : ObjectId(“5d1edd28eb81ddef9df75000”), “name” : “Bosh”, “attr” : [ 2, 9, 9 ] }</p>
<p>另外，<code>$in</code> 和 <code>$nin</code> 均支持正则表达式。例如要过滤出集合 <code>inven</code> 中 <code>name</code> 字段值以 <code>詹</code> 或者 <code>韦</code><br>开头的文档，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({name: {$in: [/^詹/, /^韦/]}})<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af2”), “name” : “詹姆斯”, “number” : 6, “attribute” : { “h” : 203, “w” : 222, “p” : “前锋” }, “status” : “A” }<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af3”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }</p>
<p>反过来，过滤出集合 <code>inven</code> 中 <code>name</code> 字段值非 <code>詹</code> 或者非 <code>韦</code> 开头的文档。对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({name: {$nin: [/^詹/, /^韦/]}})<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af4”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af5”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af6”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p>以上就是比较查询操作符的相关知识，更多关于比较查询操作符的知识可查阅官方文档 [Comparison Query<br>Operators](<a href="https://docs.mongodb.com/manual/reference/operator/query-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query-</a><br>comparison/#comparison-query-operators)。</p>
<h5 id="逻辑查询操作符"><a href="#逻辑查询操作符" class="headerlink" title="逻辑查询操作符"></a>逻辑查询操作符</h5><p>MongoDB 中的逻辑查询操作符共有 4 种，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/and/#op._S_and" target="_blank" rel="noopener"><code>$and</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配符合多个条件的文档</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/not/#op._S_not" target="_blank" rel="noopener"><code>$not</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配不符合条件的文档</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/nor/#op._S_nor" target="_blank" rel="noopener"><code>$nor</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配不符合多个条件的文档</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/or/#op._S_or" target="_blank" rel="noopener"><code>$or</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配符合任一条件的文档</td>
</tr>
</tbody></table>
<p>其中，<code>$and</code>， <code>$nor</code> 和 <code>$or</code> 语法格式相同：</p>
<p>​<br>    { $keyword: [ { <expression1> }, { <expression2> } , … , { <expressionn> } ] }</expressionn></expression2></expression1></p>
<p>语法中的 <code>keyword</code> 代表 <code>and/nor/or</code>。而 <code>$not</code> 语法格式如下</p>
<p>​<br>    { field: { $not: { <operator-expression> } } }</operator-expression></p>
<p><code>$and</code> 是隐式的，这意味着我们不必在查询语句中表明 <code>and</code> 或 <code>AND</code> 。 假设要过滤出集合 <code>inven</code> 中 <code>球衣号大于 10</code> 的<br><code>退役球员</code>，此时有两个条件：<code>球衣号大于 10</code>，<code>退役球员</code>。对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({status: “R”, number: {$gt: 10}})<br>    { “_id” : ObjectId(“5d159e794d3d891430a2512f”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25130”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25131”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p>这等效于 SQL 中的 <code>SELECT * FROM inven WHERE status = &quot;R&quot; AND number &gt;
10</code>。当然，也可以采用显式写法，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({$and: [{status: “R”}, {number: {$gt: 10}}]})<br>    { “_id” : ObjectId(“5d159e794d3d891430a2512f”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25130”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25131”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p><code>$or</code>， <code>$not</code>，<code>$nor</code> 均采用显式写法。假设要过滤出集合 <code>inven</code> 中 <code>球衣号大于 10</code> 或者 <code>退役球员</code><br>的文档，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({$or: [{status: “R”}, {number: {$gt: 10}}]})<br>    { “_id” : ObjectId(“5d159e794d3d891430a2512e”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a2512f”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25130”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d159e794d3d891430a25131”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p>这等效于 SQL 中的 <code>SELECT * FROM inven WHERE status = &quot;R&quot; OR number &gt; 10</code>。</p>
<p>假设要过滤出集合 <code>inven</code> 中 <code>number</code> 不等于 <code>11</code> 且 <code>number</code> 不等于 <code>23</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({$nor: [{number: 23}, {number: 11}]})<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af2”), “name” : “詹姆斯”, “number” : 6, “attribute” : { “h” : 203, “w” : 222, “p” : “前锋” }, “status” : “A” }<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af3”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af4”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }</p>
<p>假设要过滤出集合 <code>inven</code> 中 <code>number</code> 不大于 <code>20</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({number: {$not: {$gt: 20}}})<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af2”), “name” : “詹姆斯”, “number” : 6, “attribute” : { “h” : 203, “w” : 222, “p” : “前锋” }, “status” : “A” }<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af3”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d200b986c39176e3a421af5”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }</p>
<p>这个例子将比较查询操作符和逻辑查询操作符结合使用，实现了更细致的查询。</p>
<p>更多关于逻辑查询操作符的知识可查阅官方文档 [Logical Query<br>Operators](<a href="https://docs.mongodb.com/manual/reference/operator/query-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query-</a><br>logical/#logical-query-operators)。</p>
<h5 id="元素查询操作符"><a href="#元素查询操作符" class="headerlink" title="元素查询操作符"></a>元素查询操作符</h5><p>MongoDB 中的元素查询操作符只有 2 种，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/exists/#op._S_exists" target="_blank" rel="noopener"><code>$exists</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配具有指定字段的文档</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/type/#op._S_type" target="_blank" rel="noopener"><code>$type</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配字段值符合类型的文档</td>
</tr>
</tbody></table>
<p><strong>exists</strong></p>
<p>在开始学习 <code>$exists</code> 前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.elem.insertMany([<br>    … {title: “湖人今夏交易频繁”, author: “Asyncins”, date: “2019-07-01”, article: “…”},<br>    … {title: “詹姆斯现身 MIA-CHN 比赛现场”, date: “2019-07-06”, article: “…”},<br>    … {title: “伦纳德迟迟不肯表态”, author: “Asyncins”}<br>    … ])</p>
<p><code>$exists</code> 语法格式如下：</p>
<p>​<br>    { field: { $exists: <boolean> } }</boolean></p>
<p>假设要过滤出集合 <code>elem</code> 中包含 <code>author</code> 字段的文档，对应示例如下：</p>
<p>​<br>    &gt; db.elem.find({author: {$exists: true}})<br>    { “_id” : ObjectId(“5d203f1a6c39176e3a421af7”), “title” : “湖人今夏交易频繁”, “author” : “Asyncins”, “date” : “2019-07-01”, “article” : “…” }<br>    { “_id” : ObjectId(“5d203f1a6c39176e3a421af9”), “title” : “伦纳德迟迟不肯表态”, “author” : “Asyncins” }</p>
<p>反过来，要过滤出集合 <code>elem</code> 中不包含 <code>author</code> 字段的文档，对应示例如下：</p>
<p>​<br>    &gt; db.elem.find({author: {$exists: false}})<br>    { “_id” : ObjectId(“5d203f1a6c39176e3a421af8”), “title” : “詹姆斯现身 MIA-CHN 比赛现场”, “date” : “2019-07-06”, “article” : “…” }</p>
<p><strong>type</strong></p>
<p>在开始学习 <code>$type</code> 前，我们需要准备如下数据：</p>
<p>​<br>    &gt; db.ops.insertMany([<br>    …     {title: “北京高温持续，注意避暑”, weight: 5, rec: false},<br>    …     {title: “广西持续降雨，最大降雨量 200 ml”, weight: 5, rec: false},<br>    …     {title: “高考分数线已出，高分学子增多”, weight: “hot”, rec: true},<br>    …     {title: “秋老虎是真是假？”, weight: 3, rec: false}<br>    … ])</p>
<p><code>$type</code> 语法如下：</p>
<p>​<br>    { field: { $type: <bson type> } }</bson></p>
<p>它也支持阵列写法：</p>
<p>​<br>    { field: { $type: [ <bson type1> , <bson type2>, … ] } }</bson></bson></p>
<p>假设要过滤出 <code>weight</code> 值类型为 <code>String</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.ops.find({weight: {$type: “string”}})<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b7”), “title” : “高考分数线已出，高分学子增多”, “weight” : “hot”, “rec” : true }</p>
<p>同理，过滤出 <code>weight</code> 值类型为 <code>Number</code> 的文档的对应示例如下：</p>
<p>​<br>    &gt; db.ops.find({weight: {$type: “number”}})<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b5”), “title” : “北京高温持续，注意避暑”, “weight” : 5, “rec” : false }<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b6”), “title” : “广西持续降雨，最大降雨量 200 ml”, “weight” : 5, “rec” : false }<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b8”), “title” : “秋老虎是真是假？”, “weight” : 3, “rec” : false }</p>
<p>阵列写法中的 BSON 类型为 <code>or</code> 关系，例如要过滤出 <code>weight</code> 值类型为 <code>String</code> 或者 <code>Number</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.ops.find({weight: {$type: [“string”, “number”]}})<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b5”), “title” : “北京高温持续，注意避暑”, “weight” : 5, “rec” : false }<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b6”), “title” : “广西持续降雨，最大降雨量 200 ml”, “weight” : 5, “rec” : false }<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b7”), “title” : “高考分数线已出，高分学子增多”, “weight” : “hot”, “rec” : true }<br>    { “_id” : ObjectId(“5d1838eb51b88758035de5b8”), “title” : “秋老虎是真是假？”, “weight” : 3, “rec” : false }</p>
<p>这等效于 <code>SELECT * FROM ops WHERE weight.type = string OR weight.type = number</code><br>这样的 SQL 伪代码表示。要注意的是，<code>$type</code> 支持所有 BSON 类型的字符串标识符和整数标识符，例如 <code>String</code> 类型的字符串标识符<br><code>sting</code> 及其整数标识符 <code>2</code>，即 <code>{$type: &quot;string&quot;}</code> 等效于 <code>{$type: 2}</code>。</p>
<p>更多关于元素查询操作符的知识可查阅官方文档 [Element Query<br>Operators](<a href="https://docs.mongodb.com/manual/reference/operator/query-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query-</a><br>element/#element-query-operators)。</p>
<h5 id="评估查询操作符"><a href="#评估查询操作符" class="headerlink" title="评估查询操作符"></a>评估查询操作符</h5><p>MongoDB 中的评估查询操作符共有 6 种，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/expr/#op._S_expr" target="_blank" rel="noopener"><code>$expr</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>允许在查询语句中使用聚合表达式</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/#op._S_jsonSchema" target="_blank" rel="noopener"><code>$jsonSchema</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>根据给定的 JSON 模式验证文档</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/mod/#op._S_mod" target="_blank" rel="noopener"><code>$mod</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>对字段的值执行模运算，并选择具有指定结果的文档</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/regex/#op._S_regex" target="_blank" rel="noopener"><code>$regex</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配与正则表达式规则相符的文档</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/text/#op._S_text" target="_blank" rel="noopener"><code>$text</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>执行文本搜索</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/where/#op._S_where" target="_blank" rel="noopener"><code>$where</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配满足 JavaScript 表达式的文档</td>
</tr>
</tbody></table>
<p><strong>expr</strong></p>
<p>在学习 <code>$expr</code> 前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.acbook.insertMany([<br>    … {_id: 1, category: “衣”, 预算: 300, 开支: 600},<br>    … {_id: 2, category: “食”, 预算: 1000, 开支: 600},<br>    … {_id: 3, category: “住”, 预算: 800, 开支: 800},<br>    … {_id: 4, category: “行”, 预算: 220, 开支: 360},<br>    … {_id: 5, category: “医”, 预算: 200, 开支: -50}<br>    … ])</p>
<p><code>$expr</code> 语法格式如下：</p>
<p>​<br>    { $expr: { <expression> } }</expression></p>
<p>假设要过滤出超出预算的文档，对应示例如下：</p>
<p>​<br>    &gt; db.acbook.find({$expr: {$gt: [“$开支”, “$预算”]}})<br>    { “_id” : 1, “category” : “衣”, “预算” : 300, “开支” : 600 }<br>    { “_id” : 4, “category” : “行”, “预算” : 220, “开支” : 360 }</p>
<p>示例中使用了 <code>$gt</code> 表达式，用于比较 <code>开支</code> 和 <code>预算</code>。我们也可以使用 <code>$lt</code> 表达式，对应命令如下：</p>
<p>​<br>    &gt; db.acbook.find({$expr: {$lt: [“$预算”, “$开支”]}})<br>    { “_id” : 1, “category” : “衣”, “预算” : 300, “开支” : 600 }<br>    { “_id” : 4, “category” : “行”, “预算” : 220, “开支” : 360 }</p>
<p><code>$expr</code> 支持的表达式非常多，详见官方文档<br>[Expressions](<a href="https://docs.mongodb.com/manual/meta/aggregation-quick-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/meta/aggregation-quick-</a><br>reference/#aggregation-expressions)。</p>
<p><strong>mod</strong></p>
<p><code>$mod</code> 的作用是对字段的值执行模运算，并选择具有指定结果的文档。其语法格式如下：</p>
<p>​<br>    { field: { $mod: [ divisor, remainder ] } }</p>
<p>假设要过滤出集合 <code>acbook</code> 中满足 <code>mod(开支, 6) = 0</code> 的文档。对应示例如下：</p>
<p>​<br>    &gt; db.acbook.find({开支: {$mod: [6, 0]}})<br>    { “_id” : 1, “category” : “衣”, “预算” : 300, “开支” : 600 }<br>    { “_id” : 2, “category” : “食”, “预算” : 1000, “开支” : 600 }<br>    { “_id” : 4, “category” : “行”, “预算” : 220, “开支” : 360 }</p>
<p>即 <code>mod(600, 6) = 0</code>， <code>mod(360, 6) = 0</code>。同理，要过滤出集合 <code>acbook</code> 中满足 <code>mod(开支, 6) = 2</code><br>的文档，对应示例如下：</p>
<p>​<br>    &gt; db.acbook.find({开支: {$mod: [6, 2]}})<br>    { “_id” : 3, “category” : “住”, “预算” : 800, “开支” : 800 }</p>
<p>即 <code>mod(800, 6) = 2</code>。要注意的是，<code>$mod</code> 只接受 2 个参数：<code>divisor</code> 和 <code>remainder</code>。如果只传入 1<br>个参数，例如 <code>db.acbook.find({开支: {$mod: [6]}})</code>， 就会得到如下错误提示：</p>
<p>​<br>    Error: error: {<br>        “ok” : 0,<br>        “errmsg” : “malformed mod, not enough elements”,<br>        “code” : 2,<br>        “codeName” : “BadValue”<br>    }</p>
<p>不传入值或传入多个值也是不被允许的，在返回文档中的 <code>errmsg</code> 处会给出对应的提示。例如不传入值对应的提示为 <code>malformed mod, not
enough elements</code>，而多个值对应的提示为 <code>malformed mod, too many elements</code>。</p>
<p><strong>提示</strong> ：在 <code>2.6</code> 版本中，传入单个值时会默认补上 <code>0</code>，传入多个值时会忽略多余的值。例如 <code>db.acbook.find({开支:
{$mod: [6]}})</code> 和 <code>db.acbook.find({开支: {$mod: [6, 2, 3, 5]}})</code> 等效于<br><code>db.acbook.find({开支: {$mod: [6, 0]}})</code>。但 <code>4.0</code> 版本不允许这样做。</p>
<p><strong>regex</strong></p>
<p>MongoDB 提供的 <code>$regex</code> 让开发者可以在查询语句中使用正则表达式，这实在是令人惊喜。MongoDB 中的正则表达式是 PCRE，即 Perl<br>语言兼容的正则表达式。<code>$regex</code> 语法格式如下：</p>
<p>​<br>    { <field>: { $regex: /pattern/, $options: ‘<options>‘ } }<br>    { <field>: { $regex: ‘pattern’, $options: ‘<options>‘ } }<br>    { <field>: { $regex: /pattern/<options> } }</options></field></options></field></options></field></p>
<p>三种格式任选其一，特定语法的使用限制可参考 [$regex<br>vs./pattern/Syntax](<a href="https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query/regex/#regex-</a><br>vs-pattern-syntax) 。也可以用下面这种语法：</p>
<p>​<br>    { <field>: /pattern/<options> }</options></field></p>
<p>正则表达式中有一些特殊选项（又称模式修正符），例如不区分大小写或允许使用点字符等，MongoDB 中支持的选项如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>语法限制</th>
</tr>
</thead>
<tbody><tr>
<td><code>i</code></td>
<td>不区分大小写字母。</td>
<td></td>
</tr>
<tr>
<td><code>m</code></td>
<td>支持多行匹配。</td>
<td></td>
</tr>
<tr>
<td><code>x</code></td>
<td>忽略空格和注释（#），注释以 <code>\n</code> 结尾。</td>
<td>必须使用 $option</td>
</tr>
<tr>
<td><code>s</code></td>
<td>允许点（.）字符匹配括换行符在内的所有字符，也可以理解为允许点（.）字符匹配换行符后面的字符。</td>
<td>必须使用 $option</td>
</tr>
</tbody></table>
<p>在开始学习之前，准备以下数据：</p>
<p>​<br>    &gt; db.regexs.insertMany([<br>    … {_id: 1, nickname: “abc123”, desc: “Single Line Description.”},<br>    … {_id: 2, nickname: “abc299”, desc: “First line \nSecond line”},<br>    … {_id: 3, nickname: “xyz5566”, desc: “Many spaces before    line”},<br>    … {_id: 4, nickname: “xyz8205”, desc: “Multiple\nline description”}<br>    … ])</p>
<p>假设要过滤出 <code>nickname</code> 值结尾为 <code>299</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.regexs.find({nickname: {$regex: /299$/}})<br>    { “_id” : 2, “nickname” : “abc299”, “desc” : “First line \nSecond line” }</p>
<p>这相当于 SQL 中的模糊查询，对应的 SQL 语句为 <code>SELECT * FROM regexs WHERE nickname like
&quot;%299&quot;</code>。接下来使用模式修正符 <code>i</code> 实现不区分大小写的匹配，对应示例如下：</p>
<p>​<br>    &gt; db.regexs.find({nickname: {$regex: /^aBc/i}})<br>    { “_id” : 1, “nickname” : “abc123”, “desc” : “Single Line Description.” }<br>    { “_id” : 2, “nickname” : “abc299”, “desc” : “First line \nSecond line” }</p>
<p>这个语句的作用是过滤出集合 <code>regexs</code> 中 <code>nickname</code> 字段值由 <code>aBc</code><br>开头的文档，并在匹配时忽略大小写字母。接下来我们再通过一个例子了解模式修正符 <code>m</code> 的用法和作用，对应示例如下：</p>
<p>​<br>    &gt; db.regexs.find({desc: {$regex: /^s/, $options: “im”}})<br>    { “_id” : 1, “nickname” : “abc123”, “desc” : “Single Line Description.” }<br>    { “_id” : 2, “nickname” : “abc299”, “desc” : “First line \nSecond line” }</p>
<p>这个语句的作用是过滤出集合 <code>regexs</code> 中 <code>desc</code> 字段值由 <code>s</code> 开头的文档，匹配时忽略大小写字母，并进行多行匹配。虽然 <code>_id</code> 为 2<br>的文档中的 <code>desc</code> 并不是 <code>s</code> 或 <code>S</code> 开头，但由于使用了模式修正符 <code>m</code>，所以能够匹配到 <code>\n</code> 符号后面的<br><code>Second</code>。如果没有使用模式修正符 <code>m</code>，那么匹配结果将会是 <code>{ &quot;_id&quot; : 1, &quot;nickname&quot; : &quot;abc123&quot;, &quot;desc&quot;
: &quot;Single Line Description.&quot; }</code>。</p>
<p>点字符和星号在正则表达式中是最常用的组合，MongoDB 也支持这个组合。假设要过滤出集合 <code>regexs</code> 中 <code>desc</code> 字段值由 <code>m</code> 开头且<br><code>line</code> 结尾的文档，对应示例如下：</p>
<p>​<br>    &gt; db.regexs.find({desc: {$regex: /m.*line/, $options: “is”}})<br>    { “_id” : 3, “nickname” : “xyz5566”, “desc” : “Many spaces before    line” }<br>    { “_id” : 4, “nickname” : “xyz8205”, “desc” : “Multiple\nline description” }</p>
<p>如果不使用模式修正符 <code>s</code>，<code>.*</code> 组合也是可用的，但无法匹配到换行符后面的内容，那么匹配结果将会是 <code>{ &quot;_id&quot; : 3, &quot;nickname&quot;
: &quot;xyz5566&quot;, &quot;desc&quot; : &quot;Many spaces before line&quot; }</code>。</p>
<p>模式修正符 <code>x</code> 的描述为：“忽略空格和注释（#），注释以 <code>\n</code><br>结尾”。这理解起来有些困难，但你不用担心，只要跟着本文指引和案例，就能够掌握模式修正符 <code>x</code> 的正确用法。示例如下：</p>
<p>​<br>    &gt; var pattern = “abc #category code\n123 #item number”<br>    &gt; db.regexs.find({nickname: {$regex: pattern, $options: “x”}})<br>    { “_id” : 1, “nickname” : “abc123”, “desc” : “Single Line Description.” }</p>
<p>正则规则为 <code>abc #category code\n123 #item number</code>，根据模式修正符 <code>x</code> 的描述，我们可以将其转换为<br><code>abc123</code>。即过滤出集合 <code>regexs</code> 中 <code>nickname</code> 值为 <code>abc123</code> 的文档，所以执行结果为：</p>
<p><code>{ &quot;_id&quot; : 1, &quot;nickname&quot; : &quot;abc123&quot;, &quot;desc&quot; : &quot;Single Line Description.&quot; }</code></p>
<p>再来看一个示例：</p>
<p>​<br>    &gt; var pattern = “abc #category code\n xyz#item number”<br>    &gt; db.regexs.find({nickname: {$regex: pattern, $options: “x”}})</p>
<p>这个命令并没有得到文档输出，也就是说没有文档符合其规则，这是因为 <code>abc #category code\n xyz#item number</code> 等效于<br><code>abcxyz</code>。<code>pattern</code> 中的 <code>#</code> 代表注释，而 <code>\n</code> 表示注释结束。所以 <code>#category code\n</code> 和 <code>#item
number</code> 是没有用的，有用的是 <code>abc</code> 和 <code>xyz</code>。根据这个规则，我们可以过滤出集合 <code>regexs</code> 中 <code>nickname</code> 值包含<br><code>abc</code> 的文档。对应命令如下：</p>
<p>​<br>    &gt; var pattern = “abc # xyz #category code\n # item number 123”<br>    &gt; db.regexs.find({nickname: {$regex: pattern, $options: “x”}})<br>    { “_id” : 1, “nickname” : “abc123”, “desc” : “Single Line Description.” }<br>    { “_id” : 2, “nickname” : “abc299”, “desc” : “First line \nSecond line” }</p>
<p>此时 <code>#xyz</code>，<code>#category code\n</code> 和 <code># item number 123</code> 均无效，有效的只有<br><code>abc</code>，所以能够匹配到两个文档。再来看下面这个示例：</p>
<p>​<br>    &gt; var pattern = “# abc\n 299 # xyz #category code\n # item number”<br>    &gt; db.regexs.find({nickname: {$regex: pattern, $options: “x”}})<br>    { “_id” : 2, “nickname” : “abc299”, “desc” : “First line \nSecond line” }</p>
<p>回顾一下模式修正符 <code>x</code> 的描述：“忽略空格和注释（#），注释以 <code>\n</code> 结尾”。此时 <code># abc\n</code>， <code># xyz #category
code\n</code> 和 <code># item number</code> 均无效，由于注释以 <code>\n</code> 结尾，所以 <code># abc\n 299</code> 中的 <code>299</code><br>有效，才会输出文档：</p>
<p><code>{ &quot;_id&quot; : 2, &quot;nickname&quot; : &quot;abc299&quot;, &quot;desc&quot; : &quot;First line \nSecond line&quot; }</code></p>
<p><strong>text</strong></p>
<p>开发者可以通过 <code>$text</code> 搜索符合条件的文档，其语法格式如下：</p>
<p>​<br>    {<br>      $text:<br>        {<br>          $search: <string>,<br>          $language: <string>,<br>          $caseSensitive: <boolean>,<br>          $diacriticSensitive: <boolean><br>        }<br>    }</boolean></boolean></string></string></p>
<p>在 <code>$text</code> 中可以使用 <code>$search</code>， <code>$language</code>， <code>$caseSensitive</code> 和<br><code>$diacriticSensitive</code> 等指令，指令的类型和对应描述如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>$search</code></td>
<td>string</td>
<td>MongoDB 解析并用于查询文本索引的字符串。查询时采用 <code>OR</code> 逻辑，除非指定字符串为短语。</td>
</tr>
<tr>
<td><code>$language</code></td>
<td>string</td>
<td>确定搜索停止词列表以及词干分析其和标记器规则的语言。如果未指定，则搜索时使用默认语言。</td>
</tr>
<tr>
<td><code>$caseSensitive</code></td>
<td>boolean</td>
<td>是否启用大小写区分。</td>
</tr>
<tr>
<td><code>$diacriticSensitive</code></td>
<td>boolean</td>
<td>是否启用变音符敏感搜索。</td>
</tr>
</tbody></table>
<p>在开始学习之前，准备以下数据：</p>
<p>​<br>    &gt; db.news.insertMany([<br>    … { _id: 1, subject: “coffee”, author: “xyz”, views: 50 },<br>    … { _id: 2, subject: “Coffee Shopping”, author: “efg”, views: 5 },<br>    … { _id: 3, subject: “Baking a cake”, author: “abc”, views: 90  },<br>    … { _id: 4, subject: “baking”, author: “xyz”, views: 100 },<br>    … { _id: 5, subject: “Café Con Leche”, author: “abc”, views: 200 },<br>    … { _id: 6, subject: “Сырники”, author: “jkl”, views: 80 },<br>    … { _id: 7, subject: “coffee and cream”, author: “efg”, views: 10 },<br>    … { _id: 8, subject: “Cafe con Leche”, author: “xyz”, views: 10 },<br>    … { _id: 9, subhect: “NBA”, author: “coffee”, views: 300}<br>    … ])</p>
<p>接着为 <code>subject</code> 和 <code>author</code> 建立文本索引。对应命令如下：</p>
<p>​<br>    &gt; db.news.createIndex({subject: “text”, author: “text”})<br>    {<br>        “createdCollectionAutomatically” : false,<br>        “numIndexesBefore” : 1,<br>        “numIndexesAfter” : 2,<br>        “ok” : 1<br>    }</p>
<p><code>$search</code> 可以搜索单个词、多个词和短语。假设要过滤出集合 <code>news</code> 中建立了文本索引的字段 <code>subject</code> 和 <code>author</code> 中值包含<br><code>coffee</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.news.find({$text: {$search: “coffee”}})<br>    { “_id” : 9, “subhect” : “NBA”, “author” : “coffee”, “views” : 300 }<br>    { “_id” : 1, “subject” : “coffee”, “author” : “xyz”, “views” : 50 }<br>    { “_id” : 7, “subject” : “coffee and cream”, “author” : “efg”, “views” : 10 }<br>    { “_id” : 2, “subject” : “Coffee Shopping”, “author” : “efg”, “views” : 5 }</p>
<p>多词搜索中，多个词以空格进行分隔，多词搜索示例如下：</p>
<p>​<br>    &gt; db.news.find({$text: {$search: “cream Shopping”}})<br>    { “_id” : 7, “subject” : “coffee and cream”, “author” : “efg”, “views” : 10 }<br>    { “_id” : 2, “subject” : “Coffee Shopping”, “author” : “efg”, “views” : 5 }</p>
<p>上面提到，多次搜索时采用 <code>OR</code> 逻辑。在此示例中，搜索语句释义为：过滤出集合 <code>news</code> 中建立了文本索引的字段 <code>subject</code> 和<br><code>author</code> 中值包含 <code>coffee</code> 或 <code>Shopping</code> 的文档。按短语搜索的语法与按词搜索不同，其示例如下：</p>
<p>​<br>    &gt; db.news.find({$text: {$search: “&quot;coffee and&quot;“}})<br>    { “_id” : 7, “subject” : “coffee and cream”, “author” : “efg”, “views” : 10 }</p>
<p>搜索语句释义为：过滤出集合 <code>news</code> 中建立了文本索引的字段 <code>subject</code> 和 <code>author</code> 中值包含 <code>coffee
and</code>的文档。其中，以 <code>\&quot;keyword&quot;\</code> 格式将搜索词 <code>keyword</code> 设置为短语，示例中的短语表示为 <code>\&quot;coffee and\&quot;</code>。</p>
<p><code>$search</code> 中用前缀减号（-）作为否定词，这样我们就能够实现类似于 <code>NOT</code> 的过滤规则。假设要过滤出集合 <code>news</code> 中建立了文本索引的字段<br><code>subject</code> 和 <code>author</code> 中值包含 <code>coffee</code> 但不包含 <code>Shopping</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.news.find({$text: {$search: “coffee -Shopping”}})<br>    { “_id” : 9, “subhect” : “NBA”, “author” : “coffee”, “views” : 300 }<br>    { “_id” : 1, “subject” : “coffee”, “author” : “xyz”, “views” : 50 }<br>    { “_id” : 7, “subject” : “coffee and cream”, “author” : “efg”, “views” : 10 }</p>
<p><code>$language</code> 可以指定语言。假要过滤出集合 <code>news</code> 中建立了文本索引的字段 <code>subject</code> 和 <code>author</code> 中值包含<br><code>leche</code> 且内容为默认语言或 <code>es</code> （西班牙语）的文档，对应示例如下：</p>
<p>​<br>    &gt; db.news.find({ $text: {$search: “leche”, $language: “es”}})<br>    { “_id” : 8, “subject” : “Cafe con Leche”, “author” : “xyz”, “views” : 10 }<br>    { “_id” : 5, “subject” : “Café Con Leche”, “author” : “abc”, “views” : 200 }</p>
<p><code>$text</code> 支持的语言如下：</p>
<table>
<thead>
<tr>
<th>语言名称</th>
<th>简写（ISO 639-1 规则）</th>
</tr>
</thead>
<tbody><tr>
<td><code>danish</code></td>
<td><code>da</code></td>
</tr>
<tr>
<td><code>dutch</code></td>
<td><code>nl</code></td>
</tr>
<tr>
<td><code>english</code></td>
<td><code>en</code></td>
</tr>
<tr>
<td><code>finnish</code></td>
<td><code>fi</code></td>
</tr>
<tr>
<td><code>french</code></td>
<td><code>fr</code></td>
</tr>
<tr>
<td><code>german</code></td>
<td><code>de</code></td>
</tr>
<tr>
<td><code>hungarian</code></td>
<td><code>hu</code></td>
</tr>
<tr>
<td><code>italian</code></td>
<td><code>it</code></td>
</tr>
<tr>
<td><code>norwegian</code></td>
<td><code>nb</code></td>
</tr>
<tr>
<td><code>portuguese</code></td>
<td><code>pt</code></td>
</tr>
<tr>
<td><code>romanian</code></td>
<td><code>ro</code></td>
</tr>
<tr>
<td><code>russian</code></td>
<td><code>ru</code></td>
</tr>
<tr>
<td><code>spanish</code></td>
<td><code>es</code></td>
</tr>
<tr>
<td><code>swedish</code></td>
<td><code>sv</code></td>
</tr>
<tr>
<td><code>turkish</code></td>
<td><code>tr</code></td>
</tr>
</tbody></table>
<p>上面示例中使用的是简写，实际上 <code>$text</code> 也支持全称。例如 <code>es</code> 等效于<br><code>spanish</code>。变音符号和不敏感搜索并不常用，对此感兴趣的读者可以查阅官方文档 [Case and Diacritic Insensitive<br>Search](<a href="https://docs.mongodb.com/manual/reference/operator/query/text/#case-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query/text/#case-</a><br>and-diacritic-insensitive-search)。</p>
<p><code>$regex</code> 中是否区分大小写使用的是模式修正符 <code>i</code>，这里使用的是 <code>$caseSensitive</code> 指令。默认情况下，是不区分大小写的，即<br><code>$caseSensitive: true</code>。如果需要开启大小写区分，则将其设为 <code>false</code> 即可。假设要过滤出集合 <code>news</code><br>中建立了文本索引的字段 <code>subject</code> 和 <code>author</code> 中值包含 <code>Baking</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.news.find({$text: {$search: “Baking”, $caseSensitive: true}})<br>    { “_id” : 3, “subject” : “Baking a cake”, “author” : “abc”, “views” : 90 }</p>
<p>反之，如果要过滤出集合 <code>news</code> 中建立了文本索引的字段 <code>subject</code> 和 <code>author</code> 中值包含 <code>Baking</code> 或 <code>baking</code><br>的文档。对应命令如下：</p>
<p>​<br>    &gt; db.news.find({$text: {$search: “Baking”, $caseSensitive: false}})<br>    { “_id” : 4, “subject” : “baking”, “author” : “xyz”, “views” : 100 }<br>    { “_id” : 3, “subject” : “Baking a cake”, “author” : “abc”, “views” : 90 }</p>
<p>单个词，多词，短语搜索和否定词搜索中，<code>$caseSensitive</code> 的用法一致。要注意的是，区分大小写会影响查询速度。</p>
<p><strong>where</strong></p>
<p>使用 <code>$where</code> 可以将包含 JavaScript 表达式的字符串或函数传递给查询系统。显然，<code>$where</code> 提供了更高的灵活性，但它会将<br>JavaScript 表达式或函数应用在集合中的每个文档上，因此它对查询速度有一定影响。<code>$where</code> 支持的函数和可用属性如下：</p>
<table>
<thead>
<tr>
<th>可用属性</th>
<th>支持的函数</th>
<th>支持的函数</th>
<th>支持的函数</th>
</tr>
</thead>
<tbody><tr>
<td><code>args</code>, <code>MaxKey</code>， <code>MinKey</code></td>
<td><code>assert()</code>, <code>BinData()</code>, <code>DBPointer()</code>,</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>DBRef()</code>, <code>doassert()</code>,<code>emit()</code>, <code>gc()</code>, <code>HexData()</code>, <code>hex_md5()</code>,</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>isNumber()</code>, <code>isObject()</code>, <code>ISODate()</code>, <code>isString()</code></td>
<td><code>Map()</code>, <code>MD5()</code>,</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>NumberInt()</code>, <code>NumberLong()</code>, <code>ObjectId()</code>, <code>print()</code>, <code>printjson()</code>,</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>printjsononeline()</code></td>
<td><code>sleep()</code>, <code>Timestamp()</code>, <code>tojson()</code>,</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>tojsononeline()</code>, <code>tojsonObject()</code>, <code>UUID()</code>, <code>version()</code></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.players.insertMany([<br>    … {_id: 12378, name: “Steve”, username: “steveisawesome”, first_login: “2017-01-01”},<br>    … {_id: 2, name: “Anya”, username: “anya”, first_login: “2001-02-02”}<br>    … ])</p>
<p>假设要过滤出集合 <code>players</code> 中 <code>name</code> 的 MD5 值为 <code>9b53e667f30cd329dca1ec9e6a83e994</code><br>的文档，对应示例如下：</p>
<p>​<br>    &gt; db.players.find( { $where: function() {<br>    … return (hex_md5(this.name) == “9b53e667f30cd329dca1ec9e6a83e994”);<br>    … }})<br>    { “_id” : 2, “name” : “Anya”, “username” : “anya”, “first_login” : “2001-02-02” }</p>
<p>由于 <code>Anya</code> 的 MD5 值为 <code>9b53e667f30cd329dca1ec9e6a83e994</code>，所以匹配到 <code>_id</code> 为 <code>2</code><br>的文档。要注意的是，<code>$where</code> 中不要使用全局变量，且 <code>$where</code> 无法使用索引。</p>
<p>更多关于评估查询操作符的知识可查阅官方文档 [Evaluation Query<br>Operators](<a href="https://docs.mongodb.com/manual/reference/operator/query-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query-</a><br>evaluation/#evaluation-query-operators)。</p>
<h5 id="数组查询操作符"><a href="#数组查询操作符" class="headerlink" title="数组查询操作符"></a>数组查询操作符</h5><p>MongoDB 中的数组查询操作符共有 3 个，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/all/#op._S_all" target="_blank" rel="noopener"><code>$all</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配包含查询中指定条件的所有元素的数组。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/elemMatch/#op._S_elemMatch" target="_blank" rel="noopener"><code>$elemMatch</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配数组字段中至少有 1 个元素与指定条件相符的文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/size/#op._S_size" target="_blank" rel="noopener"><code>$size</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配数组元素数符合指定大小的文档。</td>
</tr>
</tbody></table>
<p><strong>all</strong></p>
<p><code>$all</code> 语法格式如下：</p>
<p>​<br>    { <field>: { $all: [ <value1> , <value2> … ] } }</value2></value1></field></p>
<p>它与 <code>$and</code> 操作相当，即 <code>{tags:{$all: [&quot;ssl&quot; , &quot;security&quot;]}}</code> 等效于 <code>{$and: [{ tags:
&quot;ssl&quot;}, {tags: &quot;security&quot;}]}</code>， 但二者写法不同。</p>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.inventory.insertMany([<br>    … {<br>    …    _id: 1,<br>    …    code: “xyz”,<br>    …    tags: [ “school”, “book”, “bag”, “headphone”, “appliance” ],<br>    …    qty: [<br>    …           { size: “S”, num: 10, color: “blue” },<br>    …           { size: “M”, num: 45, color: “blue” },<br>    …           { size: “L”, num: 100, color: “green” }<br>    …         ]<br>    … },<br>    … {<br>    …    _id: 2,<br>    …    code: “abc”,<br>    …    tags: [ “appliance”, “school”, “book” ],<br>    …    qty: [<br>    …           { size: “6”, num: 100, color: “green” },<br>    …           { size: “6”, num: 50, color: “blue” },<br>    …           { size: “8”, num: 100, color: “brown” }<br>    …         ]<br>    … },<br>    … {<br>    …    _id: 3,<br>    …    code: “efg”,<br>    …    tags: [ “school”, “book” ],<br>    …    qty: [<br>    …           { size: “S”, num: 10, color: “blue” },<br>    …           { size: “M”, num: 100, color: “blue” },<br>    …           { size: “L”, num: 100, color: “green” }<br>    …         ]<br>    … },<br>    … {<br>    …    _id: 4,<br>    …    code: “ijk”,<br>    …    tags: [ “electronics”, “school” ],<br>    …    qty: [<br>    …           { size: “M”, num: 100, color: “green” }<br>    …         ]<br>    … }<br>    … ])</p>
<p>假设要过滤出集合 <code>inventory</code> 中 <code>tag</code> 字段值（数组）元素包含 <code>appliance</code>， <code>school</code> 和 <code>book</code><br>的文档，对应示例如下：</p>
<p>​<br>    &gt; db.inventory.find({tags: {$all: [“appliance”, “school”, “book”]}})<br>    {<br>       _id: 1,<br>       code: “xyz”,<br>       tags: [ “school”, “book”, “bag”, “headphone”, “appliance” ],<br>       qty: [<br>              { size: “S”, num: 10, color: “blue” },<br>              { size: “M”, num: 45, color: “blue” },<br>              { size: “L”, num: 100, color: “green” }<br>            ]<br>    }<br>    {<br>       _id: 2,<br>       code: “abc”,<br>       tags: [ “appliance”, “school”, “book” ],<br>       qty: [<br>              { size: “6”, num: 100, color: “green” },<br>              { size: “6”, num: 50, color: “blue” },<br>              { size: “8”, num: 100, color: “brown” }<br>            ]<br>    }</p>
<p><code>$all</code> 的存在是为了支持数组查询，但也可以作用于非数组。示例如下：</p>
<p>​<br>    &gt; db.inventory.find({“qty.num”: {$all: [50]}})</p>
<p>它等效于：</p>
<p>​<br>    &gt; db.inventory.find({“qty.num”: 50})</p>
<p><strong>elemMatch</strong></p>
<p><code>$elemMatch</code> 操作符将匹配数组中至少有 1 个元素满足查询条件的文档，其语法格式如下：</p>
<p>​<br>    { <field>: { $elemMatch: { <query1>, <query2>, … } } }</query2></query1></field></p>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.scores.insertMany([<br>    … {_id: 1, res: [70, 85, 88]},<br>    … {_id: 2, res: [60, 78, 90]}<br>    … ])</p>
<p>假设要过滤出集合 <code>scores</code> 中 <code>res</code> 数组元素满足 <code>大于 80</code> 且 <code>小于 86</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.scores.find({res: {$elemMatch: {$gt: 80, $lt: 86}}})<br>    { “_id” : 1, “res” : [ 70, 85, 88 ] }</p>
<p>将条件改为 <code>小于 70</code>，对应示例如下：</p>
<p>​<br>    &gt; db.scores.find({res: {$elemMatch: {$lt: 70}}})<br>    { “_id” : 2, “res” : [ 60, 78, 90 ] }</p>
<p>当 <code>&lt;query&gt;</code> 只有 1 个时，可以省略 <code>$elemMatch</code>。即 <code>{res: {$elemMatch: {$lt: 70}}</code> 等效于<br><code>{res: {$lt: 70}}</code>。<code>$elemMatch</code> 可以用于嵌入式文档，例如我们需要过滤出集合 <code>inventory</code> 中 <code>qty</code> 数组元素<br><code>num = 50</code> 且 <code>color = &quot;blue&quot;</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.inventory.find({qty: {$elemMatch: {num: 50, color: “blue”}}})<br>    {<br>       _id: 2,<br>       code: “abc”,<br>       tags: [ “appliance”, “school”, “book” ],<br>       qty: [<br>              { size: “6”, num: 100, color: “green” },<br>              { size: “6”, num: 50, color: “blue” },<br>              { size: “8”, num: 100, color: “brown” }<br>            ]<br>    }</p>
<p><code>$all</code> 和 <code>$elemMatch</code> 联合使用的示例如下：</p>
<p>​<br>    &gt; db.inventory.find({qty: {$all: [{“$elemMatch”: {size: “M”, num: {$gt: 50}}},<br>    … {“$elemMatch”: {num: 100, color: “green”}}<br>    … ]}})<br>    {<br>       “_id” : 3,<br>       “code” : “efg”,<br>       “tags” : [ “school”, “book”],<br>       “qty” : [<br>                 { “size” : “S”, “num” : 10, “color” : “blue” },<br>                 { “size” : “M”, “num” : 100, “color” : “blue” },<br>                 { “size” : “L”, “num” : 100, “color” : “green” }<br>               ]<br>    }<br>    {<br>       “_id” : 4,<br>       “code” : “ijk”,<br>       “tags” : [ “electronics”, “school” ],<br>       “qty” : [<br>                 { “size” : “M”, “num” : 100, “color” : “green” }<br>               ]<br>    }                             </p>
<p>以上示例的目的是过滤出集合 <code>inventory</code> 中 <code>qty</code> 数组中满足 <code>$elemMatch</code> 条件的文档。要注意的是，<code>$where</code> 和<br><code>$text</code> 中不可使用 <code>$elemMatch</code>。</p>
<p><strong>size</strong></p>
<p><code>$size</code> 用于匹配数组元素数符合指定大小的文档。在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.mari.insertMany([<br>    … {_id: 1, tag: [“大数据”, “数据分析”, “数据挖掘”]},<br>    … {_id: 2, tag: [“python”, “java”, “rust”]},<br>    … {_id: 3, tag: [“静态语言”, “编译”]},<br>    … {_id: 4, tag: [“内存安全”]}<br>    … ])</p>
<p>集合 <code>mari</code> 中共有 4 个文档，假设需要过滤出数组 <code>tag</code> 元素数量为 2 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.mari.find({tag: {$size: 2}})<br>    { “_id” : 3, “tag” : [ “静态语言”, “编译” ] }</p>
<p>同理，过滤出数组 <code>tag</code> 元素数量为 3 的文档的示例如下：</p>
<p>​<br>    &gt; db.mari.find({tag: {$size: 3}})<br>    { “_id” : 1, “tag” : [ “大数据”, “数据分析”, “数据挖掘” ] }<br>    { “_id” : 2, “tag” : [ “python”, “java”, “rust” ] }</p>
<p>要注意的是，<code>$size</code> 和 <code>size()</code> 的作用不同，切勿混淆。</p>
<h5 id="按位查询操作符"><a href="#按位查询操作符" class="headerlink" title="按位查询操作符"></a>按位查询操作符</h5><p>MongoDB 中的按位查询操作符共有 4 个，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/bitsAllClear/#op._S_bitsAllClear" target="_blank" rel="noopener"><code>$bitsAllClear</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配 <code>&lt;field&gt;</code> 的二进制值中指定位置值均为 <code>0</code> 的文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/bitsAllSet/#op._S_bitsAllSet" target="_blank" rel="noopener"><code>$bitsAllSet</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配 <code>&lt;field&gt;</code> 的二进制值中指定位置值均为 <code>1</code> 的文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/bitsAnyClear/#op._S_bitsAnyClear" target="_blank" rel="noopener"><code>$bitsAnyClear</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配 <code>&lt;field&gt;</code> 的二进制值中任一指定位置值为 <code>0</code> 的文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/query/bitsAnySet/#op._S_bitsAnySet" target="_blank" rel="noopener"><code>$bitsAnySet</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>匹配 <code>&lt;field&gt;</code> 的二进制值中任一指定位置值为 <code>1</code> 的文档。</td>
</tr>
</tbody></table>
<p>按位查询操作符用于匹配二进制数值。数字 <code>254</code> 对应的二进制为 <code>11111110</code>，每个二进制值与位置对应关系如下：</p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td>位置</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>4 个按位查询操作符的操作均基于该对应关系。</p>
<p><code>$bitsAllClear</code> 匹配 <code>&lt;field&gt;</code> 的二进制值中指定位置值均为 <code>0</code> 的文档，其语法格式如下：</p>
<p>​<br>    { <field>: { $bitsAllClear: <numeric bitmask> } }<br>    { <field>: { $bitsAllClear: &lt; BinData bitmask&gt; } }<br>    { <field>: { $bitsAllClear: [ <position1>, <position2>, … ] } }</position2></position1></field></field></numeric></field></p>
<p><code>$bitsAllClear</code> 支持 3 种不同的位置表示，它们分别是 <code>Bit Position Array</code>， <code>Integer Bitmask</code> 和<br><code>BinData Bitmast</code>。要注意的是，该 <code>&lt;field&gt;</code> 的值必须是数值或者一个 <code>BinData</code> 对象，否则<br><code>$bitsAllClear</code> 无法匹配到文档。在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.bits.insertMant([<br>    … {“_id”: 1, “a”: 54, “binaryOfA”: “00110110”},<br>    … {“_id”: 2, “a”: 20, “binaryOfA”: “00010100”},<br>    … {“_id”: 3, “a”: 20, “binaryOfA”: “00010100”},<br>    … {“_id”: 4, “a”: BinData(0,”Zg==”), “binaryOfA”: “01100110”}<br>    … ])</p>
<p>假设要过滤出位置 1 和位置 5 上二进制值为 <code>0</code> 的文档，对应示例如下：</p>
<p>​<br>    &gt; db.bits.find({a: {$bitsAllClear: [1, 5]}})<br>    { “_id”: 2, “a”: 20, “binaryOfA”: “00010100” }<br>    { “_id”: 3, “a”: 20, “binaryOfA”: “00010100” }</p>
<p>其中 <code>a</code> 的值为 <code>20</code>，对应的二进制为 <code>00010100</code>，所以得到的结果是 <code>_id</code> 为 <code>2</code> 和 <code>3</code> 的两个文档。要注意的是，查询的<br><code>&lt;field&gt;</code> 是 <code>a</code>，而不是 <code>binaryOfA</code>。<code>binaryOfA</code><br>只是便于我们在学习时查看二进制值而已，你可以将其值替换成任何内容，都不会影响查询结果。</p>
<p>除了用 <code>[1, 5]</code> （即 <code>Bit Position Array</code>）表示位置外，还可以用数字（即 <code>Integer Bitmask</code>）来表示。数字<br><code>35</code> 的二进制为 <code>00100011</code>，其位置关系如下：</p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>0</th>
<th>0</th>
<th>0</th>
<th>1</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>位置</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>二进制值为 <code>1</code> 的位置分别是 <code>0</code>、 <code>1</code> 和 <code>5</code>，这等效于 <code>Bit Position Array</code> 中的 <code>[0, 1, 5]</code>。即<br><code>{a: {$bitsAllClear: [0, 1, 5]}}</code> 等效于 <code>{a: {$bitsAllClear: 35}}</code>。</p>
<p><code>BinData Bitmask</code> 写法即用 <code>BinData</code> 对象表示位置，例如 <code>BinData(0, ID==)</code> 的二进制为<br><code>00010100</code>，这等效于 <code>Bit Position Array</code> 中的 <code>[2, 4]</code>。BinData 示例如下：</p>
<p>​<br>    &gt; db.bits.find({a: {$bitsAllClear: BinData(0, “ID==”)}})</p>
<p>由于没有文档能够满足该条件，所以查询结果为空。</p>
<p>考虑到按位查询操作符在实际应用中用的较少，且 4 个按位查询操作符语法和用法差异并不大，所以本小节只介绍 <code>$bitsAllClear</code>。另外 3<br>种按位查询操作符的语法和用法可查阅官方文档 [Bitwise Query<br>Operators](<a href="https://docs.mongodb.com/manual/reference/operator/query-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/query-</a><br>bitwise/#bitwise-query-operators)</p>
<h5 id="投影操作"><a href="#投影操作" class="headerlink" title="投影操作"></a>投影操作</h5><p>在之前的介绍中，很多查询操作都类似于 <code>SELECT * FROM</code>。在有些需要返回指定 <code>&lt;field&gt;</code> 的场景，例如 <code>SELECT name
FROM</code> 时怎么办呢？MongoDB 的查询语句非常友好，以集合 <code>inven</code> 中球员为 <code>韦德</code> 的文档为例：</p>
<p>​<br>    {<br>        “_id” : ObjectId(“5d159e794d3d891430a2512e”),<br>        “name” : “韦德”,<br>        “number” : 3,<br>        “attribute” : {<br>            “h” : 193,<br>            “w” : 220,<br>            “p” : “得分后卫”<br>        },<br>        “status” : “R”<br>    }</p>
<p>假设想要执行与 <code>SELECT name, number FROM inven WHERE number = 3</code> 等效的操作，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({number: 3}, {name: 1, number: 1})<br>    {<br>        “_id” : ObjectId(“5d159e794d3d891430a2512e”),<br>        “name” : “韦德”,<br>        “number” : 3<br>    }</p>
<p>通过在查询语句中加入 <code>{name: 1, number: 1}</code> 实现 <code>&lt;field&gt;</code> 的过滤，此示例中仅取球员名称和球衣号。如果要取反，那么只需要将<br><code>1</code> 改为 <code>0</code> 即可，例如：</p>
<p>​<br>    &gt; db.inven.find({number: 3}, {number: 0, _id: 0})<br>    {<br>        “name” : “韦德”,<br>        “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” },<br>        “status” : “R”<br>    }</p>
<p>语句允许同时存在 <code>1</code> 和 <code>0</code>，但它有一定的条件。当我们使用 <code>db.inven.find({number: 3}, {number: 1,
name: 0})</code> 这样的命令时，会得到如下错误提示：</p>
<p>​<br>    Error: error: {<br>        “ok” : 0,<br>        “errmsg” : “Projection cannot have a mix of inclusion and exclusion.”,<br>        “code” : 2,<br>        “codeName” : “BadValue”<br>    }</p>
<p>但如果设为 <code>0</code> 的 <code>&lt;field&gt;</code> 是 <code>_id</code>，那就不会出现错误提示。对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({number: 3}, {number: 1, _id: 0, name: 1})<br>    { “name” : “韦德”, “number” : 3 }</p>
<p>MongoDB 提供了 4 种投影操作符，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/projection/positional/#proj._S_" target="_blank" rel="noopener"><code>$</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>投影数组中与指定条件匹配的第一个元素。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/projection/elemMatch/#proj._S_elemMatch" target="_blank" rel="noopener"><code>$elemMatch</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>投影数组中与 <code>$elemMatch</code> 指定条件匹配的第一个元素。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/projection/meta/#proj._S_meta" target="_blank" rel="noopener"><code>$meta</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>投影在<a href="https://docs.mongodb.com/manual/reference/operator/query/text/#op._S_text" target="_blank" rel="noopener"><code>$text</code></a>操作期间分配的文档分数。</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/projection/slice/#proj._S_slice" target="_blank" rel="noopener"><code>$slice</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>限制从数组投射的元素数量。支持跳过和限制切片。</td>
</tr>
</tbody></table>
<p><strong>$</strong></p>
<p><code>$</code> 的作用是投影数组中符合指定条件的第一个元素。在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.students.insertMany([<br>    … {“_id”: 1, “semester”: 1, “grades”: [70, 87, 90]},<br>    … {“_id”: 2, “semester”: 1, “grades”: [90, 88, 92]},<br>    … {“_id”: 3, “semester”: 1, “grades”: [85, 100, 91]},<br>    … {“_id”: 4, “semester”: 2, “grades”: [79, 85, 80]},<br>    … {“_id”: 5, “semester”: 2, “grades”: [88, 88, 92]},<br>    … {“_id”: 6, “semester”: 2, “grades”: [95, 90, 96]}<br>    … ])</p>
<p>假设要过滤出 <code>grades</code> 中有元素大于等于 <code>95</code> 的 文档，并返回数组 <code>grades</code> 中满足条件的第一个元素。对应示例如下：</p>
<p>​<br>    &gt; db.students.find({grades: {$gte: 95}}, {“grades.$”: 1})<br>    { “_id” : 3, “grades” : [ 100 ] }<br>    { “_id” : 6, “grades” : [ 95 ] }</p>
<p><strong>elemMatch</strong></p>
<p><code>$elemMatch</code> 的作用是投影数组中与 <code>$elemMatch</code> 指定条件匹配的第一个元素。在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.school.insertMany([<br>    … {<br>    …  _id: 1,<br>    …  zipcode: “63109”,<br>    …  students: [<br>    …               {name: “john”, school: 102, age: 10 },<br>    …               {name: “jess”, school: 102, age: 11 },<br>    …               {name: “jeff”, school: 108, age: 15 }<br>    …            ]<br>    … },<br>    … {<br>    …  _id: 2,<br>    …  zipcode: “63110”,<br>    …  students: [<br>    …               {name: “ajax”, school: 100, age: 7 },<br>    …               {name: “achilles”, school: 100, age: 8 },<br>    …            ]<br>    … },<br>    … {<br>    …  _id: 3,<br>    …  zipcode: “63109”,<br>    …  students: [<br>    …               {name: “ajax”, school: 100, age: 7 },<br>    …               {name: “achilles”, school: 100, age: 8 },<br>    …            ]<br>    … }<br>    … ])</p>
<p>假设要过滤出集合 <code>school</code> 中 <code>zipcode</code> 为 <code>&quot;63109&quot;</code>，且数组 <code>students</code> 的字段 <code>school</code> 为 <code>102</code><br>的文档。对应示例如下：</p>
<p>​<br>    &gt; db.school.find({zipcode: “63109”}, {students: {$elemMatch: {school: 102 }}})<br>    { “_id” : 1, “students” : [ { “name” : “john”, “school” : 102, “age” : 10 } ] }<br>    { “_id” : 3 }</p>
<ul>
<li>由于 <code>_id</code> 为 <code>1</code> 的文档中数组 <code>students</code> 的字段 <code>school</code> 值为 <code>102</code>。所以 <code>$elemMatch</code> 操作返回了数组中的第一个匹配元素 <code>{ &quot;name&quot; : &quot;john&quot;, &quot;school&quot; : 102, &quot;age&quot; : 10 }</code>。</li>
<li>由于 <code>_id</code> 为 <code>1</code> 的文档中数组 <code>students</code> 的字段 <code>school</code> 值不等于 <code>102</code>。所以只返回了 <code>{_id: 3}</code>。</li>
</ul>
<p>如果省略 <code>{zipcode: &quot;63109&quot;}</code>，那么返回结果就会变成下面这样：</p>
<p>​<br>    { “_id” : 1, “zipcode” : “63109”, “students” : [<br>        { “name” : “john”, “school” : 102, “age” : 10 },<br>        { “name” : “jess”, “school” : 102, “age” : 11 },<br>        { “name” : “jeff”, “school” : 108, “age” : 15 }<br>    ]}</p>
<p><strong>slice</strong></p>
<p><code>$slice</code> 作用于数组，它的作用是限制从数组投影的元素数量。其语法格式如下：</p>
<p>​<br>    db.collection.find( { field: value }, { array: {$slice: count } } );</p>
<p><code>$slice</code> 接受多种格式的参数，包括整负值和数组，并且它支持 <code>$skpi</code> 和 <code>$limit</code>。负数作为参数的查询命令如下：</p>
<p>​<br>    db.collection.find({}, {array: {$slice: -5}})</p>
<p>参数为正代表数组从头到尾的顺序，参数为负代表从尾到头。将数组作为参数的查询命令如下：</p>
<p>​<br>    db.collection.find({}, {array: {$slice: [3, 2]}})</p>
<p>这个命令的目的是跳过该数组的前 <code>3</code> 个元素，返回 <code>2</code> 个元素，这个操作相当于 <code>[skip, limit]</code>。</p>
<h3 id="Cursor-对象"><a href="#Cursor-对象" class="headerlink" title="Cursor 对象"></a>Cursor 对象</h3><p><code>Cursor</code> 对象不是查询结果，而是查询返回的 <code>接口</code>。当我们调用 <code>find()/findMany()/findOne()</code> 时，Shell<br>并不是立即从数据库中取出数据，而是在我们使用时才会取出数据。<code>Cursor</code> 对象有很多方法，例如<br><code>close()</code>，<code>hasNext()</code>，<code>next()</code>， <code>isClose()</code> 等。完整方法及对应描述如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.addOption/#cursor.addOption" target="_blank" rel="noopener"><code>cursor.addOption()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>添加特殊的线程协议标志，用于修改查询的行为。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.batchSize/#cursor.batchSize" target="_blank" rel="noopener"><code>cursor.batchSize()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>控制 MongoDB 在单个网络消息中返回客户端的文档数。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.close/#cursor.close" target="_blank" rel="noopener"><code>cursor.close()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>关闭游标并释放相关的服务器资源。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.isClosed/#cursor.isClosed" target="_blank" rel="noopener"><code>cursor.isClosed()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>true</code> 如果光标关闭则返回。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation" target="_blank" rel="noopener"><code>cursor.collation()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指定由返回的游标的排序规则。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.comment/#cursor.comment" target="_blank" rel="noopener"><code>cursor.comment()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>在查询中附加注释，以便在日志和 <code>system.profile</code> 集合中实现可跟踪性。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.count/#cursor.count" target="_blank" rel="noopener"><code>cursor.count()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回结果集中的文档数。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.explain/#cursor.explain" target="_blank" rel="noopener"><code>cursor.explain()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>报告游标的查询执行计划。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.forEach/#cursor.forEach" target="_blank" rel="noopener"><code>cursor.forEach()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>为游标中的每个文档应用 JavaScript 函数。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.hasNext/#cursor.hasNext" target="_blank" rel="noopener"><code>cursor.hasNext()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>如果游标包含文档并且可以迭代，则返回 <code>true</code>。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.hint/#cursor.hint" target="_blank" rel="noopener"><code>cursor.hint()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>强制 MongoDB 为查询使用特定索引。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.isExhausted/#cursor.isExhausted" target="_blank" rel="noopener"><code>cursor.isExhausted()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>检查游标是否处于关闭状态，为 <code>true</code> 代表关闭。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.itcount/#cursor.itcount" target="_blank" rel="noopener"><code>cursor.itcount()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>通过获取和迭代结果集来计算游标客户端中的文档总数。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.limit/#cursor.limit" target="_blank" rel="noopener"><code>cursor.limit()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>约束游标结果集的大小。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.map/#cursor.map" target="_blank" rel="noopener"><code>cursor.map()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将函数应用于游标中的每个文档，并收集数组中的返回值。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.max/#cursor.max" target="_blank" rel="noopener"><code>cursor.max()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指定游标的独占上限索引。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.maxScan/#cursor.maxScan" target="_blank" rel="noopener"><code>cursor.maxScan()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指定要扫描的最大项目数; 收集扫描的文档，索引扫描的键。已过时</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.maxTimeMS/#cursor.maxTimeMS" target="_blank" rel="noopener"><code>cursor.maxTimeMS()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指定处理游标操作的累积时间限制（以毫秒为单位）。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.min/#cursor.min" target="_blank" rel="noopener"><code>cursor.min()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指定游标的包含性较低索引范围。用于</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.hint/#cursor.hint" target="_blank" rel="noopener"><code>cursor.hint()</code></a></td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.next/#cursor.next" target="_blank" rel="noopener"><code>cursor.next()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回游标中的下一个文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.noCursorTimeout/#cursor.noCursorTimeout" target="_blank" rel="noopener"><code>cursor.noCursorTimeout()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指示服务器在一段时间不活动后自动关闭光标。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.objsLeftInBatch/#cursor.objsLeftInBatch" target="_blank" rel="noopener"><code>cursor.objsLeftInBatch()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回当前游标批处理中剩余的文档数。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.pretty/#cursor.pretty" target="_blank" rel="noopener"><code>cursor.pretty()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>配置光标以易于阅读的格式显示结果。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.readConcern/#cursor.readConcern" target="_blank" rel="noopener"><code>cursor.readConcern()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指定[读取关注](<a href="https://docs.mongodb.com/manual/reference/glossary/#term-read-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/glossary/#term-read-</a></td>
</tr>
<tr>
<td>concern)的<a href="https://docs.mongodb.com/manual/reference/method/db.collection.find/#db.collection.find" target="_blank" rel="noopener"><code>find()</code></a>操作。</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.readPref/#cursor.readPref" target="_blank" rel="noopener"><code>cursor.readPref()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>指定对游标的[读取首选项](<a href="https://docs.mongodb.com/manual/reference/glossary/#term-read-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/glossary/#term-read-</a></td>
</tr>
<tr>
<td>preference)，以控制客户端如何将查询定向到[复制集](<a href="https://docs.mongodb.com/manual/reference/glossary/#term-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/glossary/#term-</a></td>
<td></td>
</tr>
<tr>
<td>replica-set)。</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.returnKey/#cursor.returnKey" target="_blank" rel="noopener"><code>cursor.returnKey()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>修改游标以返回索引键而不是文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.showRecordId/#cursor.showRecordId" target="_blank" rel="noopener"><code>cursor.showRecordId()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>向光标返回的每个文档添加内部存储引擎ID字段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.size/#cursor.size" target="_blank" rel="noopener"><code>cursor.size()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回应用</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.skip/#cursor.skip" target="_blank" rel="noopener"><code>skip()</code></a></td>
<td></td>
</tr>
<tr>
<td>和</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.limit/#cursor.limit" target="_blank" rel="noopener"><code>limit()</code></a></td>
<td></td>
</tr>
<tr>
<td>方法后的游标中的文档计数。</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.skip/#cursor.skip" target="_blank" rel="noopener"><code>cursor.skip()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回仅在传递或跳过多个文档后才开始返回结果的游标。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.sort/#cursor.sort" target="_blank" rel="noopener"><code>cursor.sort()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回根据排序规范排序的结果。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.tailable/#cursor.tailable" target="_blank" rel="noopener"><code>cursor.tailable()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将光标标记为 tailable，仅适用于超过上限集合的游标。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/method/cursor.toArray/#cursor.toArray" target="_blank" rel="noopener"><code>cursor.toArray()</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回一个数组，其中包含游标返回的所有文档。</td>
</tr>
</tbody></table>
<p>接下来我们将通过几个需求场景学习常用的方法。</p>
<h4 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h4><p>查询时可以使用 <code>limit()</code> 方法指定 <code>Cursor</code> 返回的文档数量，这能够有效地提高查询性能。<code>limit()</code> 语法如下：</p>
<p>​<br>    db.collection.find(<query>).limit(<number>)</number></query></p>
<p>假设当前集合 <code>nba</code> 的中的文档如下：</p>
<p>​<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e28”), “name” : “詹姆斯”, “number” : 6, “attribute” : { “h” : 203, “w” : 222, “p” : “前锋” }, “status” : “A” }<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e29”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e2a”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e2b”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e2c”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p>假设要过滤出 3 名球员信息，对应示例如下：</p>
<p>​<br>    &gt; db.nba.find().limit(3)<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e28”), “name” : “詹姆斯”, “number” : 6, “attribute” : { “h” : 203, “w” : 222, “p” : “前锋” }, “status” : “A” }<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e29”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d16d27c72f59731a7527e2a”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }</p>
<p><code>limit()</code> 可以接受小于 2^31 的正整数和大于 -2^31 的负整数，数字 0 也是有效的。<code>limit()</code> 中的数字取绝对值，也就是说<br><code>limit(3)</code> 和 <code>limit(-3)</code> 得到的结果是相同的。<code>limit(0)</code> 等效于 <code>not limit</code>，即未使用 <code>limit()</code>。</p>
<h4 id="迭代-Cursor"><a href="#迭代-Cursor" class="headerlink" title="迭代 Cursor"></a>迭代 Cursor</h4><p>在开始学习之前，我们需要准备一些数据，数据生成的命令如下：</p>
<p>​<br>    &gt; var i = 1;<br>    &gt; while(i&lt;1000){<br>    … db.fasp.insert({_id: i, name: “James-“ + i})<br>    … i++;<br>    … }</p>
<p>命令执行后，集合 <code>fasp</code> 中有 999 个文档。当我们执行 <code>db.fasp.find()</code> 命令时，会得到如下结果：</p>
<p>​<br>    &gt; db.fasp.find()<br>    { “_id” : 1, “name” : “James-1” }<br>    { “_id” : 2, “name” : “James-2” }<br>    { “_id” : 3, “name” : “James-3” }<br>    …<br>    { “_id” : 19, “name” : “James-19” }<br>    { “_id” : 20, “name” : “James-20” }<br>    Type “it” for more</p>
<p>它只显示 20 个文档，并提示我们输入 <code>it</code> 可以查看更多文档。此时输入 <code>it</code>，将会得到 <code>_id</code> 范围为 <code>21～40</code> 的文档，即每次只得到<br>20 个文档。</p>
<p>MongoShell 默认只返回 20 个文档，就算使用 <code>limit()</code> 方法也不行。如果想获取更多文档可以使用 <code>next()</code> 方法或者<br><code>forEach()</code>。对应命令如下：</p>
<p>​<br>    &gt; var Cursors = db.fasp.find();<br>    &gt; while (Cursors.hasNext()){<br>    … print(tojson(Cursors.next()));<br>    … }<br>    { “_id” : 1, “name” : “James-1” }<br>    { “_id” : 2, “name” : “James-2” }<br>    { “_id” : 3, “name” : “James-3” }<br>    …<br>    { “_id” : 998, “name” : “James-998” }<br>    { “_id” : 999, “name” : “James-999” }</p>
<p>其中，<code>hasNext()</code> 方法用于检查是否还存在下一个文档，<code>next()</code> 的作用是取出下一个文档。<code>forEach()</code> 的语法如下：</p>
<p>​<br>    db.collection.find().forEach(<function>)</function></p>
<p>使用 <code>forEach()</code> 遍历 <code>Cursor</code> 对象的示例如下：</p>
<p>​<br>    &gt; var Cursors = db.fasp.find();<br>    &gt; Cursors.forEach(printjson);<br>    { “_id” : 1, “name” : “James-1” }<br>    { “_id” : 2, “name” : “James-2” }<br>    { “_id” : 3, “name” : “James-3” }<br>    …<br>    { “_id” : 998, “name” : “James-998” }<br>    { “_id” : 999, “name” : “James-999” }</p>
<p>也就是说，<code>forEach()</code> 中的 <code>&lt;function&gt;</code> 会作用于每一个文档，例如在遍历的过程中打印 <code>name</code> 字段的值：</p>
<p>​<br>    &gt; var Cursors = db.fasp.find();<br>    &gt; Cursors.forEach(function(n){print(n.name)})<br>    James-1<br>    James-2<br>    James-3<br>    …<br>    James-999</p>
<p>除此之外，我们还可以使用 <code>toArray()</code> 方法迭代 <code>Cursor</code> 对象。<code>toArray()</code><br>方法会将文档装载到数组中，接着我们就可以使用数组下标访问文档了，对应示例如下：</p>
<p>​<br>    &gt; var Cursors = db.fasp.find();<br>    &gt; Cursors.toArray()[5];<br>    { “_id” : 6, “name” : “James-6” }</p>
<h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>有时候我们只想获取集合中文档的数量，而不是获取集合中的文档。这时候可以使用 <code>size()</code> 方法和 <code>count()</code> 方法，对应示例如下：</p>
<p>​<br>    &gt; db.fasp.find().size()<br>    999<br>    &gt; db.fasp.find().count()<br>    999</p>
<p>既然它们的都能获取文档数量，那为什么还需要两个方法呢？</p>
<p>实际上 <code>size()</code> 会受到 <code>skip()</code> 或 <code>limit()</code> 的影响，举个例子：</p>
<p>​<br>    &gt; db.fasp.find().limit(800).count()<br>    999<br>    &gt; db.fasp.find().limit(800).size()<br>    800</p>
<p><code>size()</code> 返回的是使用过 <code>skip()</code> 或 <code>limit()</code> 之后的文档数量，而 <code>count()</code> 返回的始终是集合中文档的数量。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>在学习迭代 Cursor 的时候提到了 <code>forEach()</code>，<code>map()</code> 的作用与之相似。<code>map()</code>示例如下：</p>
<p>​<br>    &gt; db.fasp.find().map( function(n) { return n.name} )<br>    [<br>        “James-1”,<br>        “James-2”,<br>        “James-3”,<br>        …,<br>        “James-999”,<br>    ]</p>
<p>与 <code>forEach()</code> 不同的是，<code>map()</code> 会将函数返回值装载到数组中。如果 <code>map()</code> 中的 <code>&lt;function&gt;</code> 没有<br><code>return</code>，那么数组中得到的将是 <code>undefined</code>。</p>
<h4 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a>Skip</h4><p>SQL 中使用 <code>offset</code> 控制数据返回的起始位置，常见的场景是分页。MongoDB 中具有相同功能的方法是 <code>skip()</code>，示例如下：</p>
<p>​<br>    &gt; db.fasp.find().skip(990)<br>    { “_id” : 991, “name” : “James-991” }<br>    { “_id” : 992, “name” : “James-992” }<br>    { “_id” : 993, “name” : “James-993” }<br>    { “_id” : 994, “name” : “James-994” }<br>    { “_id” : 995, “name” : “James-995” }<br>    { “_id” : 996, “name” : “James-996” }<br>    { “_id” : 997, “name” : “James-997” }<br>    { “_id” : 998, “name” : “James-998” }<br>    { “_id” : 999, “name” : “James-999” }</p>
<p><code>skip(990)</code> 代表数据返回的起始位置为 990。<code>skip()</code> 可以跟 <code>limit()</code> 共同使用，假设要从 990 开始，提取 3<br>个文档，对应示例如下：</p>
<p>​<br>    &gt; db.fasp.find().skip(990).limit(3)<br>    { “_id” : 991, “name” : “James-991” }<br>    { “_id” : 992, “name” : “James-992” }<br>    { “_id” : 993, “name” : “James-993” }</p>
<p>在命令中，<code>skip()</code> 和 <code>limit()</code> 的顺序并不会影响结果，<code>limit(3).skip(990)</code> 得到的结果与<br><code>skip(990).limit(3)</code> 相同。</p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>排序是最常见也最重要的操作。MongoDB 提供了 <code>sort()</code> 用于排序，其语法格式如下：</p>
<p>​<br>    { field: value }</p>
<p><code>sort()</code> 的升序降序用数字 <code>1</code> 和 <code>-1</code> 表示。假设要根据 <code>_id</code> 进行降序排序，对应示例如下：</p>
<p>​<br>    &gt; db.fasp.find().sort({_id: -1})<br>    { “_id” : 999, “name” : “James-999” }<br>    …<br>    { “_id” : 980, “name” : “James-980” }<br>    Type “it” for more</p>
<p><code>sort()</code> 支持多条件排序，例如 <code>sort(_id: 1, name:
-1)</code>。排序必定有比较，例如数字大小对应正序降序。那其他类型如何排序呢？MongoDB 在比较不同的 BOSN 类型时，将使用以下比较顺序，顺序从低到高：</p>
<ol>
<li>MinKey (internal type)</li>
<li>Null</li>
<li>Numbers (ints, longs, doubles, decimals)</li>
<li>Symbol, String</li>
<li>Object</li>
<li>Array</li>
<li>BinData</li>
<li>ObjectId</li>
<li>Boolean</li>
<li>Date</li>
<li>Timestamp</li>
<li>Regular Expression</li>
<li>MaxKey (internal type)</li>
</ol>
<h3 id="Update-Operations"><a href="#Update-Operations" class="headerlink" title="Update Operations"></a>Update Operations</h3><p>MongoDB 提供了几个方法用于更新文档，它们分别是：</p>
<p>​<br>    db.collection.updateOne(<filter>, <update>, <options>)<br>    db.collection.updateMany(<filter>, <update>, <options>)<br>    db.collection.replaceOne(<filter>, <update>, <options>)</options></update></filter></options></update></filter></options></update></filter></p>
<h4 id="更新单个文档"><a href="#更新单个文档" class="headerlink" title="更新单个文档"></a>更新单个文档</h4><p><code>updateOne()</code> 方法会根据过滤器更新集合中的单个文档，其语法格式如下：</p>
<p>​<br>    db.collection.updateOne(<br>       <filter>,<br>       <update>,<br>       {<br>         upsert: <boolean>,<br>         writeConcern: <document>,<br>         collation: <document>,<br>         arrayFilters: [ <filterdocument1>, … ]<br>       }<br>    )</filterdocument1></document></document></boolean></update></filter></p>
<p>例如将 <code>inven</code> 集合中名为 <code>韦德</code> 的球员名称改为 <code>热火韦德</code>，对应示例如下：</p>
<p>​<br>    &gt; db.inven.updateOne(<br>    … {name: “韦德”},<br>    … {$set: {name: “热火韦德”}}<br>    … )<br>    { “acknowledged” : true, “matchedCount” : 1, “modifiedCount” : 1 }</p>
<p>返回的结果文档包含操作状态 <code>acknowledged</code>，匹配的文档数 <code>matchedCount</code> 和修改过的文档数<br><code>modifiedCount</code>。本次返回结果文档代表修改成功，<code>韦德</code> 的名字被改变了。</p>
<h4 id="Upsert"><a href="#Upsert" class="headerlink" title="Upsert"></a>Upsert</h4><p>在实际应用中，<code>upsert</code> 指令非常常见。当 <code>upsert</code> 的值为 <code>true</code> 时，如果 <code>&lt;filter&gt;</code><br>并匹配到文档，那么本次操作就会将它当作新文档添加到集合中。例如当文档中没有名为 <code>ABC</code> 的球员时，会将 <code>奥尼尔</code> 添加到集合中，对应示例如下：</p>
<p>​<br>    &gt; db.inven.updateOne( {name: “ABC”}, {$set: {name: “奥尼尔”}}, {upsert: true})<br>    {<br>        “acknowledged” : true,<br>        “matchedCount” : 0,<br>        “modifiedCount” : 0,<br>        “upsertedId” : ObjectId(“5d15d6c718f0856b4385c123”)<br>    }</p>
<p>结果文档显示本次操作未匹配到文档，也未更新文档，但操作成功。相对于上一次的结果文档，本次结果文档中多出了 <code>upsertedId</code>，这正是 <code>奥尼尔</code><br>文档的 <code>_id</code>。我们可以通过 <code>find()</code> 方法来验证：</p>
<p>​<br>    &gt; db.inven.find({name: “奥尼尔”})<br>    { “_id” : ObjectId(“5d15d6c718f0856b4385c123”), “name” : “奥尼尔” }</p>
<p>果然， <code>奥尼尔</code> 被添加到集合中。</p>
<h4 id="更新多个文档"><a href="#更新多个文档" class="headerlink" title="更新多个文档"></a>更新多个文档</h4><p><code>updateMany()</code> 方法可以更新多个文档，其语法格式与 <code>updateOne()</code> 相同。假设要将球衣号大于 20 的所有球员球衣号设置为<br>33，对示例如下：</p>
<p>​<br>    &gt; db.inven.updateMany(<br>    … {number: {$gt: 20}},<br>    … {$set: {number: 33}}<br>    … )<br>    { “acknowledged” : true, “matchedCount” : 2, “modifiedCount” : 2 }</p>
<p>其他指令如 <code>upsert</code> 使用时与之前相同。</p>
<p><code>update()</code> 方法的语法格式与 <code>updateOne()</code> 相同，但它默认只更新单个文档。假设要将球衣号等于 33 的球员球衣号设置为<br>0，对应示例如下：</p>
<p>​<br>    &gt; db.inven.update( {number: {$eq: 33}}, {$set: {number: 0}} )<br>    WriteResult({ “nMatched” : 1, “nUpserted” : 0, “nModified” : 1 })</p>
<p>返回文档显示只更新了 1 个文档，其他查询符合条件的文档并未被更新。如果想要更新多个文档，可以将指令 <code>multi</code> 设置为 <code>true</code>，或者使用<br><code>updateMany()</code>。</p>
<h4 id="替换文档"><a href="#替换文档" class="headerlink" title="替换文档"></a>替换文档</h4><p><code>replaceOne()</code> 方法会根据过滤器替换集合中的单个文档，其语法如下：</p>
<p>​<br>    db.collection.replaceOne(<br>       <filter>,<br>       <replacement>,<br>       {<br>         upsert: <boolean>,<br>         writeConcern: <document>,<br>         collation: <document><br>       }<br>    )</document></document></boolean></replacement></filter></p>
<p>假设要为 <code>奥尼尔</code> 添加球衣号，对应示例如下：</p>
<p>​<br>    &gt; db.inven.replaceOne( {name: “奥尼尔”}, {name: “奥尼尔”, number: 34})<br>    { “acknowledged” : true, “matchedCount” : 1, “modifiedCount” : 1 }</p>
<p>命令执行后，<code>奥尼尔</code> 文档从 <code>{name: &quot;奥尼尔&quot;}</code> 变成了 <code>{name: &quot;奥尼尔&quot;, number: 34}</code>。</p>
<h4 id="Save"><a href="#Save" class="headerlink" title="Save"></a>Save</h4><p><code>save()</code> 是一个多用途的方法，它会根据 <code>_id</code> 是否存在而选择调用 <code>insert()</code> 或者 <code>update()</code>。当文档中存在 <code>_id</code><br>时，<code>save()</code> 等效于带有 <code>upsert</code> 指令的 <code>update()</code>；当文档中不包含 <code>_id</code> 时，<code>save()</code> 等效于<br><code>insert()</code>，此时 MongoShell 将创建一个 <code>ObjectId</code>，并将其分配给 <code>_id</code>。<code>save()</code> 的语法格式如下：</p>
<p>​<br>    db.collection.save(<br>       <document>,<br>       {<br>         writeConcern: <document><br>       }<br>    )</document></document></p>
<p><code>奥尼尔</code> 的 <code>_id</code> 为 <code>ObjectId(&quot;5d16c699dca60c968c6d8f69&quot;)</code>，当 <code>save()</code> 方法中的文档包含<br><code>_id</code> 时会更新文档内容，对应示例如下：</p>
<p>​<br>    &gt; db.inven.save({_id: “5d16c699dca60c968c6d8f69”, name: “奥尼尔”, status: “R”})<br>    WriteResult({<br>        “nMatched” : 0,<br>        “nUpserted” : 1,<br>        “nModified” : 0,<br>        “_id” : “5d16c699dca60c968c6d8f69”<br>    })</p>
<p><code>{&quot;name&quot; : &quot;奥尼尔&quot; }</code> 变成了 <code>{&quot;name&quot; : &quot;奥尼尔&quot;, &quot;status&quot; : &quot;R&quot;
}</code>。要注意的是，<code>ObjectId(&quot;5d16c699dca60c968c6d8f69&quot;)</code> 在命令中的写法是<br><code>&quot;5d16c699dca60c968c6d8f69&quot;</code>。</p>
<h4 id="更新操作符"><a href="#更新操作符" class="headerlink" title="更新操作符"></a>更新操作符</h4><p>MongoDB 共有四类更新操作符，它们是：字段更新操作符、数组更新操作符、修饰操作符和按位操作符。</p>
<h5 id="字段更新操作符"><a href="#字段更新操作符" class="headerlink" title="字段更新操作符"></a>字段更新操作符</h5><p>MongoDB 中共有 9 个字段更新操作符，它们分别是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/currentDate/#up._S_currentDate" target="_blank" rel="noopener"><code>$currentDate</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将字段的值设置为当前日期，可以是 <code>Date</code> 或 <code>Timestamp</code>。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/inc/#up._S_inc" target="_blank" rel="noopener"><code>$inc</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将指定字段的值与传入的值相加。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/min/#up._S_min" target="_blank" rel="noopener"><code>$min</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>仅当指定的值小于现有字段值时才更新字段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/max/#up._S_max" target="_blank" rel="noopener"><code>$max</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>仅当指定的值大于现有字段值时才更新字段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/mul/#up._S_mul" target="_blank" rel="noopener"><code>$mul</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将指定字段的值与传入的值相乘。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/rename/#up._S_rename" target="_blank" rel="noopener"><code>$rename</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>重命名字段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/set/#up._S_set" target="_blank" rel="noopener"><code>$set</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>设置文档中字段的值。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/setOnInsert/#up._S_setOnInsert" target="_blank" rel="noopener"><code>$setOnInsert</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>如果更新导致文档插入，则设置字段的值。对修改现有文档的更新操作没有影响。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/unset/#up._S_unset" target="_blank" rel="noopener"><code>$unset</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>从文档中删除指定的字段。</td>
</tr>
</tbody></table>
<p>我们将在本节中挑选几个典型的字段更新操作符进行学习，对于作用相似或语法类似的将不作赘述。例如 <code>$min</code> 和 <code>$max</code>，我们只需要了解其中一个即可。</p>
<p><strong>currentDate</strong></p>
<p><code>$currentDate</code> 的作用是将字段的值设为当前日期，其语法格式如下：</p>
<p>​<br>    { $currentDate: { <field1>: <typespecification1>, … } }</typespecification1></field1></p>
<p>其中，<code>&lt;typeSpecification1&gt;</code> 可以是一个布尔值、 <code>{$type: &quot;timestamp&quot;}</code> 或者 <code>{$type:
&quot;date&quot;}</code>。在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.registers.save({_id: 1, name: “async”, pwd: “123456”, regTime: new Date()})</p>
<p>此时，<code>regTime</code> 的值为 <code>ISODate(&quot;2019-07-10T08:40:02.253Z&quot;)</code>。假设要更新<br><code>regTime</code>的值，我们可以使用如下命令：</p>
<p>​<br>    &gt; db.registers.update(<br>    … {_id: 1},<br>    … {$currentDate:{regTime: true}<br>    … })</p>
<p>命令执行后，<code>regTime</code> 的值就会被改变，新的文档内容类似于：</p>
<p>​<br>    { “_id” : 1, “name” : “async”, “pwd” : “123456”, “regTime” : ISODate(“2019-07-10T08:43:24.981Z”) }</p>
<p>当然，我们也可以使用 <code>{$type: &quot;timestamp&quot;}</code> 这种语法，命令如下：</p>
<p>​<br>    &gt; db.registers.update(<br>    … {_id: 1},<br>    … {$currentDate:{ regTime: {$type: “timestamp”}}<br>    … })</p>
<p>命令执行后，<code>regTime</code> 的值也会被改变。要注意的是，由于 <code>Date</code> 与 <code>Timestamp</code> 格式不同，所以 <code>regTime</code><br>的值的格式将由原来的 <code>ISODate</code> 变成 <code>Timestamp</code>。</p>
<p><strong>inc</strong></p>
<p><code>$inc</code> 的作用是按指定的数量增加字段的值，其语法格式如下：</p>
<p>​<br>    { $inc: { <field1>: <amount1>, <field2>: <amount2>, … } }</amount2></field2></amount1></field1></p>
<p>假设现在有一个这样的文档：</p>
<p>​<br>    {<br>      _id: 1,<br>      sku: “abc123”,<br>      quantity: 10,<br>      metrics: {<br>        orders: 2,<br>        ratings: 3.5<br>      }<br>    }</p>
<p>如果我们需要在此基础上将 <code>quantity</code> 和 <code>metrics.orders</code> 的值做加法，对应示例如下：</p>
<p>​<br>    db.products.update(<br>       { sku: “abc123” },<br>       { $inc: { quantity: -2, “metrics.orders”: 1 } }<br>    )</p>
<p>命令执行后，文档将会变成下面这样：</p>
<p>​<br>    {<br>       “_id” : 1,<br>       “sku” : “abc123”,<br>       “quantity” : 8,<br>       “metrics” : {<br>          “orders” : 3,<br>          “ratings” : 3.5<br>       }<br>    }</p>
<p>如果传入的不是数字，而是字符串或其它类型，我们将得到错误提示：</p>
<p>​<br>    &gt; db.products.update({sku: “abc123” },{$inc: {quantity: “async”}})<br>    WriteResult({<br>        “nMatched” : 0,<br>        “nUpserted” : 0,<br>        “nModified” : 0,<br>        “writeError” : {<br>            “code” : 14,<br>            “errmsg” : “Cannot increment with non-numeric argument: {quantity: &quot;async&quot;}”<br>        }<br>    })</p>
<p><code>$mul</code> 的作用是将指定字段的值与传入的值相乘，这与 <code>$inc</code> 类似，此处不再赘述。<code>$mul</code> 的语法和介绍可查阅官方文档<br><a href="https://docs.mongodb.com/manual/reference/operator/update/mul/#mul" target="_blank" rel="noopener">$mul</a>。</p>
<p><strong>min</strong></p>
<p><code>$min</code> 的描述是“仅当指定的值小于现有字段值时才更新字段”，其语法格式如下：</p>
<p>​<br>    { $min: { <field1>: <value1>, … } }</value1></field1></p>
<p>假设有以下数据：</p>
<p>​<br>    { _id: 1, highScore: 800, lowScore: 200 }</p>
<p>最高分 <code>highScore</code> 为 <code>800</code>，最低分 <code>lowScore</code> 为 <code>200</code>。以下 <code>$min</code> 操作将用指定的 <code>150</code> 与 <code>200</code><br>进行比对，由于 <code>150 &lt; 200</code>，原文档中 <code>lowScore</code> 的值会被更新为指定的 <code>150</code>。更新语句如下：</p>
<p>​<br>    &gt; db.scores.update( { _id: 1 }, { $min: { lowScore: 250 } } )</p>
<p>命令执行后，文档将会变成：</p>
<p>​<br>    { _id: 1, highScore: 800, lowScore: 150 }</p>
<p>示例中只演示了数字类型的比较，实际上 BSON 都可以进行比较，比较顺序参考 [BSON comparison<br>order](<a href="https://docs.mongodb.com/manual/reference/bson-type-comparison-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/bson-type-comparison-</a><br>order/#faq-dev-compare-order-for-bson-types)。<code>$max</code><br>将指定值与现有字段值进行比较，如果指定值大于现有字段值，则更新对应字段值。这与 <code>$min</code> 类似，此处不再赘述。<code>$max</code> 的语法和介绍可查阅官方文档<br><a href="https://docs.mongodb.com/manual/reference/operator/update/max/#max" target="_blank" rel="noopener">$max</a>。</p>
<p><strong>unset</strong></p>
<p><code>$unset</code> 的作用是删除文档中的指定字段，其语法格式如下：</p>
<p>​<br>    { $unset: { <field1>: “”, … } }</field1></p>
<p>集合 <code>products</code> 中的文档如下：</p>
<p>​<br>    { “_id” : 1, “sku” : “abc123”, “quantity” : 8, “metrics” : { “orders” : 3, “ratings” : 3.5 } }</p>
<p>假设要删除 <code>quantity</code> 字段，对应示例如下：</p>
<p>​<br>    &gt; db.products.update(<br>    … {_id: 1},<br>    … {$unset: {quantity: “”}}<br>    … )</p>
<p>命令执行后，文档内容将会变成下面这样：</p>
<p>​<br>    { “_id” : 1, “sku” : “abc123”, “metrics” : { “orders” : 3, “ratings” : 3.5 } }</p>
<p>对比命令执行前后的结果可以看出，字段 <code>quantity</code> 已被成功删除。<code>$set</code> 与 <code>$unset</code> 语法类似，此处不再赘述。<code>$set</code><br>的具体介绍可查阅官方文档<br><a href="https://docs.mongodb.com/manual/reference/operator/update/set/#set" target="_blank" rel="noopener">$set</a>。</p>
<h5 id="数组更新操作符"><a href="#数组更新操作符" class="headerlink" title="数组更新操作符"></a>数组更新操作符</h5><p>MongoDB 中共有 8 个数组更新操作符，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/positional/#up._S_" target="_blank" rel="noopener"><code>$</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>充当占位符以更新与查询条件匹配的第一个元素。</td>
</tr>
<tr>
<td>[<code>$[]</code>](<a href="https://docs.mongodb.com/manual/reference/operator/update/positional-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/update/positional-</a></td>
<td></td>
</tr>
<tr>
<td>all/#up.<em>S</em>[])</td>
<td>充当占位符以更新数组中与查询条件匹配的文档中的所有元素。</td>
</tr>
<tr>
<td>[<code>$[&lt;identifier&gt;]</code>](<a href="https://docs.mongodb.com/manual/reference/operator/update/positional-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/update/positional-</a></td>
<td></td>
</tr>
<tr>
<td>filtered/#up.<em>S</em>[])</td>
<td>充当占位符以更新与 <code>arrayFilters</code>匹配查询条件的文档的条件匹配的所有元素。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/addToSet/#up._S_addToSet" target="_blank" rel="noopener"><code>$addToSet</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>仅当数组中尚不存在元素时才将元素添加到数组中。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/pop/#up._S_pop" target="_blank" rel="noopener"><code>$pop</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>删除数组的第一个或最后一个元素。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/pull/#up._S_pull" target="_blank" rel="noopener"><code>$pull</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>删除与指定查询匹配的所有数组元素。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/push/#up._S_push" target="_blank" rel="noopener"><code>$push</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将元素添加到数组。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/pullAll/#up._S_pullAll" target="_blank" rel="noopener"><code>$pullAll</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>从数组中删除所有匹配的值。</td>
</tr>
</tbody></table>
<p>我们将在本节中挑选两个个常用的数组更新操作符进行学习，例如 <code>$pop</code> 和 <code>$push</code></p>
<p><strong>pop</strong></p>
<p><code>$pop</code> 的作用是删除数组的第一个或最后一个元素，其语法格式如下：</p>
<p>​<br>    { $pop: { <field>: &lt;-1 | 1&gt;, … } }</field></p>
<p>假设现在有一个这样的文档：</p>
<p>​<br>    { _id: 1, scores: [ 8, 9, 10 ] }</p>
<p>文档中字段 <code>scores</code> 的值是一个数组。当我们需要删除 <code>scores</code> 中的第一个元素时，执行以下命令：</p>
<p>​<br>    &gt; db.collection.update( { _id: 1 }, { $pop: { scores: -1 } } )</p>
<p>命令执行后，文档将会变成：</p>
<p>​<br>    { “_id” : 1, “scores” : [ 9, 10 ] }</p>
<p>当我们要删除最后一个元素时，执行以下命令：</p>
<p>​<br>    &gt; db.collection.update( { _id: 1 }, { $pop: { scores: 1 } } )</p>
<p>命令执行后，文档将会变成：</p>
<p>​<br>    { “_id” : 1, “scores” : [ 9] }</p>
<p>如果将数组元素的排序看成从左到右，那么 <code>{$pop: { &lt;field&gt;: -1}}</code> 删除的是最左的元素，而 <code>{$pop: { &lt;field&gt;:
1}}</code> 删除的是最右的元素。</p>
<p><strong>push</strong></p>
<p><code>$push</code> 的作用是将元素添加到数组，其语法格式如下：</p>
<p>​<br>    { $push: { <field1>: <value1>, … } }</value1></field1></p>
<p>假设现在有一个这样的文档：</p>
<p>​<br>    { _id: 1, scores: [ 8, 9, 10 ] }</p>
<p>文档中字段 <code>scores</code> 的值是一个数组。当我们需要将 <code>100</code> 添加到 <code>scores</code> 中时，执行以下命令：</p>
<p>​<br>    &gt; db.collection.update({_id: 1}, {$push: {scores: 100}})</p>
<p>命令执行后，文档将会变成：</p>
<p>​<br>    { _id: 1, scores: [ 8, 9, 10, 100 ] }</p>
<p>但如果要添加的元素是一个数组，而不是一个数值呢？假设要将 <code>200, 300</code> 添加到数组 <code>scores</code> 中，希望得到的结果是 <code>{ _id: 1,
scores: [ 8, 9, 10, 100, 200, 300 ] }</code>，我们应该怎么做？用与上面相同的命令：</p>
<p>​<br>    &gt; db.collection.update({_id: 1}, {$push: {scores: [200, 300]}})</p>
<p>命令执行后，将会得到如下结果：</p>
<p>​<br>    { _id: 1, scores: [ 8, 9, 10, 100, [200, 300] ] }</p>
<p>换一种命令：</p>
<p>​<br>    &gt; db.collection.update({_id: 1}, {$push: {scores: 200, 300}})</p>
<p>得到的却是错误提示。实际上，MongoDB 提供了一些更新操作修饰符，用于丰富更新操作。在这个需求中，我们可以使用更新操作修饰符 <code>$each</code><br>帮助我们完成任务。</p>
<p>更新操作符并不复杂，此处不再进行其它更新操作符的介绍，读者可查阅官方文档 [Update<br>Operators](<a href="https://docs.mongodb.com/manual/reference/operator/update-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/update-</a><br>array/#update-operators)。接下来，我们将学习更新操作修饰符的相关知识。</p>
<h5 id="更新操作修饰符"><a href="#更新操作修饰符" class="headerlink" title="更新操作修饰符"></a>更新操作修饰符</h5><p>MongoDB 中的更新操作修饰符共有 4 个，它们是：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/each/#up._S_each" target="_blank" rel="noopener"><code>$each</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>修饰</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/push/#up._S_push" target="_blank" rel="noopener"><code>$push</code></a></td>
<td></td>
</tr>
<tr>
<td>和</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/addToSet/#up._S_addToSet" target="_blank" rel="noopener"><code>$addToSet</code></a>操作符以附加多个项目以进行阵列更新。</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/position/#up._S_position" target="_blank" rel="noopener"><code>$position</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>修饰</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/push/#up._S_push" target="_blank" rel="noopener"><code>$push</code></a>操作符以指定数组中添加元素的位置。</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/slice/#up._S_slice" target="_blank" rel="noopener"><code>$slice</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>修饰</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/push/#up._S_push" target="_blank" rel="noopener"><code>$push</code></a>操作符以限制更新数组的大小。</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/sort/#up._S_sort" target="_blank" rel="noopener"><code>$sort</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>修饰</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/update/push/#up._S_push" target="_blank" rel="noopener"><code>$push</code></a></td>
<td></td>
</tr>
<tr>
<td>操作符以重新排序存储在数组中的文档。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>each</strong></p>
<p><code>$each</code> 的作用是修饰 <code>$push</code> 和 <code>$addToSet</code> 更新操作符，以附加多个元素。上一个小节中，我们的需求是将 <code>200, 300</code><br>添加到数组 <code>scores</code> 中，但添加结果却是 <code>[200, 300]</code> 。如果用 <code>$each</code> 修饰 <code>$push</code><br>操作符，就能够达到目的。对应示例如下：</p>
<p>​<br>    &gt; db.collection.update({_id: 1}, {$push: {scores:{$each: [200, 300]}}})</p>
<p>命令执行后，文档将会变成：</p>
<p>​<br>    { “_id” : 1, “scores” : [ 8, 9, 10, 100, [ 200, 300 ], 200, 300 ] }</p>
<p><strong>position</strong></p>
<p><code>$position</code> 的作用是修饰更新操作符 <code>$push</code> ，以指定元素添加时的位置。其语法格式如下：</p>
<p>​<br>    {<br>      $push: {<br>        <field>: {<br>           $each: [ <value1>, <value2>, … ],<br>           $position: <num><br>        }<br>      }<br>    }</num></value2></value1></field></p>
<p>以下示例中，<code>$position</code> 将与 <code>$each</code> 协同工作。假设要将 <code>15, 25</code> 插入到 <code>scores</code> 数组的第 1<br>个位置，对应示例如下：</p>
<p>​<br>    &gt; db.collection.update({_id: 1}, {$push: {scores:{$each: [15, 25], $position: 1}}})</p>
<p>命令执行后，文档将会变成：</p>
<p>​<br>    { “_id” : 1, “scores” : [ 8, 15, 25, 9, 10, 100, [ 200, 300 ], 200, 300 ] }</p>
<p><strong>小提示</strong> ：当 <code>$position</code> 为负数时，将会从右往左插入。</p>
<p>更新操作修饰符用于修饰更新操作符，使更新操作变得更灵活更丰富。<code>$sort</code> 和 <code>$slice</code> 的语法和具体用法可在官网查阅，此处不再赘述。</p>
<h5 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h5><p>MongoDB 中的按位操作符只有一个：<code>$bit</code>。它的作用是执行按位与、按位或和按位异或等操作，其语法格式如下：</p>
<p>​<br>    { $bit: { <field>: { &lt;and|or|xor&gt;: <int> } } }</int></field></p>
<p><strong>按位操作</strong></p>
<p>很多读者对按位操作都不熟悉，这里简单介绍一下。</p>
<ul>
<li>按位与操作将参与预算的两数各对应的二进位相与，只有对应的两个二进位均为 <code>1</code> 时，结果位才为 <code>1</code>。</li>
<li>按位或操作将参与预算的两数各对应的二进位相或，只要对应的两个二进位中有一个为 <code>1</code> 时，结果位就为 <code>1</code>。</li>
<li>按位异或操作参与预算的两数各对应的二进位相异或，对应的两个二进位中的值不相同时，结果位就为 <code>1</code>。</li>
</ul>
<p>如果想要全面了解位运算，可参考我在微信公众号【Rust之蝉】上发布的文章<br><a href="https://mp.weixin.qq.com/s?timestamp=1564496573&src=3&ver=1&signature=1RFLcJophxfaKFya80hnrAPOSUTbdN0qjtXBXZAeRkS943NRxi-91s2GikDxNsOr6xgVt9Rsp6mr6V2TDVJviVddLd8*pQEC2vEcfNQYTKufz6cYYKWFjcvrsgqgr9TA1nJF8gAyUn*Ez*tFic57SwQgc3HeNEXzEv869P3d50g=" target="_blank" rel="noopener">【七分钟全面了解位运算】</a>。</p>
<p>以数字 <code>5</code> 和 <code>9</code> 为例，进行按位与、按位或和按位异或操作演示。数字 <code>5</code> 对应的二进制为 <code>0101</code>，数字 <code>9</code> 对应的二进制为<br><code>1001</code>。二进位比对如下：</p>
<p>​<br>    0101<br>    1001</p>
<p>首先是按位与操作：只有对应的两个二进位均为 <code>1</code> 时，结果位才为 <code>1</code>，否则为 <code>0</code>。</p>
<p>​<br>    0101<br>    1001<br>    —-<br>    0001</p>
<p>所以按位与结果为 <code>0001</code>，对应的十进制为 <code>1</code>，即数字 <code>5</code> 和数字 <code>9</code> 按位与的结果为数字 <code>1</code>。</p>
<p>接着看看按位或操作：只要对应的两个二进位中有一个为 <code>1</code> 时，结果位为 <code>1</code>，否则为 <code>0</code>。</p>
<p>​<br>    0101<br>    1001<br>    —-<br>    1101</p>
<p>所以按位或的结果为 <code>1101</code>，对应的十进制为数字 <code>13</code>，即数字 <code>5</code> 和数字 <code>9</code> 按位或的结果为数字 <code>13</code>。</p>
<p>最后是按位异或操作： 对应的两个二进位中的值不相同时，结果位就为 <code>1</code>，否则为 <code>0</code>。</p>
<p>​<br>    0101<br>    1001<br>    —-<br>    1100</p>
<p>所以按位异或的结果为 <code>1100</code>，对应的十进制为 <code>12</code>，即数字 <code>5</code> 和数字 <code>9</code> 按位异或的结果为数字 <code>12</code>。</p>
<p><strong>bit</strong></p>
<p>假设有如下文档：</p>
<p>​<br>    { _id: 1, expdata: NumberInt(13) }</p>
<p>以下 <code>update</code> 操作将 <code>expdata</code> 字段值进行按位与更新：</p>
<p>​<br>    &gt; db.collection.update(<br>       { _id: 1 },<br>       { $bit: { expdata: { and: NumberInt(10) } } }<br>    )</p>
<p><code>13</code> 对应的进制为 <code>1101</code>，<code>10</code> 对应的二进制为 <code>1010</code>，<code>13</code> 和 <code>10</code> 的按位与操作如下：</p>
<p>​<br>    1101<br>    1010<br>    —-<br>    1000</p>
<p>二进制 <code>1000</code> 对应的十进制为 <code>8</code>。也就是说，更新操作执行后，文档将会变成：</p>
<p>​<br>    { “_id” : 1, “expdata” : 8 }</p>
<p>如果使用按位或，即 <code>or</code>，则文档将会变成：</p>
<p>​<br>    { “_id” : 1, “expdata” : 15 }</p>
<p>至此，更新操作符的相关知识我们已经学习完毕。</p>
<h3 id="DELETE-Operations"><a href="#DELETE-Operations" class="headerlink" title="DELETE Operations"></a>DELETE Operations</h3><p>MongoDB 提供了几个方法用于删除文档，它们是：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteMany/#db.collection.deleteMany" target="_blank" rel="noopener"><code>db.collection.deleteMany()</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteOne/#db.collection.deleteOne" target="_blank" rel="noopener"><code>db.collection.deleteOne()</code></a></li>
</ul>
<h4 id="删除单个文档"><a href="#删除单个文档" class="headerlink" title="删除单个文档"></a>删除单个文档</h4><p><code>deleteOne()</code> 方法会根据过滤器删除集合中的单个文档。假设我们希望从集合中删除 <code>奥尼尔</code>，对应命令如下：</p>
<p>​<br>    &gt; db.inven.deleteOne({name: “奥尼尔”})<br>    { “acknowledged” : true, “deletedCount” : 1 }</p>
<h4 id="删除多个文档"><a href="#删除多个文档" class="headerlink" title="删除多个文档"></a>删除多个文档</h4><p><code>deleteMany()</code> 方法会根据过滤器删除集合中的多个文档，甚至所有文档。例如我们希望删除集合 <code>inven</code> 中的所有文档，对应命令如下：</p>
<p>​<br>    &gt; db.inven.deleteMany({})<br>    { “acknowledged” : true, “deletedCount” : 5 }</p>
<p>要注意的是，删除操作并不会删除索引，即使我们删除了集合中的所有文档。</p>
<h3 id="文档的-CRUD-操作小结"><a href="#文档的-CRUD-操作小结" class="headerlink" title="文档的 CRUD 操作小结"></a>文档的 CRUD 操作小结</h3><p>以上就是 MongoDB 中文档 CURD 操作的介绍。内容篇幅较长，但经过本篇的学习，我们已经熟悉了 MongoDB<br>中常见的文档操作，能够很好地应对工作需要了。</p>
<h2 id="基础篇-二-流式聚合操作"><a href="#基础篇-二-流式聚合操作" class="headerlink" title="基础篇 二 流式聚合操作"></a>基础篇 二 流式聚合操作</h2><p>信息科学中的聚合是指对相关数据进行内容筛选、处理和归类并输出结果的过程。MongoDB<br>中的聚合是指同时对多个文档中的数据进行处理、筛选和归类并输出结果的过程。数据在聚合操作的过程中，就像是水流过一节一节的管道一样，所以 MongoDB<br>中的聚合又被人称为流式聚合。MongoDB 提供了几种聚合方式：</p>
<ul>
<li>Aggregation Pipeline </li>
<li>Map-Reduce</li>
<li>简单聚合</li>
</ul>
<p>接下来，我们将全方位地了解 MongoDB 中的聚合。</p>
<h3 id="Aggregation-Pipeline"><a href="#Aggregation-Pipeline" class="headerlink" title="Aggregation Pipeline"></a>Aggregation Pipeline</h3><p>Aggregation Pipeline 又称聚合管道。开发者可以将多个文档传入一个由多个 <code>Stage</code> 组成的 <code>Pipeline</code>，每一个<br><code>Stage</code> 处理的结果将会传入下一个 <code>Stage</code> 中，最后一个 <code>Stage</code> 的处理结果就是整个 <code>Pipeline</code> 的输出。</p>
<p>创建聚合管道的语法如下：</p>
<p>​<br>    db.collection.aggregate( [ { <stage> }, … ] )</stage></p>
<p>MongoDB 提供了 23 种 <code>Stage</code>，它们是：</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/#pipe._S_addFields" target="_blank" rel="noopener"><code>$addFields</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>向文档添加新字段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/bucket/#pipe._S_bucket" target="_blank" rel="noopener"><code>$bucket</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>根据指定的表达式和存储区边界将传入的文档分组。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/bucketAuto/#pipe._S_bucketAuto" target="_blank" rel="noopener"><code>$bucketAuto</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>根据指定的表达式将传入的文档分类为特定数量的组，自动确定存储区边界。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/collStats/#pipe._S_collStats" target="_blank" rel="noopener"><code>$collStats</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回有关集合或视图的统计信息。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/count/#pipe._S_count" target="_blank" rel="noopener"><code>$count</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回聚合管道此阶段的文档数量计数。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/facet/#pipe._S_facet" target="_blank" rel="noopener"><code>$facet</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>在同一组输入文档的单个阶段内处理多个聚合操作。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/#pipe._S_geoNear" target="_blank" rel="noopener"><code>$geoNear</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>基于与地理空间点的接近度返回有序的文档流。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup" target="_blank" rel="noopener"><code>$graphLookup</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>对集合执行递归搜索。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#pipe._S_group" target="_blank" rel="noopener"><code>$group</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>按指定的标识符表达式对文档进行分组。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/indexStats/#pipe._S_indexStats" target="_blank" rel="noopener"><code>$indexStats</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>返回集合的索引信息。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/limit/#pipe._S_limit" target="_blank" rel="noopener"><code>$limit</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将未修改的前 n 个文档传递给管道。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/listSessions/#pipe._S_listSessions" target="_blank" rel="noopener"><code>$listSessions</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>列出<code>system.sessions</code>集合的所有会话。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#pipe._S_lookup" target="_blank" rel="noopener"><code>$lookup</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>对同一数据库中的另一个集合执行左外连接。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match" target="_blank" rel="noopener"><code>$match</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>过滤文档，仅允许匹配的文档地传递到下一个管道阶段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#pipe._S_out" target="_blank" rel="noopener"><code>$out</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>将聚合管道的结果文档写入指定集合，它必须是管道中的最后一个阶段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#pipe._S_project" target="_blank" rel="noopener"><code>$project</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>为文档添加新字段或删除现有字段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/redact/#pipe._S_redact" target="_blank" rel="noopener"><code>$redact</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>可用于实现字段级别的编辑。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/replaceRoot/#pipe._S_replaceRoot" target="_blank" rel="noopener"><code>$replaceRoot</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>用指定的嵌入文档替换文档。该操作将替换输入文档中的所有现有字段，包括<code>_id</code>字段。指定嵌入在输入文档中的文档以将嵌入文档提升到顶层。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sample/#pipe._S_sample" target="_blank" rel="noopener"><code>$sample</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>从输入中随机选择指定数量的文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/skip/#pipe._S_skip" target="_blank" rel="noopener"><code>$skip</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>跳过前 n 个文档，并将未修改的其余文档传递到下一个阶段。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sort/#pipe._S_sort" target="_blank" rel="noopener"><code>$sort</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>按指定的排序键重新排序文档流。只有订单改变; 文件保持不变。对于每个输入文档，输出一个文档。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/#pipe._S_sortByCount" target="_blank" rel="noopener"><code>$sortByCount</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>对传入文档进行分组，然后计算每个不同组中的文档计数。</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#pipe._S_unwind" target="_blank" rel="noopener"><code>$unwind</code></a></td>
<td></td>
</tr>
<tr>
<td></td>
<td>解构文档中的数组字段。</td>
</tr>
</tbody></table>
<p>文档、<code>Stage</code> 和 <code>Pipeline</code> 的关系如下图所示：</p>
<p><img src="https://images.gitbook.cn/11d4cfe0-be88-11e9-bb6f-13203c9ddaa7" alt="在这里插入图片描述"><br>上图描述了文档经过 <code>$match</code>、<code>$sample</code> 和 <code>$project</code> 等三个 <code>Stage</code> 并输出的过程。SQL 中常见的聚合术语有<br><code>WHERE</code>、<code>SUM</code> 和 <code>COUNT</code> 等。下表描述了常见的 SQL 聚合术语、函数和概念以及对应的 MongoDB 操作符或 <code>Stage</code>。</p>
<table>
<thead>
<tr>
<th>SQL</th>
<th>MongoDB</th>
</tr>
</thead>
<tbody><tr>
<td>WHERE</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match" target="_blank" rel="noopener"><code>$match</code></a></td>
<td></td>
</tr>
<tr>
<td>GROUP BY</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#pipe._S_group" target="_blank" rel="noopener"><code>$group</code></a></td>
<td></td>
</tr>
<tr>
<td>HAVING</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/match/#pipe._S_match" target="_blank" rel="noopener"><code>$match</code></a></td>
<td></td>
</tr>
<tr>
<td>SELECT</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#pipe._S_project" target="_blank" rel="noopener"><code>$project</code></a></td>
<td></td>
</tr>
<tr>
<td>ORDER BY</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sort/#pipe._S_sort" target="_blank" rel="noopener"><code>$sort</code></a></td>
<td></td>
</tr>
<tr>
<td>LIMIT</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/limit/#pipe._S_limit" target="_blank" rel="noopener"><code>$limit</code></a></td>
<td></td>
</tr>
<tr>
<td>SUM()</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sum/#grp._S_sum" target="_blank" rel="noopener"><code>$sum</code></a></td>
<td></td>
</tr>
<tr>
<td>COUNT()</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sum/#grp._S_sum" target="_blank" rel="noopener"><code>$sum</code></a><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/#pipe._S_sortByCount" target="_blank" rel="noopener"><code>$sortByCount</code></a></td>
<td></td>
</tr>
<tr>
<td>join</td>
<td></td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#pipe._S_lookup" target="_blank" rel="noopener"><code>$lookup</code></a></td>
<td></td>
</tr>
</tbody></table>
<p>下面，我们将通过示例了解 <code>Aggregate</code>、 <code>Stage</code> 和 <code>Pipeline</code> 之间的关系。</p>
<h4 id="概念浅出"><a href="#概念浅出" class="headerlink" title="概念浅出"></a>概念浅出</h4><p><code>$match</code> 的描述为“过滤文档，仅允许匹配的文档地传递到下一个管道阶段”。其语法格式如下：</p>
<p>​<br>    { $match: { <query> } }</query></p>
<p>在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.artic.insertMany([<br>    … { “_id” : 1, “author” : “dave”, “score” : 80, “views” : 100 },<br>    … { “_id” : 2, “author” : “dave”, “score” : 85, “views” : 521 },<br>    … { “_id” : 3, “author” : “anna”, “score” : 60, “views” : 706 },<br>    … { “_id” : 4, “author” : “line”, “score” : 55, “views” : 300 }<br>    … ])</p>
<p>然后我们建立只有一个 <code>Stage</code> 的 <code>Pipeline</code>，以实现过滤出 <code>author</code> 为 <code>dave</code> 的文档。对应示例如下：</p>
<p>​<br>    &gt; db.artic.aggregate([<br>    … {$match: {author: “dave”}}<br>    … ])<br>    { “_id” : 1, “author” : “dave”, “score” : 80, “views” : 100 }<br>    { “_id” : 2, “author” : “dave”, “score” : 85, “views” : 521 }</p>
<p>如果要建立有两个 <code>Stage</code> 的 <code>Pipeline</code>，那么就在 <code>aggregate</code> 中添加一个 <code>Stage</code> 即可。现在有这样一个需求：统计集合<br><code>artic</code> 中 <code>score</code> 大于 <code>70</code> 且小于 <code>90</code> 的文档数量。这个需求分为两步进行：</p>
<ul>
<li>过滤出符合要求的文档</li>
<li>统计文档数量</li>
</ul>
<p>Aggregation 非常适合这种多步骤的操作。在这个场景中，我们需要用到 <code>$match</code>、<code>$group</code> 这两个 <code>Stage</code><br>，然后再与聚合表达式 <code>$sum</code> 相结合，对应示例如下：</p>
<p>​<br>    &gt; db.artic.aggregate([<br>    … {$match: {score: {$gt: 70, $lt: 90}}},<br>    … {$group: {_id: null, number: {$sum: 1}}}<br>    … ])<br>    { “_id” : null, “number” : 2 }</p>
<p>这个示例的完整过程可以用下图表示：<br><img src="https://images.gitbook.cn/37744ff0-be88-11e9-bb6f-13203c9ddaa7" alt="在这里插入图片描述"><br>通过上面的描述和举例，我相信你对 <code>Aggregate</code>、 <code>Stage</code> 和 <code>Pipeline</code> 有了一定的了解。接下来，我们将学习常见的<br><code>Stage</code> 的语法和用途。</p>
<h4 id="常见的-Stage"><a href="#常见的-Stage" class="headerlink" title="常见的 Stage"></a>常见的 Stage</h4><p><strong>sample</strong></p>
<p><code>$sample</code> 的作用是从输入中随机选择指定数量的文档，其语法格式如下：</p>
<p>​<br>    { $sample: { size: <positive integer> } }</positive></p>
<p>假设要从集合 <code>artic</code> 中随机选择两个文档，对应示例如下：</p>
<p>​<br>    &gt; db.artic.aggregate([<br>    … {$sample: {size: 2}}<br>    … ])<br>    { “_id” : 1, “author” : “dave”, “score” : 80, “views” : 100 }<br>    { “_id” : 3, “author” : “anna”, “score” : 60, “views” : 706 }</p>
<p><code>size</code> 对应的值必须是正整数，如果输入负数会得到错误提示：<code>size argument to $sample must not be
negative</code>。要注意的是，当值超过集合中的文档数量时，返回结果是集合中的所有文档，但文档顺序是随机的。</p>
<p><strong>project</strong></p>
<p><code>$project</code> 的作用是过滤文档中的字段，这与投影操作相似，但处理结果将会传入到下一个阶段 。其语法格式如下：</p>
<p>​<br>    { $project: { &lt;specification(s)&gt; } }</p>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.projects.save(<br>        {_id: 1, title: “篮球训练营青春校园活动开始啦”, numb: “A829Sck23”, author: {last: “quinn”, first: “James”}, hot: 35}<br>    )</p>
<p>假设 <code>Pipeline</code> 中的下一个 <code>Stage</code> 只需要文档中的 <code>title</code> 和 <code>author</code> 字段，对应示例如下：</p>
<p>​<br>    &gt; db.projects.aggregate([{$project: {title: 1, author: 1}}])<br>    { “_id” : 1, “title” : “篮球训练营青春校园活动开始啦”, “author” : { “last” : “quinn”, “first” : “James” } }</p>
<p><code>0</code> 和 <code>1</code> 可以同时存在。对应示例如下：</p>
<p>​<br>    &gt; db.projects.aggregate([{$project: {title: 1, author: 1, _id: 0}}])<br>    { “title” : “篮球训练营青春校园活动开始啦”, “author” : { “last” : “quinn”, “first” : “James” } }</p>
<p><code>true</code> 等效于 <code>1</code>，<code>false</code> 等效于 <code>0</code>，也可以混用布尔值和数字，对应示例如下：</p>
<p>​<br>    &gt; db.projects.aggregate([{$project: {title: 1, author: true, _id: false}}])<br>    { “title” : “篮球训练营青春校园活动开始啦”, “author” : { “last” : “quinn”, “first” : “James” } }</p>
<p>如果想要排除指定字段，那么在 <code>$project</code> 中将其设置为 <code>0</code> 或 <code>false</code> 即可，对应示例如下：</p>
<p>​<br>    &gt; db.projects.aggregate([{$project: {author: false, _id: false}}])<br>    { “title” : “篮球训练营青春校园活动开始啦”, “numb” : “A829Sck23”, “hot” : 35 }</p>
<p><code>$project</code> 也可以作用于嵌入式文档。对于 <code>author</code> 字段，有时候我们只需要 <code>FirstName</code> 或者 <code>Lastname</code><br>，对应示例如下：</p>
<p>​<br>    &gt; db.projects.aggregate([{$project: {author: {“last”: false}, _id: false, numb: 0}}])<br>    { “title” : “篮球训练营青春校园活动开始啦”, “author” : { “first” : “James” }, “hot” : 35 }</p>
<p>这里使用 <code>{author: {&quot;last&quot;: false}}</code> 过滤掉 <code>LastName</code>，但保留 <code>first</code>。</p>
<p>以上就是 <code>$project</code> 的基本用法和作用介绍，更多与 <code>$project</code> 相关的知识可查阅官方文档<br>[$project](<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/#project-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/project/#project-</a><br>aggregation)。</p>
<p><strong>lookup</strong></p>
<p><code>$lookup</code> 的作用是对同一数据库中的集合执行左外连接，其语法格式如下：</p>
<p>​<br>    {<br>       $lookup:<br>         {<br>           from: <collection to join>,<br>           localField: <field from the input documents>,<br>           foreignField: &lt;field from the documents of the “from” collection&gt;,<br>           as: <output array field><br>         }<br>    }</output></field></collection></p>
<p>左外连接类似与下面的伪 SQL 语句：</p>
<p>​<br>    SELECT *, <output array field><br>    FROM collection WHERE <output array field> IN (<br>    SELECT * FROM <collection to join> WHERE<br>    <foreignfield>= &lt;collection.localField&gt;);</foreignfield></collection></output></output></p>
<p><code>lookup</code> 支持的指令及对应描述如下：</p>
<table>
<thead>
<tr>
<th>领域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>from</code></td>
<td>指定集合名称。</td>
</tr>
<tr>
<td><code>localField</code></td>
<td>指定输入 <code>$lookup</code> 中的字段。</td>
</tr>
<tr>
<td><code>foreignField</code></td>
<td>指定<code>from</code> 给定的集合中的文档字段。</td>
</tr>
<tr>
<td><code>as</code></td>
<td>指定要添加到输入文档的新数组字段的名称。</td>
</tr>
<tr>
<td>新数组字段包含<code>from</code>集合中的匹配文档。</td>
<td></td>
</tr>
<tr>
<td>如果输入文档中已存在指定的名称，则会覆盖现有字段 。</td>
<td></td>
</tr>
</tbody></table>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.sav.insert([<br>       { “_id” : 1, “item” : “almonds”, “price” : 12, “quantity” : 2 },<br>       { “_id” : 2, “item” : “pecans”, “price” : 20, “quantity” : 1 },<br>       { “_id” : 3  }<br>    ])</p>
<pre><code>&gt; db.avi.insert([
   { &quot;_id&quot; : 1, &quot;sku&quot; : &quot;almonds&quot;, description: &quot;product 1&quot;, &quot;instock&quot; : 120 },
   { &quot;_id&quot; : 2, &quot;sku&quot; : &quot;bread&quot;, description: &quot;product 2&quot;, &quot;instock&quot; : 80 },
   { &quot;_id&quot; : 3, &quot;sku&quot; : &quot;cashews&quot;, description: &quot;product 3&quot;, &quot;instock&quot; : 60 },
   { &quot;_id&quot; : 4, &quot;sku&quot; : &quot;pecans&quot;, description: &quot;product 4&quot;, &quot;instock&quot; : 70 },
   { &quot;_id&quot; : 5, &quot;sku&quot;: null, description: &quot;Incomplete&quot; },
   { &quot;_id&quot; : 6 }
])</code></pre><p>假设要连接集合 <code>sav</code> 中的 <code>item</code> 和集合 <code>avi</code> 中的 <code>sku</code>，并将连接结果命名为 <code>savi</code>。对应示例如下：</p>
<p>​<br>    &gt; db.sav.aggregate([<br>       {<br>         $lookup:<br>           {<br>             from: “avi”,<br>             localField: “item”,<br>             foreignField: “sku”,<br>             as: “savi”<br>           }<br>      }<br>    ])</p>
<p>命令执行后，输出如下内容：</p>
<p>​<br>    {<br>       “_id” : 1,<br>       “item” : “almonds”,<br>       “price” : 12,<br>       “quantity” : 2,<br>       “savi” : [<br>          { “_id” : 1, “sku” : “almonds”, “description” : “product 1”, “instock” : 120 }<br>       ]<br>    }<br>    {<br>       “_id” : 2,<br>       “item” : “pecans”,<br>       “price” : 20,<br>       “quantity” : 1,<br>       “savi” : [<br>          { “_id” : 4, “sku” : “pecans”, “description” : “product 4”, “instock” : 70 }<br>       ]<br>    }<br>    {<br>       “_id” : 3,<br>       “savi” : [<br>          { “_id” : 5, “sku” : null, “description” : “Incomplete” },<br>          { “_id” : 6 }<br>       ]<br>    }</p>
<p>上面的连接操作等效于下面这样的伪 SQL：</p>
<p>​<br>    SELECT *, savi<br>    FROM sav<br>    WHERE savi IN (SELECT *<br>    FROM avi<br>    WHERE sku= sav.item);</p>
<p>以上就是 <code>lookup</code> 的基本用法和作用介绍，更多与 <code>lookup</code> 相关的知识可查阅官方文档<br>[lookup](<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#lookup-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#lookup-</a><br>aggregation)。</p>
<p><strong>unwind</strong></p>
<p><code>unwind</code> 能将包含数组的文档拆分称多个文档，其语法格式如下：</p>
<p>​<br>    {<br>      $unwind:<br>        {<br>          path: <field path>,<br>          includeArrayIndex: <string>,<br>          preserveNullAndEmptyArrays: <boolean><br>        }<br>    }</boolean></string></field></p>
<p><code>unwind</code> 支持的指令及对应描述如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>path</code></td>
<td>string</td>
<td>指定数组字段的字段路径， 必填。</td>
</tr>
<tr>
<td><code>includeArrayIndex</code></td>
<td>string</td>
<td>用于保存元素的数组索引的新字段的名称。</td>
</tr>
<tr>
<td><code>preserveNullAndEmptyArrays</code></td>
<td>boolean</td>
<td>默认情况下，如果<code>path</code>为 <code>null</code>、缺少该字段或空数组，</td>
</tr>
<tr>
<td>则不输出文档。反之，将其设为 <code>true</code> 则会输出文档。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.shoes.save({_id: 1, brand: “Nick”, sizes: [37, 38, 39]})</p>
<p>集合 <code>shoes</code> 中的 <code>sizes</code> 是一个数组，里面有多个尺码数据。假设要将这个文档拆分成 3 个 <code>size</code> 为单个值的文档，对应示例如下：</p>
<p>​<br>    &gt; db.shoes.aggregate([{$unwind : “$sizes”}])<br>    { “_id” : 1, “brand” : “Nick”, “sizes” : 37 }<br>    { “_id” : 1, “brand” : “Nick”, “sizes” : 38 }<br>    { “_id” : 1, “brand” : “Nick”, “sizes” : 39 }</p>
<p>显然，这样的文档更方便我们做数据处理。<code>preserveNullAndEmptyArrays</code> 指令默认为 <code>false</code>，也就是说文档中指定的<br><code>path</code> 为空、<code>null</code> 或缺少该 <code>path</code> 的时候，会忽略掉该文档。假设数据如下：</p>
<p>​<br>    &gt; db.shoes2.insertMany([<br>    {“_id”: 1, “item”: “ABC”, “sizes”: [“S”, “M”, “L”]},<br>    {“_id”: 2, “item”: “EFG”, “sizes”: [ ]},<br>    {“_id”: 3, “item”: “IJK”, “sizes”: “M”},<br>    {“_id”: 4, “item”: “LMN” },<br>    {“_id”: 5, “item”: “XYZ”, “sizes”: null}<br>    ])</p>
<p>我们执行以下命令：</p>
<p>​<br>    &gt; db.shoes2.aggregate([{$unwind: “$sizes”}])</p>
<p>就会得到如下输出：</p>
<p>​<br>    { “_id” : 1, “item” : “ABC”, “sizes” : “S” }<br>    { “_id” : 1, “item” : “ABC”, “sizes” : “M” }<br>    { “_id” : 1, “item” : “ABC”, “sizes” : “L” }<br>    { “_id” : 3, “item” : “IJK”, “sizes” : “M” }</p>
<p><code>_id</code> 为 <code>2</code>、<code>4</code> 和 <code>5</code> 的文档由于满足 <code>preserveNullAndEmptyArrays</code> 的条件，所以不会被拆分。</p>
<p>以上就是 <code>unwind</code> 的基本用法和作用介绍，更多与 <code>unwind</code> 相关的知识可查阅官方文档<br>[unwind](<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#unwind-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/#unwind-</a><br>aggregation)。</p>
<p><strong>out</strong></p>
<p><code>out</code> 的作用是聚合 <code>Pipeline</code> 返回的结果文档，并将其写入指定的集合。要注意的是，<code>out</code> 操作必须出现在 <code>Pipeline</code><br>的最后。<code>out</code> 语法格式如下：</p>
<p>​<br>    { $out: “<output-collection>“ }</output-collection></p>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.books.insertMany([<br>    { “_id” : 8751, “title” : “The Banquet”, “author” : “Dante”, “copies” : 2 },<br>    { “_id” : 8752, “title” : “Divine Comedy”, “author” : “Dante”, “copies” : 1 },<br>    { “_id” : 8645, “title” : “Eclogues”, “author” : “Dante”, “copies” : 2 },<br>    { “_id” : 7000, “title” : “The Odyssey”, “author” : “Homer”, “copies” : 10 },<br>    { “_id” : 7020, “title” : “Iliad”, “author” : “Homer”, “copies” : 10 }<br>    ])</p>
<p>假设要集合 <code>books</code> 的分组结果保存到名为 <code>books_result</code> 的集合中，对应示例如下：</p>
<p>​<br>    &gt; db.books.aggregate([<br>    … { $group : {_id: “$author”, books: {$push: “$title”}}},<br>    … { $out : “books_result” }<br>    … ])</p>
<p>命令执行后，MongoDB 将会创建 <code>books_result</code> 集合，并将分组结果保存到该集合中。集合 <code>books_result</code> 中的文档如下：</p>
<p>​<br>    { “_id” : “Homer”, “books” : [ “The Odyssey”, “Iliad” ] }<br>    { “_id” : “Dante”, “books” : [ “The Banquet”, “Divine Comedy”, “Eclogues” ] }</p>
<p>以上就是 <code>out</code> 的基本用法和作用介绍，更多与 <code>out</code> 相关的知识可查阅官方文档<br>[out](<a href="https://docs.mongodb.com/manual/reference/operator/aggregation/out/#out-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/operator/aggregation/out/#out-</a><br>aggregation)。</p>
<h3 id="Map-Reduce"><a href="#Map-Reduce" class="headerlink" title="Map-Reduce"></a>Map-Reduce</h3><p>Map-reduce 用于将大量数据压缩为有用的聚合结果，其语法格式如下：</p>
<p>​<br>    db.runCommand(<br>                   {<br>                     mapReduce: <collection>,<br>                     map: <function>,<br>                     reduce: <function>,<br>                     finalize: <function>,<br>                     out: <output>,<br>                     query: <document>,<br>                     sort: <document>,<br>                     limit: <number>,<br>                     scope: <document>,<br>                     jsMode: <boolean>,<br>                     verbose: <boolean>,<br>                     bypassDocumentValidation: <boolean>,<br>                     collation: <document>,<br>                     writeConcern: <document><br>                   }<br>                 )</document></document></boolean></boolean></boolean></document></number></document></document></output></function></function></function></collection></p>
<p>其中，<code>db.runCommand({mapReduce: &lt;collection&gt;})</code> 也可以写成<br><code>db.collection.mapReduce()</code>。各指令的对应描述如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>mapReduce</code></td>
<td>collection</td>
<td>集合名称，必填。</td>
</tr>
<tr>
<td><code>map</code></td>
<td>function</td>
<td>JavaScript 函数，必填。</td>
</tr>
<tr>
<td><code>reduce</code></td>
<td>function</td>
<td>JavaScript 函数，必填。</td>
</tr>
<tr>
<td><code>out</code></td>
<td>string or document</td>
<td>指定输出结果，必填。</td>
</tr>
<tr>
<td><code>query</code></td>
<td>document</td>
<td>查询条件语句。</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>document</td>
<td>对文档进行排序。</td>
</tr>
<tr>
<td><code>limit</code></td>
<td>number</td>
<td>指定输入到 <code>map</code> 中的最大文档数量。</td>
</tr>
<tr>
<td><code>finalize</code></td>
<td>function</td>
<td>修改 <code>reduce</code> 的输出。</td>
</tr>
<tr>
<td><code>scope</code></td>
<td>document</td>
<td>指定全局变量。</td>
</tr>
<tr>
<td><code>jsMode</code></td>
<td>boolean</td>
<td>是否在执行<code>map</code>和<code>reduce</code> 函数之间将中间数据转换为 BSON 格式，默认 <code>false</code>。</td>
</tr>
<tr>
<td><code>verbose</code></td>
<td>boolean</td>
<td>结果中是否包含 <code>timing</code> 信息，默认 <code>false</code>。</td>
</tr>
<tr>
<td><code>bypassDocumentValidation</code></td>
<td>boolean</td>
<td>是否允许</td>
</tr>
<tr>
<td><a href="https://docs.mongodb.com/manual/reference/command/mapReduce/#dbcmd.mapReduce" target="_blank" rel="noopener"><code>mapReduce</code></a>在操作期间绕过文档验证，默认</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>false</code>。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>collation</code></td>
<td>document</td>
<td></td>
</tr>
<tr>
<td>指定要用于操作的[排序规则](<a href="https://docs.mongodb.com/manual/reference/bson-type-comparison-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/bson-type-comparison-</a></td>
<td></td>
<td></td>
</tr>
<tr>
<td>order/#collation)。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>writeConcern</code></td>
<td>document</td>
<td>指定写入级别，不填写则使用默认级别。</td>
</tr>
</tbody></table>
<h4 id="简单的-mapReduce"><a href="#简单的-mapReduce" class="headerlink" title="简单的 mapReduce"></a>简单的 mapReduce</h4><p>一个简单的 <code>mapReduce</code> 语法示例如下：</p>
<p>​<br>    var mapFunction = function() { … };<br>    var reduceFunction = function(key, values) { … };<br>    db.runCommand(<br>    … {<br>    … … mapReduce: <input-collection>,<br>    … … map: mapFunction,<br>    … … reduce: reduceFunction,<br>    … … out: { merge: <output-collection> },<br>    … … query: <query><br>    … })</query></output-collection></input-collection></p>
<p><code>map</code> 函数负责将每个输入的文档转换为零个或多个文档。<code>map</code> 结构如下：</p>
<p>​<br>    function() {<br>       …<br>       emit(key, value);<br>    }</p>
<p><code>emit</code> 函数的作用是分组，它接收两个参数：</p>
<ul>
<li><code>key</code>：指定用于分组的字段。</li>
<li><code>value</code>：要聚合的字段。</li>
</ul>
<p>在 <code>map</code> 中可以使用 <code>this</code> 关键字引用当前文档。<code>reduce</code> 结构如下：</p>
<p>​<br>    function(key, values) {<br>       …<br>       return result;<br>    }</p>
<p><code>reduce</code> 执行具体的数据处理操作，它接收两个参数：</p>
<ul>
<li><code>key</code>：与 <code>map</code> 中的 <code>key</code> 相同，即分组字段。</li>
<li><code>values</code>：根据分组字段，将相同 <code>key</code> 的值放到同一个数组，<code>values</code> 就是包含这些分类数组的对象。</li>
</ul>
<p><code>out</code> 用于指定结果输出，<code>out: &lt;collectionName&gt;</code> 会将结果输出到新的集合，或者使用以下语法将结果输出到已存在的集合中：</p>
<p>​<br>    out: { <action>: <collectionname><br>            [, db: <dbname>]<br>            [, sharded: <boolean> ]<br>            [, nonAtomic: <boolean> ] }</boolean></boolean></dbname></collectionname></action></p>
<p>要注意的是，如果 <code>out</code> 指定的 <code>collection</code> 已存在，那么它就会覆盖该集合。在开始学习之前，我们需要准备以下数据：</p>
<p>​<br>    &gt; db.mprds.insertMany([<br>    … {_id: 1, numb: 3, score: 9, team: “B”},<br>    … {_id: 2, numb: 6, score: 9, team: “A”},<br>    … {_id: 3, numb: 24, score: 9, team: “A”},<br>    … {_id: 4, numb: 6, score: 8, team: “A”}<br>    … ])</p>
<p>接着定义 <code>map</code> 函数、<code>reduce</code> 函数，并将其应用到集合 <code>mrexample</code> 上。然后为输出结果指定存放位置，这里将输出结果存放在名为<br><code>mrexample_result</code> 的集合中。</p>
<p>​<br>    &gt; var func_map = function(){emit(this.numb, this.score);};<br>    &gt; var func_reduce = function(key, values){return Array.sum(values);};<br>    &gt; db.mprds.mapReduce(func_map, func_reduce, {query: {team: “A”}, out: “mprds_result”})</p>
<p><code>map</code> 函数指定了结果中包含的两个键，并将 <code>this.class</code> 相同的文档输出到同一个文档中。<code>reduce</code><br>则对传入的列表进行求和，求和结果作为结果中的 <code>value</code> 。命令执行完毕后，结果会被存放在集合 <code>mprds_result</code> 中。用以下命令查看结果：</p>
<p>​<br>    &gt; db.mprds_result.find()<br>    { “_id” : 6, “value” : 17 }<br>    { “_id” : 24, “value” : 9 }</p>
<p>结果文档中的 <code>_id</code> 即 <code>map</code> 中的 <code>this.numb</code>，<code>value</code> 为 <code>reduce</code> 函数的返回值。</p>
<p>下图描述了此次 <code>mapReduce</code> 操作的完整过程：</p>
<p><img src="https://images.gitbook.cn/574748f0-be88-11e9-8cae-739b42a884cb" alt="在这里插入图片描述"></p>
<h4 id="finallize-剪枝"><a href="#finallize-剪枝" class="headerlink" title="finallize 剪枝"></a>finallize 剪枝</h4><p><code>finallize</code> 用于修改 <code>reduce</code> 的输出结果，其语法格式如下：</p>
<p>​<br>    function(key, reducedValue) {<br>       …<br>       return modifiedObject;<br>    }</p>
<p>它接收两个参数：</p>
<p><code>key</code>，与 <code>map</code> 中的 <code>key</code> 相同，即分组字段。</p>
<p><code>reducedValue</code>，一个 <code>Obecjt</code>，是<code>reduce</code> 的输出。</p>
<p>上面我们介绍了 <code>map</code> 和 <code>reduce</code>，并通过一个简单的示例了解 <code>mapReduce</code> 的基本组成和用法。实际上我们还可以编写功能更丰富的<br><code>reduce</code> 函数，甚至使用 <code>finallize</code> 修改 <code>reduce</code> 的输出结果。以下 <code>reduce</code> 函数将传入的 <code>values</code><br>进行计算和重组，返回一个 <code>reduceVal</code> 对象：</p>
<p>​<br>    &gt; var func_reduce2 = function(key, values){<br>        reduceVal = {team: key, score: values, total: Array.sum(values), count: values.length};<br>        return reduceVal;<br>    };</p>
<p><code>reduceVal</code> 对象中包含 <code>team</code>、<code>score</code>、<code>total</code> 和 <code>count</code> 四个属性。但我们还想为其添加 <code>avg</code><br>属性，那么可以在 <code>finallize</code> 函数中执行 <code>avg</code> 值的计算和 <code>avg</code> 属性的添加工作：</p>
<p>​<br>    &gt; var func_finalize = function(key, values){<br>        values.avg = values.total / values.count;<br>        return values;<br>    };</p>
<p><code>map</code> 保持不变，将这几个函数作用于集合 <code>mprds</code> 上，对应示例如下：</p>
<p>​<br>    &gt; db.mprds.mapReduce(func_map, func_reduce2, {query: {team: “A”}, out: “mprds_result”, finalize: func_finalize})</p>
<p>命令执行后，结果会存入指定的集合中。此时，集合 <code>mprds_result</code> 内容如下：</p>
<p>​<br>    { “_id” : 6, “value” : { “team” : 6, “score” : [ 9, 8 ], “total” : 17, “count” : 2, “avg” : 8.5 } }<br>    { “_id” : 24, “value” : 9 }</p>
<p>下图描述了此次 <code>mapReduce</code> 操作的完整过程：<br><img src="https://images.gitbook.cn/766326f0-be88-11e9-bb6f-13203c9ddaa7" alt="在这里插入图片描述"><br><code>finallize</code> 在 <code>reduce</code> 后面使用，微调 <code>reduce</code> 的处理结果。这着看起来像是一个园丁在修剪花圃的枝丫，所以人们将<br><code>finallize</code> 形象地称为“剪枝”。</p>
<p>要注意的是：<code>map</code> 会将 <code>key</code> 值相同的文档中的 <code>value</code> 归纳到同一个对象中，这个对象会经过 <code>reduce</code> 和<br><code>finallize</code>。对于 <code>key</code> 值唯一的那些文档，指定的 <code>key</code> 和 <code>value</code> 会被直接输出。</p>
<h3 id="简单的聚合"><a href="#简单的聚合" class="headerlink" title="简单的聚合"></a>简单的聚合</h3><p>除了 Aggregation Pipeline 和 Map-Reduce 这些复杂的聚合操作之外，MongoDB 还支持一些简单的聚合操作，例如<br><code>count</code>、<code>group</code> 和 <code>distinct</code> 等。</p>
<p><strong>count</strong></p>
<p><code>count</code> 用于计算集合或视图中的文档数，返回一个包含计数结果和状态的文档。其语法格式如下：</p>
<p>​<br>    {<br>      count: <collection or view>,<br>      query: <document>,<br>      limit: <integer>,<br>      skip: <integer>,<br>      hint: <hint>,<br>      readConcern: <document><br>    }</document></hint></integer></integer></document></collection></p>
<p><code>count</code> 支持的指令及对应描述如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>count</code></td>
<td>string</td>
<td>要计数的集合或视图的名称，必填。</td>
</tr>
<tr>
<td><code>query</code></td>
<td>document</td>
<td>查询条件语句。</td>
</tr>
<tr>
<td><code>limit</code></td>
<td>integer</td>
<td>指定要返回的最大匹配文档数。</td>
</tr>
<tr>
<td><code>skip</code></td>
<td>integer</td>
<td>指定返回结果之前要跳过的匹配文档数。</td>
</tr>
<tr>
<td><code>hint</code></td>
<td>string or document</td>
<td>指定要使用的索引，将索引名称指定为字符串或索引规范文档。</td>
</tr>
</tbody></table>
<p>假设要统计集合 <code>mprds</code> 中的文档数量，对应示例如下：</p>
<p>​<br>    &gt; db.runCommand({count: ‘mprds’})<br>    { “n” : 4, “ok” : 1 }</p>
<p>假设要统计集合 <code>mprds</code> 中 <code>numb</code> 为 <code>6</code> 的文档数量，对应示例如下：</p>
<p>​<br>    &gt; db.runCommand({count: ‘mprds’, query: {numb: {$eq: 6}}})<br>    { “n” : 2, “ok” : 1 }</p>
<p>指定返回结果之前跳过 <code>1</code> 个文档，对应示例如下：</p>
<p>​<br>    &gt; db.runCommand({count: ‘mprds’, query: {numb: {$eq: 6}}, skip: 1})<br>    { “n” : 1, “ok” : 1 }</p>
<p>更多关于 <code>count</code> 的知识可查阅官方文档<br><a href="https://docs.mongodb.com/manual/reference/command/count/#count" target="_blank" rel="noopener">Count</a>。</p>
<p><strong>group</strong></p>
<p><code>group</code> 的作用是按指定的键对集合中的文档进行分组，并执行简单的聚合函数，它与 SQL 中的 <code>SELECT ... GROUP BY</code><br>类似。其语法格式如下：</p>
<p>​<br>    {<br>      group:<br>       {<br>         ns: <namespace>,<br>         key: <key>,<br>         $reduce: <reduce function>,<br>         $keyf: <key function>,<br>         cond: <query>,<br>         finalize: <finalize function><br>       }<br>    }</finalize></query></key></reduce></key></namespace></p>
<p><code>group</code> 支持的指令及对应描述如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ns</code></td>
<td>string</td>
<td>通过操作执行组的集合，必填。</td>
</tr>
<tr>
<td><code>key</code></td>
<td>ducoment</td>
<td>要分组的字段或字段，必填。</td>
</tr>
<tr>
<td><code>$reduce</code></td>
<td>function</td>
<td>在分组操作期间对文档进行聚合操作的函数。</td>
</tr>
<tr>
<td>该函数有两个参数：当前文档和该组的聚合结果文档。</td>
<td></td>
<td></td>
</tr>
<tr>
<td>必填。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>initial</code></td>
<td>document</td>
<td>初始化聚合结果文档， 必填。</td>
</tr>
<tr>
<td><code>$keyf</code></td>
<td>function</td>
<td>替代 <code>key</code>。指定用于创建“密钥对象”以用作分组密钥的函数。</td>
</tr>
<tr>
<td>使用<code>$keyf</code>而不是 <code>key</code>按计算字段而不是现有文档字段进行分组。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>cond</code></td>
<td>document</td>
<td>用于确定要处理的集合中的哪些文档的选择标准。</td>
</tr>
<tr>
<td>如果省略，<code>group</code> 会处理集合中的所有文档。</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>finalize</code></td>
<td>function</td>
<td>在返回结果之前运行，此函数可以修改结果文档。</td>
</tr>
</tbody></table>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.sales.insertMany([<br>    {_id: 1, orderDate: ISODate(“2012-07-01T04:00:00Z”), shipDate: ISODate(“2012-07-02T09:00:00Z”), attr: {name: “新款椰子鞋”, price: 2999, size: 42, color: “香槟金”}},<br>    {_id: 2, orderDate: ISODate(“2012-07-03T05:20:00Z”), shipDate: ISODate(“2012-07-04T09:00:00Z”), attr: {name: “高邦篮球鞋”, price: 1999, size: 43, color: “狮王棕”}},<br>    {_id: 3, orderDate: ISODate(“2012-07-03T05:20:10Z”), shipDate: ISODate(“2012-07-04T09:00:00Z”), attr: {name: “新款椰子鞋”, price: 2999, size: 42, color: “香槟金”}},<br>    {_id: 4, orderDate: ISODate(“2012-07-05T15:11:33Z”), shipDate: ISODate(“2012-07-06T09:00:00Z”), attr: {name: “极速跑鞋”, price: 500, size: 43, color: “西湖蓝”}},<br>    {_id: 5, orderDate: ISODate(“2012-07-05T20:22:09Z”), shipDate: ISODate(“2012-07-06T09:00:00Z”), attr: {name: “新款椰子鞋”, price: 2999, size: 42, color: “香槟金”}},<br>    {_id: 6, orderDate: ISODate(“2012-07-05T22:35:20Z”), shipDate: ISODate(“2012-07-06T09:00:00Z”), attr: {name: “透气网跑”, price: 399, size: 38, color: “玫瑰红”}}<br>    ])</p>
<p>假设要将集合 <code>sales</code> 中的文档按照 <code>attr.name</code> 进行分组，并限定参与分组的文档的 <code>shipDate</code> 大于指定时间。对应示例如下：</p>
<p>​<br>    &gt; db.runCommand({<br>        group:{<br>            ns: ‘sales’,<br>          key: {“attr.name”: 1},<br>          cond: {shipDate: {$gt: ISODate(‘2012-07-04T00:00:00Z’)}},<br>          $reduce: function(curr, result){},<br>          initial: {}<br>        }<br>    })</p>
<p>命令执行后，会返回一个结果档。其中， <code>retval</code> 包含指定字段 <code>attr.name</code> 的数据，<code>count</code> 为参与分组的文档数量，<code>keys</code><br>代表组的数量，<code>ok</code> 代表文档状态。结果文档如下：</p>
<p>​<br>    {<br>        “retval” : [<br>            {<br>                “attr.name” : “高邦篮球鞋”<br>            },<br>            {<br>                “attr.name” : “新款椰子鞋”<br>            },<br>            {<br>                “attr.name” : “极速跑鞋”<br>            },<br>            {<br>                “attr.name” : “透气网跑”<br>            }<br>        ],<br>        “count” : NumberLong(5),<br>        “keys” : NumberLong(4),<br>        “ok” : 1<br>    }</p>
<p>上方示例指定的 <code>key</code> 是 <code>attr.name</code>。由于参与分组的 5 个文档中只有 2 个文档的 <code>attr.name</code> 是相同的，所以分组结果中的<br><code>keys</code> 为 <code>4</code>，这代表集合 <code>sales</code> 中的文档被分成了 4 组。</p>
<p>将 <code>attr.name</code>换成 <code>shipDate</code>，看看结果会是什么。对应示例如下：</p>
<p>​<br>    &gt; db.runCommand(<br>    {<br>        group:{<br>            ns: ‘sales’,<br>            key: {shipDate: 1},<br>            cond: {shipDate: {$gt: ISODate(‘2012-07-04T00:00:00Z’)}},<br>            $reduce: function(curr, result){},<br>            initial: {}<br>            }<br>        }<br>    )</p>
<p>命令执行后，返回如下结果：</p>
<p>​<br>    {<br>        “retval” : [<br>            {<br>                “shipDate” : ISODate(“2012-07-04T09:00:00Z”)<br>            },<br>            {<br>                “shipDate” : ISODate(“2012-07-06T09:00:00Z”)<br>            }<br>        ],<br>        “count” : NumberLong(5),<br>        “keys” : NumberLong(2),<br>        “ok” : 1<br>    }</p>
<p>由于参与分组的 5 个文档中有几个文档的 <code>shipDate</code> 是重复的，所以分组结果中的 <code>keys</code> 为 <code>2</code>，这代表集合 <code>sales</code><br>中的文档被分成了 2 组。</p>
<p>上面的示例并没有用到 <code>reduce</code>、 <code>initial</code> 和 <code>finallize</code><br>，接下来我们将演示它们的用法和作用。假设要统计同组的销售总额，那么可以在 <code>reduce</code> 中执行具体的计算逻辑。对应示例如下：</p>
<p>​<br>    &gt; db.runCommand(<br>    {<br>        group:{<br>            ns: ‘sales’,<br>            key: {shipDate: 1},<br>            cond: {shipDate: {$gt: ISODate(‘2012-07-04T00:00:00Z’)}},<br>            $reduce: function(curr, result){<br>                result.total += curr.attr.price;<br>                },<br>            initial: {total: 0}<br>            }<br>        }<br>    )</p>
<p>命令执行后，返回结果如下：</p>
<p>​<br>    {<br>        “retval” : [<br>            {<br>                “shipDate” : ISODate(“2012-07-04T09:00:00Z”),<br>                “total” : 4998<br>            },<br>            {<br>                “shipDate” : ISODate(“2012-07-06T09:00:00Z”),<br>                “total” : 3898<br>            }<br>        ],<br>        “count” : NumberLong(5),<br>        “keys” : NumberLong(2),<br>        “ok” : 1<br>    }</p>
<p>人工验证一下，发货日期 <code>shipDate</code> 大于 <code>2012-07-04T09:00:00Z</code> 的文档为：</p>
<p>​<br>    { “_id” : 2, “orderDate” : ISODate(“2012-07-03T05:20:00Z”), “shipDate” : ISODate(“2012-07-04T09:00:00Z”), “attr” : { “name” : “高邦篮球鞋”, “price” : 1999, “size” : 43, “color” : “狮王棕” } }<br>    { “_id” : 3, “orderDate” : ISODate(“2012-07-03T05:20:10Z”), “shipDate” : ISODate(“2012-07-04T09:00:00Z”), “attr” : { “name” : “新款椰子鞋”, “price” : 2999, “size” : 42, “color” : “香槟金” } }</p>
<p>销售总额为 <code>1999 + 2999 = 4998</code>，与返回结果相同。发货日期 <code>shipDate</code> 大于 <code>2012-07-06T09:00:00Z</code><br>的文档为：</p>
<p>​<br>    { “_id” : 4, “orderDate” : ISODate(“2012-07-05T15:11:33Z”), “shipDate” : ISODate(“2012-07-06T09:00:00Z”), “attr” : { “name” : “极速跑鞋”, “price” : 500, “size” : 43, “color” : “西湖蓝” } }<br>    { “_id” : 5, “orderDate” : ISODate(“2012-07-05T20:22:09Z”), “shipDate” : ISODate(“2012-07-06T09:00:00Z”), “attr” : { “name” : “新款椰子鞋”, “price” : 2999, “size” : 42, “color” : “香槟金” } }<br>    { “_id” : 6, “orderDate” : ISODate(“2012-07-05T22:35:20Z”), “shipDate” : ISODate(“2012-07-06T09:00:00Z”), “attr” : { “name” : “透气网跑”, “price” : 399, “size” : 38, “color” : “玫瑰红” } }</p>
<p>销售总额为 <code>500 + 2999 + 399 = 3898</code>，与返回结果相同。</p>
<p>有时候可能需要统计每个组的文档数量以及计算平均销售额，对应示例如下：</p>
<p>​<br>    &gt; db.runCommand(<br>    {<br>        group:{<br>            ns: ‘sales’,<br>            key: {shipDate: 1},<br>            cond: {shipDate: {$gt: ISODate(‘2012-07-04T00:00:00Z’)}},<br>            $reduce: function(curr, result){<br>                result.total += curr.attr.price;<br>                result.count ++;<br>                },<br>            initial: {total: 0, count: 0},<br>            finalize: function(result){<br>                result.avg = Math.round(result.total / result.count);<br>                }<br>            }<br>        }<br>    )</p>
<p>上面的示例中改动了 <code>$reduce</code> 函数，目的是为了统计 <code>count</code>。然后新增了<br><code>finalize</code>，目的是计算分组中的平均销售额。命令执行后，返回以下文档：</p>
<p>​<br>    {<br>        “retval” : [<br>            {<br>                “shipDate” : ISODate(“2012-07-04T09:00:00Z”),<br>                “total” : 4998,<br>                “count” : 2,<br>                “avg” : 2499<br>            },<br>            {<br>                “shipDate” : ISODate(“2012-07-06T09:00:00Z”),<br>                “total” : 3898,<br>                “count” : 3,<br>                “avg” : 1299<br>            }<br>        ],<br>        “count” : NumberLong(5),<br>        “keys” : NumberLong(2),<br>        “ok” : 1<br>    }</p>
<p>以上就是 <code>group</code> 的基本用法和作用介绍，更多与 <code>group</code> 相关的知识可查阅官方文档<br><a href="https://docs.mongodb.com/manual/reference/command/group/#group" target="_blank" rel="noopener">group</a>。</p>
<p><strong>distinct</strong></p>
<p><code>distinct</code> 的作用是查找单个集合中指定字段的不同值，其语法格式如下：</p>
<p>​<br>    {<br>      distinct: “<collection>“,<br>      key: “<field>“,<br>      query: <query>,<br>      readConcern: <read concern document>,<br>      collation: <collation document><br>    }</collation></read></query></field></collection></p>
<p><code>distinct</code> 支持的指令及对应描述如下：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>distinct</code></td>
<td>string</td>
<td>集合名称， 必填。</td>
</tr>
<tr>
<td><code>key</code></td>
<td>string</td>
<td>指定的字段， 必填。</td>
</tr>
<tr>
<td><code>query</code></td>
<td>document</td>
<td>查询条件语句。</td>
</tr>
<tr>
<td><code>readConcern</code></td>
<td>document</td>
<td></td>
</tr>
<tr>
<td><code>collation</code></td>
<td>document</td>
<td></td>
</tr>
</tbody></table>
<p>准备以下数据：</p>
<p>​<br>    &gt; db.dress.insertMany([<br>    … {_id: 1, “dept”: “A”, attr: {“款式”: “立领”, color: “red” }, sizes: [“S”, “M” ]},<br>    … {_id: 2, “dept”: “A”, attr: {“款式”: “圆领”, color: “blue” }, sizes: [“M”, “L” ]},<br>    … {_id: 3, “dept”: “B”, attr: {“款式”: “圆领”, color: “blue” }, sizes: “S” },<br>    … {_id: 4, “dept”: “A”, attr: {“款式”: “V领”, color: “black” }, sizes: [“S” ] }<br>    ])</p>
<p>假设要统计集合 <code>dress</code> 中所有文档的 <code>dept</code> 字段的不同值，对应示例如下：</p>
<p>​<br>    &gt; db.runCommand ( { distinct: “dress”, key: “dept” } )<br>    { “values” : [ “A”, “B” ], “ok” : 1 }</p>
<p>或者看看有那些款式，对应示例如下</p>
<p>​<br>    &gt; db.runCommand ( { distinct: “dress”, key: “attr.款式” } )<br>    { “values” : [ “立领”, “圆领”, “V领” ], “ok” : 1 }</p>
<p>就算值是数组， <code>distinct</code> 也能作出正确处理，对应示例如下：</p>
<p>​<br>    &gt; db.runCommand ( { distinct: “dress”, key: “sizes” } )<br>    { “values” : [ “M”, “S”, “L” ], “ok” : 1 }</p>
<h3 id="流式聚合操作小结"><a href="#流式聚合操作小结" class="headerlink" title="流式聚合操作小结"></a>流式聚合操作小结</h3><p>以上就是本篇对 MongoDB<br>中流式聚合操作的介绍。聚合与管道的概念并不常见，但是理解起来也不难。只要跟着示例思考，并动手实践，相信你很快就能够熟练掌握聚合操作。</p>
<h2 id="基础篇-三-执行计划与索引"><a href="#基础篇-三-执行计划与索引" class="headerlink" title="基础篇 三 执行计划与索引"></a>基础篇 三 执行计划与索引</h2><p>在前面的几篇中，我们学习了 MongoDB 常用的文档 CURD 操作，并了解了流式聚合的相关知识。要注意的是，如果查询语句使用不当，会降低 MongoDB<br>的检索效率。反之，如果查询语句设计得当，就能够有效提升检索效率。那么我们如何确定什么语句是“得当”，什么语句又“不得当”呢？</p>
<p>我们将在本篇了解查询语句的优劣，学习如何查看查询语句的执行计划，并学习索引相关的知识。这些知识能避免我们写出“不得当”的查询语句，设计出合理的查询方案。</p>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><p>执行计划是对一次查询在数据库中的执行过程或访问路径的描述。我们可以通过这个描述来判断本次查询的效率，并根据实际情况进行调整，进而提升检索效率。</p>
<p>MongoDB 提供了几种方法用于返回执行计划和执行计划统计信息，它们是：</p>
<ul>
<li><code>db.collection.explain()</code> 方法；</li>
<li><code>cursor.explain()</code> 方法；</li>
<li><code>explain</code> 命令；</li>
</ul>
<p>本篇我们讨论的是 <code>cursor.explain()</code> 方法，以下简称 <code>explain()</code>，其语法如下：</p>
<p>​<br>    db.collection.find().explain(<verbose>)</verbose></p>
<p>其中，<code>&lt;verbose&gt;</code> 参数代表执行计划的输出模式，该模式将会影响 <code>explain()</code> 的行为以及返回的信息量。<code>&lt;verbose&gt;</code><br>的可选参数为：<code>queryPlanner</code>、<code>executionStats</code> 和 <code>allPlansExecution</code>，它们的作用如下：</p>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>queryPlanner</code></td>
<td>执行计划的详细信息，包括查询计划、集合信息、查询条件、最佳执行计划、查询方式和 MongoDB 服务信息等。</td>
</tr>
<tr>
<td><code>executionStats</code></td>
<td>最佳执行计划的执行情况和被拒绝的计划等信息。</td>
</tr>
<tr>
<td><code>allPlansExecution</code></td>
<td>选择并执行最佳执行计划，并返回最佳执行计划和其他执行计划的执行情况。</td>
</tr>
</tbody></table>
<p>每个模式返回的信息均不相同，<code>queryPlanner</code> 模式返回的信息格式如下：</p>
<p>​<br>    “queryPlanner” : {<br>       “plannerVersion” : <int>,<br>       “namespace” : <string>,<br>       “indexFilterSet” : <boolean>,<br>       “parsedQuery” : {<br>          …<br>       },<br>       “winningPlan” : {<br>          “stage” : <stage1>,<br>          …<br>          “inputStage” : {<br>             “stage” : <stage2>,<br>             …<br>             “inputStage” : {<br>                …<br>             }<br>          }<br>       },<br>       “rejectedPlans” : [<br>          &lt;candidate plan 1&gt;,<br>          …<br>       ]<br>    },<br>    “serverInfo” : {<br>       “host” : <string>,<br>       “port” : <int>,<br>       “version” : <string>,<br>       “gitVersion” : <string><br>    }</string></string></int></string></stage2></stage1></boolean></string></int></p>
<p><code>stage</code> 代表查询方式，各查询方式含义如下例如：</p>
<ul>
<li><code>COLLSCAN</code> 全文检索；</li>
<li><code>IXSCAN</code> 按索引检索；</li>
<li><code>FETCH</code> 检索文档；</li>
<li><code>SHARD_MERGE</code> 合并分片的结果；</li>
<li><code>SHARDING_FILTER</code> 从分片中过滤掉孤立文档；</li>
</ul>
<p>我们注意到，<code>queryPlanner</code> 模式的返回信息中包含了很多字段，例如 <code>plannerVersion</code>、<br><code>namespace</code>、<code>winningPlan</code>、<code>rejetedPlans</code> 和 <code>serverInfo</code> 等。字段及对应的描述如下：</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>plannerVersion</td>
<td>执行计划的版本</td>
</tr>
<tr>
<td>namespace</td>
<td>要查询的集合</td>
</tr>
<tr>
<td>indexFilterSet</td>
<td>是否使用索引</td>
</tr>
<tr>
<td>parsedQuery</td>
<td>查询条件，此处为x=1</td>
</tr>
<tr>
<td>winningPlan</td>
<td>最佳执行计划</td>
</tr>
<tr>
<td>stage</td>
<td>查询方式</td>
</tr>
<tr>
<td>filter</td>
<td>过滤条件</td>
</tr>
<tr>
<td>direction</td>
<td>搜索方向</td>
</tr>
<tr>
<td>rejectedPlans</td>
<td>拒绝的执行计划</td>
</tr>
<tr>
<td>serverInfo</td>
<td>MongoDB服务器信息</td>
</tr>
</tbody></table>
<p><code>executionStats</code> 模式返回的信息格式如下：</p>
<p>​<br>    “queryPlanner” : {<br>       “plannerVersion” : <int>,<br>       “parsedQuery” : {<br>        …<br>       },<br>       “winningPlan” : {<br>          “stage” : <stage1>,<br>          …<br>       },<br>       “rejectedPlans” : []<br>       },<br>    “executionStats” : {<br>       “executionSuccess” : <boolean>,<br>       “nReturned” : <int>,<br>       “executionTimeMillis” : <int>,<br>       “totalKeysExamined” : <int>,<br>       “totalDocsExamined” : <int>,<br>       “executionStages” : {<br>          “stage” : <stage1><br>          “nReturned” : <int>,<br>          “executionTimeMillisEstimate” : <int>,<br>          “works” : <int>,<br>          “advanced” : <int>,<br>          “needTime” : <int>,<br>          “needYield” : <int>,<br>          “saveState” : <int>,<br>          “restoreState” : <int>,<br>          “isEOF” : <boolean>,<br>          …<br>            }<br>        },<br>      “serverInfo” : {<br>        “host” : <string>,<br>        “port” : <int>,<br>        “version” : <string>,<br>        “gitVersion” : <string><br>      }</string></string></int></string></boolean></int></int></int></int></int></int></int></int></stage1></int></int></int></int></boolean></stage1></int></p>
<p><code>executionStats</code> 模式的返回信息中包含了 <code>queryPlanner</code> 模式的所有字段，并且还包含了最佳执行计划的执行情况，涉及的字段如<br><code>executionSuccess</code>、 <code>totalDocsExamined</code>、<code>advanced</code> 和 <code>works</code> 等。字段具体描述如下：</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>executionSuccess</td>
<td>是否执行成功</td>
</tr>
<tr>
<td>nReturned</td>
<td>返回的结果</td>
</tr>
<tr>
<td>executionTimeMillis</td>
<td>查询计划的选择和执行所耗费的时间</td>
</tr>
<tr>
<td>totalKeysExamined</td>
<td>索引扫描次数</td>
</tr>
<tr>
<td>totalDocsExamined</td>
<td>文档扫描次数</td>
</tr>
<tr>
<td>executionStages</td>
<td>这个分类下描述执行的状态</td>
</tr>
<tr>
<td>isEOF</td>
<td>是否到达 steam 结尾，<code>1</code> 或者 <code>true</code> 代表已到达结尾</td>
</tr>
<tr>
<td>executionTimeMillisEstimate</td>
<td>预估耗时</td>
</tr>
<tr>
<td>works</td>
<td>工作单元数，一个查询会分解成小的工作单元</td>
</tr>
<tr>
<td>advanced</td>
<td>优先返回的结果数</td>
</tr>
<tr>
<td>docsExamined</td>
<td>文档检查数</td>
</tr>
</tbody></table>
<p><code>allPlansExecution</code> 模式返回的信息包含 <code>executionStats</code> 模式的内容，且包含 <code>&quot;allPlansExecution&quot;
: [ ]</code> 块，也就是最佳执行计划和被拒绝计划的部分执行信息。<code>&quot;allPlansExecution&quot; : [ ]</code> 块信息格式如下：</p>
<p>​<br>    “allPlansExecution” : [<br>          {<br>             “nReturned” : <int>,<br>             “executionTimeMillisEstimate” : <int>,<br>             “totalKeysExamined” : <int>,<br>             “totalDocsExamined” :<int>,<br>             “executionStages” : {<br>                “stage” : <stagea>,<br>                “nReturned” : <int>,<br>                “executionTimeMillisEstimate” : <int>,<br>                …<br>                }<br>             }<br>          },<br>          …<br>       ]</int></int></stagea></int></int></int></int></p>
<p>在了解了 <code>explain</code> 的语法和三种模式后，我们就可以开始实际练习了。假设要了解查询集合 <code>inven</code> 的查询语句<br><code>db.inven.find({number: {$gt: 6}})</code> 的查询计划，对应示例如下：</p>
<p>​<br>    &gt; db.inven.find({number: {$gt: 6}}).explain()<br>    {<br>        “queryPlanner” : {<br>            “plannerVersion” : 1,<br>            “namespace” : “test.inven”,<br>            “indexFilterSet” : false,<br>            “parsedQuery” : {<br>                “number” : {<br>                    “$gt” : 6<br>                }<br>            },<br>            “winningPlan” : {<br>                “stage” : “COLLSCAN”,<br>                “filter” : {<br>                    “number” : {<br>                        “$gt” : 6<br>                    }<br>                },<br>                “direction” : “forward”<br>            },<br>            “rejectedPlans” : [ ]<br>        },<br>        “serverInfo” : {<br>            “host” : “asyncdeMBP”,<br>            “port” : 27017,<br>            “version” : “4.0.10”,<br>            “gitVersion” : “c389e7f69f637f7a1ac3cc9fae843b635f20b766”<br>        },<br>        “ok” : 1<br>    }</p>
<p>以上就是本次操作的返回信息。要注意的是，在未传入正确参数的情况下，默认模式为 <code>queryPlanner</code>。从返回信息中，我们得知：</p>
<ul>
<li>本次查询的集合为 <code>test.inven</code>；</li>
<li>最佳执行计划的 <code>stage</code> 为 <code>COLLSCAN</code>；</li>
<li>查询时所用的过滤条件为 <code>number: {$gt: 6}</code>，即球衣号大于 6；</li>
<li>没有被拒绝的执行计划；</li>
<li>MongoDB 版本为 <code>4.0.10</code>，端口号为 <code>27017</code>。</li>
</ul>
<p>假如我们将查询模式改为 <code>executionStats</code>，那么我们将会得到如下信息：</p>
<p>​<br>    &gt; db.inven.find({number: {$gt: 6}}).explain(“executionStats”)<br>    {<br>        “queryPlanner” : {<br>            “plannerVersion” : 1,<br>            “namespace” : “test.inven”,<br>            “indexFilterSet” : false,<br>            “parsedQuery” : {<br>                “number” : {<br>                    “$gt” : 6<br>                }<br>            },<br>            “winningPlan” : {<br>                “stage” : “COLLSCAN”,<br>                “filter” : {<br>                    “number” : {<br>                        “$gt” : 6<br>                    }<br>                },<br>                “direction” : “forward”<br>            },<br>            “rejectedPlans” : [ ]<br>        },<br>        “executionStats” : {<br>            “executionSuccess” : true,<br>            “nReturned” : 3,<br>            “executionTimeMillis” : 0,<br>            “totalKeysExamined” : 0,<br>            “totalDocsExamined” : 5,<br>            “executionStages” : {<br>                “stage” : “COLLSCAN”,<br>                “filter” : {<br>                    “number” : {<br>                        “$gt” : 6<br>                    }<br>                },<br>                “nReturned” : 3,<br>                “executionTimeMillisEstimate” : 0,<br>                “works” : 7,<br>                “advanced” : 3,<br>                “needTime” : 3,<br>                “needYield” : 0,<br>                “saveState” : 0,<br>                “restoreState” : 0,<br>                “isEOF” : 1,<br>                “invalidates” : 0,<br>                “direction” : “forward”,<br>                “docsExamined” : 5<br>            }<br>        },<br>        “serverInfo” : {<br>            “host” : “asyncdeMBP”,<br>            “port” : 27017,<br>            “version” : “4.0.10”,<br>            “gitVersion” : “c389e7f69f637f7a1ac3cc9fae843b635f20b766”<br>        },<br>        “ok” : 1<br>    }</p>
<p>由于 <code>executionStats</code> 模式的返回信息中包含了 <code>queryPlanner</code><br>模式的返回内容，所以我们可以得到与执行默认模式相同的结果。除此之外，我们还可以看到最佳执行计划的详细情况：</p>
<ul>
<li>此次查询共遍历 <code>5</code> 份文档;</li>
<li>只有 <code>3</code> 份文档符合过滤要求；</li>
<li>本次查询操作的执行时间小于 <code>1</code> 毫秒；</li>
<li>本次查询操作已遍历整个集合，没有被 <code>limit</code> 等语句限制。</li>
</ul>
<p>假如我们在命令中使用了 <code>limit</code>，例如 <code>db.inven.find({number: {$gt:
6}}).limit(2).explain(&quot;executionStats&quot;)</code>，那么返回信息中就会包含 <code>limitAmount</code><br>字段，并且<code>nReturned</code> 字段和 <code>advanced</code> 字段对应的值也会发生相应变化。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引支持 MongoDB 中查询的高效执行。如果没有索引，MongoDB<br>必须执行全文检索，即扫描集合中的每个文档，以选择与查询语句匹配的文档。如果查询存在适当的索引，MongoDB 可以使用索引来限制它必须检查的文档数。</p>
<p>MongoDB 的索引是特殊的数据结构，这种结构叫做<br>B-tree，它以易于遍历的形式存储集合数据集的一小部分。索引存储特定字段或字段集的值，按字段的值排序。索引条目的排序支持有效的等式匹配和基于范围的查询操作。此外，MongoDB<br>可以使用索引中的顺序返回排序结果。</p>
<p>下图描述了使用索引选择和排序匹配文档的查询过程：<br><img src="https://images.gitbook.cn/8d649640-be88-11e9-9891-77a2f5d7a812" alt="在这里插入图片描述"><br>上图表示索引建立在集合 <code>user</code> 的 <code>score</code> 字段上，索引中记录着包含 <code>score</code> 字段的文档的位置。当发起查询操作时，MongoDB<br>会先从索引中检索，快速定位包含 <code>score</code> 字段的文档的位置，而不是扫描整个集合。</p>
<p>MongoDB 中的索引与其他数据库系统中的索引类似，它允许在集合级别定义索引，并支持文档的任何字段。</p>
<p>MongoDB 提供了非常多的索引类型来支持特定类型的数据和查询，例如单字段索引、复合索引、多键索引、文字索引、2d<br>索引、散列索引和稀疏索引等。接下来，我们将学习常用的单字段索引、复合索引和多键索引。</p>
<h4 id="单字段索引"><a href="#单字段索引" class="headerlink" title="单字段索引"></a>单字段索引</h4><p>创建索引的语法格式如下：</p>
<p>​<br>    db.collection.createIndex( <key and index type specification>, <options> )</options></key></p>
<p>假设要为集合 <code>inven</code> 的 <code>number</code> 字段创建单字段索引，对应示例如下：</p>
<p>​<br>    &gt; db.inven.createIndex({number: 1})<br>    {<br>        “createdCollectionAutomatically” : false,<br>        “numIndexesBefore” : 1,<br>        “numIndexesAfter” : 2,<br>        “ok” : 1<br>    }</p>
<p>结果文档中的 <code>numIndexesBefore</code> 表示本次索引创建前的索引数量，而 <code>numIndexesAfter</code><br>代表本次索引创建后的索引数量。在本次操作之前，我们从未为集合 <code>inven</code> 创建过索引，那么 <code>numIndexesBefore</code> 的值为什么是 <code>1</code><br>呢？实际上 mongoDB 为每个集合创建了默认的索引，默认索引的字段为 <code>_id</code>，所以本次操作后，<code>numIndexesAfter</code> 的值为 <code>2</code>。</p>
<p>我们可以通过对比索引建立前后的执行计划来了解索引对查询效率的影响，查看执行计划的命令如下：</p>
<p>​<br>    &gt; db.inven.find({number: {$gt: 6}}).explain()<br>    {<br>        “queryPlanner” : {<br>            “plannerVersion” : 1,<br>            “namespace” : “test.inven”,<br>            “indexFilterSet” : false,<br>            “parsedQuery” : {<br>                “number” : {<br>                    “$gt” : 6<br>                }<br>            },<br>            “winningPlan” : {<br>                “stage” : “FETCH”,<br>                “inputStage” : {<br>                    “stage” : “IXSCAN”,<br>                    “keyPattern” : {<br>                        “number” : 1<br>                    },<br>                    “indexName” : “number_1”,<br>                    “isMultiKey” : false,<br>                    “multiKeyPaths” : {<br>                        “number” : [ ]<br>                    },<br>                    “isUnique” : false,<br>                    “isSparse” : false,<br>                    “isPartial” : false,<br>                    “indexVersion” : 2,<br>                    “direction” : “forward”,<br>                    “indexBounds” : {<br>                        “number” : [<br>                            “(6.0, inf.0]”<br>                        ]<br>                    }<br>                }<br>            },<br>            “rejectedPlans” : [ ]<br>        },<br>        “serverInfo” : {<br>            “host” : “asyncdeMacBook-Pro.local”,<br>            “port” : 27017,<br>            “version” : “4.0.10”,<br>            “gitVersion” : “c389e7f69f637f7a1ac3cc9fae843b635f20b766”<br>        },<br>        “ok” : 1<br>    }</p>
<p>将本次执行计划与索引创建前的执行计划进行对比，可以发现 <code>stage</code> 发生了变化：</p>
<ul>
<li>建立索引前：<code>stage</code> 为 <code>COLLSCAN</code>，即扫描整个集合。</li>
<li>建立索引后：<code>stage</code> 为 <code>IXSCAN</code>，即按索引检索文档。</li>
</ul>
<p>相对于整个扫描整个集合来说，按索引检索文档的速度显然更快。</p>
<p>除了为文档指定的字段创建索引之外，我们还可以为内嵌文档的字段建立索引。假设文档结构如下：</p>
<p>​<br>    {<br>      “_id”: 1,<br>      “score”: 1034,<br>      “location”: { state: “NY”, city: “New York” }<br>    }</p>
<p>为内嵌文档中的 <code>location</code> 字段创建索引的示例如下：</p>
<p>​<br>    &gt; db.collection.createIndex( { location: 1 } )</p>
<p>为内嵌文档 <code>location</code> 中的 <code>state</code> 字段创建索引的示例如下：</p>
<p>​<br>    &gt; db.collection.createIndex( { “location.state”: 1 } )</p>
<p>要注意的是，MongoDB 可以从任一方向遍历索引，所以对于单字段索引来说，索引键的排序顺序并不重要。</p>
<h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><p>单字段索引并不能满足所有需求，有时候我们需要为文档建立更多的索引，多个字段的组合索引在 MongoDB 中称为复合索引。创建复合索引的语法格式如下：</p>
<p>​<br>    db.collection.createIndex( { <field1>: <type>, <field2>: <type2>, … } )</type2></field2></type></field1></p>
<p><code>&lt;type&gt;</code> 为 <code>1</code> 代表升序，<code>-1</code><br>代表降序。索引键的排序顺序（即升序或降序）在复合索引中是非常重要的，它可以确定索引是否支持排序操作。准备以下数据：</p>
<p>​<br>    &gt; db.indx.insertMany([<br>    … {_id: 1, name: “James”, number: 6, h: 203, w: 222},<br>    … {_id: 2, name: “Wade”, number: 3, h: 193, w: 220},<br>    … {_id: 3, name: “Kobe”, number: 24, h: 198, w: 212},<br>    … {_id: 4, name: “Yao”, number: 11, h: 226, w: 308},<br>    … {_id: 5, name: “Jd”, number: 23, h: 198, w: 216}<br>    … ])</p>
<p>然后为身高和体重这两个字段创建索引。其中，身高索引为升序，体重索引为降序。对应示例如下：</p>
<p>​<br>    &gt; db.indx.createIndex({h: 1, w: -1})<br>    {<br>        “createdCollectionAutomatically” : false,<br>        “numIndexesBefore” : 1,<br>        “numIndexesAfter” : 2,<br>        “ok” : 1<br>    }</p>
<p>索引创建成功后，我们来做一个实验：我们希望查询结果先按升高进行升序排序，然后按体重进行降序排序。对应示例如下：</p>
<p>​<br>    &gt; db.indx.find().sort({h: 1, w: -1})<br>    { “_id” : 2, “name” : “Wade”, “number” : 3, “h” : 193, “w” : 220 }<br>    { “_id” : 5, “name” : “Jd”, “number” : 23, “h” : 198, “w” : 216 }<br>    { “_id” : 3, “name” : “Kobe”, “number” : 24, “h” : 198, “w” : 212 }<br>    { “_id” : 1, “name” : “James”, “number” : 6, “h” : 203, “w” : 222 }<br>    { “_id” : 4, “name” : “Yao”, “number” : 11, “h” : 226, “w” : 308 }</p>
<p>可以看到，身高同为 <code>198</code> 的两个球员会按体重进行降序排序，所以球员 <code>jd</code> 排在球员 <code>kobe</code><br>之前。假如我们希望升高和体重都按升序排序呢？对应示例如下：</p>
<p>​<br>    &gt; db.indx.find().sort({h: 1, w: 1})<br>    { “_id” : 2, “name” : “Wade”, “number” : 3, “h” : 193, “w” : 220 }<br>    { “_id” : 3, “name” : “Kobe”, “number” : 24, “h” : 198, “w” : 212 }<br>    { “_id” : 5, “name” : “Jd”, “number” : 23, “h” : 198, “w” : 216 }<br>    { “_id” : 1, “name” : “James”, “number” : 6, “h” : 203, “w” : 222 }<br>    { “_id” : 4, “name” : “Yao”, “number” : 11, “h” : 226, “w” : 308 }</p>
<p>身高同为 <code>198</code> 的两个球员按体重进行升序排序 ，返回文档我们预想的结果相同，这有什么问题吗？由于 <code>sort()</code><br>支持这种排序规则，所以从结果上来看是没有问题的。实际上这两种排序方式的执行计划是不同的，我们可以使用 <code>explain()</code> 查看它们的执行计划：</p>
<ul>
<li><code>{h: 1, w: -1}</code> 的执行计划显示 <code>stage</code> 为 <code>IXSCAN</code>；</li>
<li><code>{h: 1, w: 1}</code> 的执行计划显示 <code>stage</code> 为 <code>COLLSCAN</code>；</li>
</ul>
<p>也就是说，如果索引不支持查询时所用的排序规则，那么索引将不会发挥作用。反之，如果索引支持查询时所用的排序规则，那么索引将会发挥作用。</p>
<h4 id="索引前缀"><a href="#索引前缀" class="headerlink" title="索引前缀"></a>索引前缀</h4><p>索引前缀（也有人称前缀索引）是索引字段的起始子集。假设有以下复合索引：</p>
<p>​<br>    { “number”: 1, “h”: 1, “w”: 1 }</p>
<p>该复合索引的索引前缀为：</p>
<ul>
<li><code>{ number: 1 }</code></li>
<li><code>{ number: 1, h: 1 }</code></li>
</ul>
<p>MongoDB 允许我们在以下字段中使用索引进行查询：</p>
<ul>
<li><code>number</code> 字段</li>
<li><code>number</code> 字段和 <code>h</code> 字段</li>
<li><code>number</code> 字段、<code>h</code>字段和 <code>w</code>字段</li>
</ul>
<p>这是因为查询时使用 <code>number</code> 或 <code>number &amp; h</code> 组合作为索引前缀。如果使用其他索引前缀， 那就无法使用索引。其他前缀组合如下：</p>
<ul>
<li><code>h</code> 字段</li>
<li><code>w</code> 字段</li>
<li><code>h</code>字段和 <code>w</code>字段</li>
</ul>
<p>也就是说，当使用类似 <code>db.indx.find({h: 1, w: 1})</code> 这样的查询语句时，<code>stage</code> 的值为<br><code>COLLSCAN</code>，即索引不起作用。而使用类似 <code>db.indx.find({h: 1, w: 1, number: 1})</code><br>这样的语句时，<code>stage</code> 的值为 <code>IXSCAN</code>，即索引起作用。</p>
<h4 id="多键索引"><a href="#多键索引" class="headerlink" title="多键索引"></a>多键索引</h4><p>在创建索引时，如果设定的字段值是数组，那么 MongoDB 就会为数组中的每一个元素创建索引键。多键索引的创建是完全自动的，不需要显式指定。准备以下数据：</p>
<p>​<br>    &gt; db.mindx.insertMany([<br>    { _id: 5, type: “food”, item: “aaa”, ratings: [ 5, 8, 9 ] },<br>    { _id: 6, type: “food”, item: “bbb”, ratings: [ 5, 9 ] },<br>    { _id: 7, type: “food”, item: “ccc”, ratings: [ 9, 5, 8 ] },<br>    { _id: 8, type: “food”, item: “ddd”, ratings: [ 9, 5 ] },<br>    { _id: 9, type: “food”, item: “eee”, ratings: [ 5, 9, 5 ] }<br>    ])</p>
<p>为 <code>ratings</code> 字段创建索引的示例如下：</p>
<p>​<br>    &gt; db.mindx.createIndex( { ratings: 1 } )<br>    {<br>        “createdCollectionAutomatically” : false,<br>        “numIndexesBefore” : 1,<br>        “numIndexesAfter” : 2,<br>        “ok” : 1<br>    }</p>
<p>由于 <code>ratings</code> 字段的值是数组，所以这个索引并不是单字段索引，而是多键索引。当我们执行 <code>db.mindx.find( { ratings: [
5, 9 ] } )</code> 这样的命令时，索引会发挥作用，执行计划中<code>stage</code> 的值为 <code>IXSCAN</code>。要注意的是，MongoDB 不允许创建超过 1<br>个数组的复合多键索引。假设有如下文档结构：</p>
<p>​<br>    { _id: 1, a: [ 1, 2 ], b: [ 1, 2 ], category: “AB - both arrays” }</p>
<p>当我们试图创建类似 <code>{a: 1, b: 1}</code> 这样的复合多键索引时，会得到错误提示：</p>
<p>​<br>    {<br>        “ok” : 0,<br>        “errmsg” : “cannot index parallel arrays [b] [a]”,<br>        “code” : 171,<br>        “codeName” : “CannotIndexParallelArrays”<br>    }</p>
<p>如果文档结构为：</p>
<p>​<br>    { _id: 1, a: 99, b: [ 1, 2 ], category: “A” }<br>    { _id: 2, a: [3, 5], b: 77, category: “B” }</p>
<p>那么当我们试图创建类似 <code>{a: 1, b: 1}</code> 或 <code>{a: -1, b: -1}</code>这样的复合多键索引时，命令将得到正确的执行。</p>
<h3 id="索引综合知识"><a href="#索引综合知识" class="headerlink" title="索引综合知识"></a>索引综合知识</h3><p>下面将介绍一些与索引相关的技巧或知识，包括索引的查看、创建删除和对数据库的影响等。</p>
<h4 id="如何查看已有的索引"><a href="#如何查看已有的索引" class="headerlink" title="如何查看已有的索引"></a>如何查看已有的索引</h4><p>我们可以使用 <code>db.collection.getIndexes()</code> 方法查询集合中已有的索引。假设要查询集合 <code>indx</code> 已有的索引，对应示例如下：</p>
<p>​<br>    &gt; db.indx.getIndexes()<br>    [<br>        {<br>            “v” : 2,<br>            “key” : {<br>                “<em>id” : 1<br>            },<br>            “name” : “_id</em>“,<br>            “ns” : “test.indx”<br>        },<br>        {<br>            “v” : 2,<br>            “key” : {<br>                “number” : 1,<br>                “h” : 1,<br>                “w” : 1<br>            },<br>            “name” : “number_1_h_1_w_1”,<br>            “ns” : “test.indx”<br>        }<br>    ]</p>
<p>结果文档中的 <code>name</code> 代表索引名称，<code>key</code> 代表索引键，<code>ns</code> 代表集合名称。</p>
<h4 id="索引的命名"><a href="#索引的命名" class="headerlink" title="索引的命名"></a>索引的命名</h4><p>默认情况下，索引的名称是字段与排序的组合词，例如复合多键索引 <code>{item: 1, ratings: -1}</code> 的索引名称为<br><code>item_1_ratings_-1</code>。当然，我们也可以在创建索引的时候指定索引名称，对应示例如下：</p>
<p>​<br>    &gt; db.mindx.createIndex( {item: 1,  ratings: -1 }, {name: “irats”} )<br>    {<br>        “createdCollectionAutomatically” : false,<br>        “numIndexesBefore” : 1,<br>        “numIndexesAfter” : 2,<br>        “ok” : 1<br>    }</p>
<p>命令执行后，集合 <code>mindx</code> 会多出一个名为 <code>irats</code> 的复合多键索引。</p>
<h4 id="如何删除索引"><a href="#如何删除索引" class="headerlink" title="如何删除索引"></a>如何删除索引</h4><p>删除索引的方法为 <code>db.collection.dropIndex()</code>，我们可以选择删除多个索引或删除指定的索引。假如我们将索引名称传递给<br><code>dropindex()</code>，那么就可以删除这个索引。假如我们没有传递任何参数，那么将会删除对应集合中的所有索引。假设要删除集合 <code>indx</code> 中名为<br><code>number_1_h_1_w_1</code> 的索引。对应示例如下：</p>
<p>​<br>    &gt; db.indx.dropIndex(“number_1_h_1_w_1”)<br>    { “nIndexesWas” : 2, “ok” : 1 }</p>
<p>而如果要删除集合 <code>mindx</code> 中的所有索引，我们只需要执行如下命令即可：</p>
<p>​<br>    &gt; db.mindx.dropIndexes()<br>    {<br>        “nIndexesWas” : 2,<br>        “msg” : “non-_id indexes dropped for collection”,<br>        “ok” : 1<br>    }</p>
<p>要注意的是，默认索引 <code>_id</code> 不会被删除。</p>
<h4 id="索引的创建与数据库性能"><a href="#索引的创建与数据库性能" class="headerlink" title="索引的创建与数据库性能"></a>索引的创建与数据库性能</h4><p>索引是个好东西，但不能盲目地为所有字段都建立索引，这是因为索引的创建和维护也是有一定的代价。</p>
<p><strong>索引的创建</strong></p>
<p>在索引构建完成之前，集合所属的数据库将不可执行读或写操作。所以，如果需要构建大型索引，请考虑使用后台创建模式，即<br><code>backound</code>。后台创建模式的语法很简单，只需要在创建索引时加上 <code>{ background: true }</code> 即可。例如为集合 <code>mindx</code> 中的<br><code>item</code> 字段创建索引，并希望在索引创建过程中避免对数据库读写操作的影响，对应的示例如下：</p>
<p>​<br>    &gt; db.mindx.createIndex( { item: 1 }, {background: true} )<br>    {<br>        “createdCollectionAutomatically” : false,<br>        “numIndexesBefore” : 2,<br>        “numIndexesAfter” : 3,<br>        “ok” : 1<br>    }</p>
<p>这种情况下，索引的创建将会在后台进行，不会影响数据库读写操作。但因此付出的代价是在创建索引过程中阻塞当前的 Mongoshell 会话，直到索引创建完成。当<br>Mongoshell 阻塞时，我们想要向 MongoDB<br>发出命令就必须开启另一个连接。后台创建索引所要花费的时间会比在前台创建的要长，如果数据量较大或操作频繁，可以将索引的创建时间放在“夜深人静”的时候。</p>
<p>这种长时间的索引构建让人焦虑，人们希望能够看到索引的创建状态或终止创建。索引创建状态的查看可以使用 <code>db.currentOp()</code> 命令，终止创建的命令为<br><code>db.killOp()</code>。</p>
<p><strong>索引的维护</strong></p>
<p>MongoDB 会自动维护创建了索引的字段。当我们在集合中添加或删除文档时，就会触发 MongoDB<br>的索引维护。如果集合中的文档数量较多，且建立了索引的字段也较多，那么索引维护也将会成为数据库的一笔开销。</p>
<h3 id="索引小结"><a href="#索引小结" class="headerlink" title="索引小结"></a>索引小结</h3><p>以上就是本篇对执行计划和索引的介绍，现在我们用一句话概括：执行计划用于判断查询效率，如果对查询效率不满意，可以考虑为字段建立索引。</p>
<h2 id="进阶篇-一-数据模型"><a href="#进阶篇-一-数据模型" class="headerlink" title="进阶篇 一 数据模型"></a>进阶篇 一 数据模型</h2><p>MongoDB 不强制执行文档结构，也就是说我们不需要在数据插入前定义文档的结构，也不要求集合中的文档具有相同的结构。要知道，在 MySQL<br>这样的关系型数据库中，我们必须在插入数据前定义数据模型（即创建表和定义字段），否则无法向将数据写入到数据库中。MongoDB<br>的文档结构非常灵活，具体表现在以下方面：</p>
<ul>
<li>集合中的文档可以使用不同的字段；</li>
<li>文档的字段类型可以不同；</li>
<li>假如要更改文档的结构（例如删除字段、添加字段或更新字段值的类型），只需要执行更新操作即可。</li>
</ul>
<h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><p>为 MongoDB<br>应用程序设计数据模型的关键决策围绕文档结构以及应用程序如何表示数据之间的关系。MongoDB允许将相关数据嵌入到单个文档中。MongoDB<br>中有两种文档结构：嵌入式和规范化。</p>
<h4 id="嵌入式结构"><a href="#嵌入式结构" class="headerlink" title="嵌入式结构"></a>嵌入式结构</h4><p>MongoDB<br>允许将文档嵌入到字段或数组中，包含嵌入文档的文档结构叫做嵌入式结构。嵌入式结构通过在单个文档中存储相关数据来描述数据之间的关系或将数据关联在一起。嵌入式结构的文档如下：</p>
<p>​<br>    {<br>      _id: 1,<br>      username: “123xyz”,<br>      contact: {<br>        phone: “123-456-789”,<br>        email: “<a href="mailto:xyz@example.com" target="_blank" rel="noopener">xyz@example.com</a>“<br>      },<br>      access: {<br>        level: 5,<br>        group: “dev”<br>      }<br>    }</p>
<p>由于 <code>contact</code>字段 和 <code>access</code> 字段的值是文档，所以这两个字段对应的值被称为嵌入式文档（又称内嵌文档），<code>_id</code> 为 <code>1</code><br>的文档则是它们的外层文档。我们可以使用点符号访问嵌入式文档中的字段，例如使用 <code>contact.phone</code> 这种方式访问 <code>contact</code> 中的<br><code>phone</code> 字段。</p>
<h4 id="规范化结构"><a href="#规范化结构" class="headerlink" title="规范化结构"></a>规范化结构</h4><p>规范化结构通过引用的方式来描述数据之间的关系或将数据关联在一起。这与 SQL 数据库中的 <code>Foreign key</code><br>概念相似。规范化结构关联文档的方式如下图所示：<br><img src="https://images.gitbook.cn/a2b82e80-be88-11e9-8cae-739b42a884cb" alt="在这里插入图片描述"><br>上图示例中，集合 <code>contact</code> 与集合 <code>access</code> 中的 <code>user_id</code> 字段均引用自集合 <code>user</code> 中的 <code>_id</code><br>字段。规范化结构的存在使得我们可以描述更复杂的多对多关系。</p>
<h3 id="文档结构与模型关系"><a href="#文档结构与模型关系" class="headerlink" title="文档结构与模型关系"></a>文档结构与模型关系</h3><p>嵌入式结构和规范化结构的适用场景不同，我们在设计数据模型时应该考虑哪些因素呢？下面将通过几个示例来了解这些场景。</p>
<p>嵌入式结构很适合有包含关系的情况，以下示例用规范化结构来表示客户 <code>James</code> 与其收货地址的关系：</p>
<p>​<br>    {<br>       _id: “1”,<br>       user_id: 30,<br>       name: “James”<br>    }<br>    {<br>       user_id: “30”,<br>       address: “虹桥机场员工宿舍C区5楼”,<br>       city: “上海”,<br>       phone: “13005920000”,<br>       zip: “200020”<br>    }</p>
<p>记录收货地址信息的文档引用了用户信息文档中的用户 <code>user_id</code><br>字段。如果经常检索收货地址信息，那么就会发出多个查询。更好的数据模型是将用户信息和收货地址信息放在同一个文档，例如：</p>
<p>​<br>    {<br>       _id: “1”,<br>       user_id: 30,<br>       name: “James”,<br>       adres:<br>       {<br>         address: “虹桥机场员工宿舍C区5楼”,<br>         city: “上海”,<br>         phone: “13005920000”,<br>         zip: “200020”<br>       }<br>    }</p>
<p>使用嵌入式结构后，只需要一次查询就可以得到完整的结果。用户通常会有多个收货地址，即数据模型要满足一对多的关系。以下示例用规范化结构来表示客户 <code>James</code><br>与其多个收货地址的关系：</p>
<p>​<br>    {<br>       _id: <objectid1>,<br>       user_id: 30,<br>       name: “James”<br>    }<br>    {<br>         _id: <objectid2><br>       user_id: <objectid1>,<br>       address: “虹桥机场员工宿舍C区5楼”,<br>       city: “上海”,<br>       phone: “13005920000”,<br>       zip: “200020”<br>    }<br>    {<br>          _id: <objectid3><br>       user_id: <objectid1>,<br>       address: “白云机场员工宿舍A区6楼”,<br>       city: “广州”,<br>       phone: “13005920000”,<br>       zip: “510080”<br>    }</objectid1></objectid3></objectid1></objectid2></objectid1></p>
<p>也可以使用嵌入式结构来表示一对多关系，示例如下：</p>
<p>​<br>    {<br>       _id: “1”,<br>       user_id: 30,<br>       name: “James”,<br>       adres:[<br>       {<br>         address: “虹桥机场员工宿舍C区5楼”,<br>         city: “上海”,<br>         phone: “13005920000”,<br>         zip: “200020”<br>         },<br>         {<br>         address: “白云机场员工宿舍A区6楼”,<br>         city: “广州”,<br>         phone: “13005920000”,<br>         zip: “510080”<br>         }]<br>    }    </p>
<p>当然，用规范化结构来描述一对多关系也有好处。通常情况下，论坛用户会频繁地发布自己的观点（发帖或回帖），如果用嵌入式结构存储观点发布者和观点内容，那么就会造成发布者信息重复。对应示例如下：</p>
<p>​<br>    {<br>        title: “吉利星越大型试驾活动，发夹弯见！”,<br>        publisher_id: 29019,<br>        publisher: “车评人陈杨”,<br>        pdate: ISODate(“2019-01-01 12:03:36”),<br>        view: 32810,<br>        tag: [“吉利”, “星越”, “试驾”]<br>    }<br>    {<br>        title: “宝马排名飙升 评2019上半年豪华品牌销量”,<br>        publisher_id: 29019,<br>        publisher: “车评人陈杨”,<br>        pdate: ISODate(“2019-01-01 12:03:50”),<br>        view: 6020,<br>        tag: [“宝马”, “豪华”, “奔驰”]<br>    }<br>    {<br>        title: “试驾全新一代广汽传祺GA6”,<br>        publisher_id: 29019,<br>        publisher: “车评人陈杨”,<br>        pdate: ISODate(“2019-01-01 12:03:58”),<br>        view: 10751,<br>        tag: [“试驾”, “广汽”, “传祺”]<br>    }</p>
<p>用规范化结构存储论坛用户观点，就可以节省非常多的空间，对应示例如下：</p>
<p>​<br>    {<br>        _id: <objectid1><br>        username: “chenyang”,<br>        nickname: “车评人陈杨”<br>    }<br>    {<br>        _id: <objectid2><br>        title: “吉利星越大型试驾活动，发夹弯见！”,<br>        user_id: <objectid1>,<br>        pdate: ISODate(“2019-01-01 12:03:36”),<br>        view: 32810,<br>        tag: [“吉利”, “星越”, “试驾”]<br>    }<br>    {<br>        _id: <objectid3><br>        title: “宝马排名飙升 评2019上半年豪华品牌销量”,<br>        user_id: <objectid1>,<br>        pdate: ISODate(“2019-01-01 12:03:50”),<br>        view: 6020,<br>        tag: [“宝马”, “豪华”, “奔驰”]<br>    }<br>    {<br>        _id: <objectid4><br>        title: “试驾全新一代广汽传祺GA6”,<br>        user_id: <objectid1>,<br>        pdate: ISODate(“2019-01-01 12:03:58”),<br>        view: 10751,<br>        tag: [“试驾”, “广汽”, “传祺”]<br>    }</objectid1></objectid4></objectid1></objectid3></objectid1></objectid2></objectid1></p>
<p>嵌入式结构的读取操作性能比规范化结构更高，但嵌入式结构会导致数据重复，而规范化结构则不会。除了一对多关系之外，规范化结构还能够描述更复杂的多对多关系。</p>
<h3 id="树状数据模型"><a href="#树状数据模型" class="headerlink" title="树状数据模型"></a>树状数据模型</h3><p>嵌入式结构和规范化结构并不能满足所有的场景，例如树状关系的对象。<br><img src="https://images.gitbook.cn/b8594a80-be88-11e9-8cae-739b42a884cb" alt="在这里插入图片描述"><br>如上图所示，树状关系的对象或实体是编程中常见的结构，下面我们就来学习树状结构的数据模型。</p>
<h4 id="父引用树状数据模型"><a href="#父引用树状数据模型" class="headerlink" title="父引用树状数据模型"></a>父引用树状数据模型</h4><p>父引用树状数据模型通过在子节点中存储对父节点的引用来组织树状结构中的文档，对应示例如下：</p>
<p>​<br>    &gt; db.trees1.insertMany([<br>    { _id: “MongoDB”, parent: “Databases” },<br>    { _id: “dbm”, parent: “Databases” },<br>    { _id: “Databases”, parent: “Programming” },<br>    { _id: “Languages”, parent: “Programming” },<br>    { _id: “Programming”, parent: “Books” },<br>    { _id: “Books”, parent: null }<br>    ])</p>
<p>在这样的树状结构中，我们可以直接检索某个节点的父节点，例如检索 <code>MongoDB</code> 节点的父节点的示例如下：</p>
<p>​<br>    &gt; db.trees1.findOne({_id: “MongoDB”}).parent<br>    Databases</p>
<p>也可以直接检索某个节点的子节点，例如检索 <code>Databases</code> 节点的子节点的示例如下：</p>
<p>​<br>    &gt; db.trees1.find({parent: “Databases”})<br>    { “_id” : “MongoDB”, “parent” : “Databases” }<br>    { “_id” : “dbm”, “parent” : “Databases” }</p>
<p>我们还可以为父节点字段创建索引，以提高查询效率。为集合 <code>trees1</code> 的父节点字段 <code>parent</code> 创建索引的示例如下：</p>
<p>​<br>    &gt; db.trees1.createIndex( { parent: 1 } )</p>
<h4 id="子引用树状数据模型"><a href="#子引用树状数据模型" class="headerlink" title="子引用树状数据模型"></a>子引用树状数据模型</h4><p>既然父节点可以存储在模型中，那么也可以在父节点中存储子节点的引用来组织树状结构中的文档，对应示例如下：</p>
<p>​<br>    &gt; db.trees2.insertMany([<br>    { _id: “MongoDB”, children: []},<br>    { _id: “dbm”, children: []},<br>    { _id: “Databases”, children: [ “MongoDB”, “dbm” ]},<br>    { _id: “Languages”, children: []},<br>    { _id: “Programming”, children: [ “Databases”, “Languages”]},<br>    { _id: “Books”, children: [ “Programming” ]}<br>    ])</p>
<p>在这样的树状结构中，我们可以直接检索某个节点的子节点，例如检索 <code>MongoDB</code> 节点的子节点的示例如下：</p>
<p>​<br>    &gt; db.trees2.findOne({_id: “Databases”}).children<br>    [ “MongoDB”, “dbm” ]</p>
<p>也可以直接检索某个节点的父节点，例如检索 <code>Languages</code> 节点的父节点。对应示例如下：</p>
<p>​<br>    &gt; db.trees2.find({children: “Languages”})<br>    { “_id” : “Programming”, “children” : [ “Databases”, “Languages” ] }</p>
<p>我们还可以为子节点字段创建索引，以提高查询效率。为集合 <code>trees2</code> 的子节点字段 <code>children</code> 创建索引的示例为：</p>
<p>​<br>    &gt; db.trees2.createIndex({children: 1})</p>
<h4 id="祖先阵列树状数据模型"><a href="#祖先阵列树状数据模型" class="headerlink" title="祖先阵列树状数据模型"></a>祖先阵列树状数据模型</h4><p>后来又扩展出存储所有父节点数组和上层父节点的祖先阵列树状数据模型，这种模型为快速定位指定节点的后代节点和祖先节点提供了有效的解决办法，对应如下：</p>
<p>​<br>    &gt; db.trees3.insertMany([<br>    {_id: “MongoDB”, ancestors: [“Books”, “Programming”, “Databases”], parent: “Databases”},<br>    {_id: “dbm”, ancestors: [“Books”, “Programming”, “Databases”], parent: “Databases”},<br>    {_id: “Databases”, ancestors: [“Books”, “Programming”], parent: “Programming”},<br>    {_id: “Languages”, ancestors: [“Books”, “Programming”], parent: “Programming”},<br>    {_id: “Programming”, ancestors: [“Books”], parent: “Books”},<br>    {_id: “Books”, ancestors: [ ], parent: null}<br>    ])</p>
<p>在这样的树状结构中，我们可以直接检索某个节点的祖先节点，例如检索 <code>MongoDB</code> 节点的祖先节点的示例如下：</p>
<p>​<br>    &gt; db.trees3.findOne({_id: “MongoDB”}).ancestors<br>    [ “Books”, “Programming”, “Databases” ]</p>
<p>也可以直接检索某个节点的所有后代节点，例如检索 <code>Languages</code> 节点的所有后代节点的示例如下：</p>
<p>​<br>    &gt; db.trees3.find({ancestors: “Programming”})<br>    { “_id” : “MongoDB”, “ancestors” : [ “Books”, “Programming”, “Databases” ], “parent” : “Databases” }<br>    { “_id” : “dbm”, “ancestors” : [ “Books”, “Programming”, “Databases” ], “parent” : “Databases” }<br>    { “_id” : “Databases”, “ancestors” : [ “Books”, “Programming” ], “parent” : “Programming” }<br>    { “_id” : “Languages”, “ancestors” : [ “Books”, “Programming” ], “parent” : “Programming” }</p>
<p>我们还可以为祖先数组字段创建索引，以提高查询效率。为集合 <code>trees3</code> 的祖先数组字段 <code>ancestors</code> 创建索引的示例为：</p>
<p>​<br>    &gt; db.trees3.createIndex({ancestors: 1})</p>
<h4 id="路径树状数据模型"><a href="#路径树状数据模型" class="headerlink" title="路径树状数据模型"></a>路径树状数据模型</h4><p>路径树状数据模型将存储文档中的每个树节点，并以字符串的形式存储祖先节点或路径。这种数据模型在检索时需要使用正则表达式，同时也允许通过部分路径进行检索，对应示例如下：</p>
<p>​<br>    &gt; db.trees4.insertMany([<br>    {_id: “Books”, path: null},<br>    {_id: “Programming”, path: “,Books,”},<br>    {_id: “Databases”, path: “,Books,Programming,”},<br>    {_id: “Languages”, path: “,Books,Programming,”},<br>    {_id: “MongoDB”, path: “,Books,Programming,Databases,”},<br>    {_id: “dbm”, path: “,Books,Programming,Databases,”}<br>    ])</p>
<p>我们可以对这样的结构按照路径进行排序，对应示例如下：</p>
<p>​<br>    &gt; db.trees4.find().sort({ path: 1})<br>    { “_id” : “Books”, “path” : null }<br>    { “_id” : “Programming”, “path” : “,Books,” }<br>    { “_id” : “Databases”, “path” : “,Books,Programming,” }<br>    { “_id” : “Languages”, “path” : “,Books,Programming,” }<br>    { “_id” : “MongoDB”, “path” : “,Books,Programming,Databases,” }<br>    { “_id” : “dbm”, “path” : “,Books,Programming,Databases,” }</p>
<p>在这样的树状结构中，我们可以直接检索某个节点的所有后代节点，例如检索 <code>Programming</code> 节点所有后代节点的示例如下：</p>
<p>​<br>    &gt; db.trees4.find({path: /,Programming,/})<br>    { “_id” : “Databases”, “path” : “,Books,Programming,” }<br>    { “_id” : “Languages”, “path” : “,Books,Programming,” }<br>    { “_id” : “MongoDB”, “path” : “,Books,Programming,Databases,” }<br>    { “_id” : “dbm”, “path” : “,Books,Programming,Databases,” }</p>
<p>由于查询语句使用的是正则表达式，所以我们可以写出更灵活的查询语句。例如检索以 <code>Books</code> 节点开头的所有后代节点：</p>
<p>​<br>    &gt; db.trees4.find({path: /^,Books,/})<br>    { “_id” : “Programming”, “path” : “,Books,” }<br>    { “_id” : “Databases”, “path” : “,Books,Programming,” }<br>    { “_id” : “Languages”, “path” : “,Books,Programming,” }<br>    { “_id” : “MongoDB”, “path” : “,Books,Programming,Databases,” }<br>    { “_id” : “dbm”, “path” : “,Books,Programming,Databases,” }</p>
<p>我们还可以为路径字段创建索引，以提高查询效率。为集合 <code>trees4</code> 的路径字段 <code>path</code> 创建索引的示例为：</p>
<p>​<br>    &gt; db.trees4.createIndex({path: 1})</p>
<h4 id="嵌套集树状数据模型"><a href="#嵌套集树状数据模型" class="headerlink" title="嵌套集树状数据模型"></a>嵌套集树状数据模型</h4><p>祖先阵列树状数据模型为快速定位指定节点的后代节点和祖先节点提供了有效的解决办法，而嵌套集树状数据模型的出现则是为快速定位指定节点的子树。嵌套集树状数据模型的节点结构如下图所示：<br><img src="https://images.gitbook.cn/cfd3ba60-be88-11e9-9891-77a2f5d7a812" alt="在这里插入图片描述"><br>每个节点会被访问两次：首次访问时和返程时，访问规则为深度优先。嵌套集存储文档中的每个树节点和父节点的 <code>_id</code>，并在 <code>left</code><br>字段中记录首次访问时的序号、在 <code>right</code> 字段中记录返程时的序号（序号为递增数字，例如 1~$+\infty$）。</p>
<p>以下示例采用嵌套集树状数据模型进行建模：</p>
<p>​<br>    &gt; db.tree5.insertMany([<br>    {_id: “Books”, parent: 0, left: 1, right: 12},<br>    {_id: “Programming”, parent: “Books”, left: 2, right: 11},<br>    {_id: “Languages”, parent: “Programming”, left: 3, right: 4},<br>    {_id: “Databases”, parent: “Programming”, left: 5, right: 10},<br>    {_id: “MongoDB”, parent: “Databases”, left: 6, right: 7},<br>    {_id: “dbm”, parent: “Databases”, left: 8, right: 9}<br>    ])</p>
<p>从建模语句可以看出，<code>left</code> 字段值越小则节点的层级越高，<code>right</code><br>字段的值越小则节点的层级越低。根据这个规律，我们可以快速定位某个节点的所有后代节点，例如检索 <code>Databases</code> 节点所有后代节点的示例如下：</p>
<p>​<br>    &gt; var databaseCategory = db.tree5.findOne( { _id: “Databases” } );<br>    &gt; db.tree5.find( { left: { $gt: databaseCategory.left }, right: { $lt: databaseCategory.right } } );</p>
<pre><code>{ &quot;_id&quot; : &quot;MongoDB&quot;, &quot;parent&quot; : &quot;Databases&quot;, &quot;left&quot; : 6, &quot;right&quot; : 7 }
{ &quot;_id&quot; : &quot;dbm&quot;, &quot;parent&quot; : &quot;Databases&quot;, &quot;left&quot; : 8, &quot;right&quot; : 9 }</code></pre><p>要注意的是，在修改嵌套集树状结构时要付出的代价高于其他树状结构，因此嵌套集树状数据模型适合用于结构极少改动的场景。</p>
<h3 id="数据模型小结"><a href="#数据模型小结" class="headerlink" title="数据模型小结"></a>数据模型小结</h3><p>虽然 MongoDB 不强制执行文档结构，但一个合适的数据模型可以有效地提高查询效率或减少数据冗余。</p>
<h2 id="进阶篇-二-提高数据服务可用性的复制集"><a href="#进阶篇-二-提高数据服务可用性的复制集" class="headerlink" title="进阶篇 二 提高数据服务可用性的复制集"></a>进阶篇 二 提高数据服务可用性的复制集</h2><p>MongoDB<br>中的复制指的是将数据同步在多个服务器。复制操作将会在多个服务器上建立数据副本，这些副本的集合称为复制集，它们存储的内容与主服务器上的内容一致。建立了复制集之后，就可以在主服务器出现故障或无法连接的情况下保证数据服务可用。</p>
<h3 id="复制集成员"><a href="#复制集成员" class="headerlink" title="复制集成员"></a>复制集成员</h3><p>MongoDB<br>的复制集可以支持多个节点，但要求至少有两个节点。任何情况下都只有一个主节点（即主服务器），它负责处理客户端发出的命令。除主节点之外的所有节点都称为从节点，它们会主动同步主节点中的数据。在<br>MongoDB 中，主节点称为 Primary，从节点称为 Secondarie。</p>
<h4 id="主节点-Primary"><a href="#主节点-Primary" class="headerlink" title="主节点 Primary"></a>主节点 Primary</h4><p>主节点是复制集中唯一一个可以接收写操作的成员。MongoDB 在主节点上执行写操作，并将操作记录在主节点的 oplog<br>中，从节点会复制主节点的操作记录，然后执行相同操作以实现数据同步的目的。下图描述了由三个成员组成的复制集的成员关系：<br><img src="https://images.gitbook.cn/e1dabfb0-be88-11e9-9891-77a2f5d7a812" alt="在这里插入图片描述"><br>这个复制集中有两个从节点和一个主节点。主节点接收客户端发起的写操作，从节点通过 oplog<br>实现数据同步。要注意的是，复制集中的所有从节点都可以接收读操作，但默认情况下读取操作依然是交给主节点。如果想要更改读取规则，可以查阅官方文档 [Read<br>Preference](<a href="https://docs.mongodb.com/manual/core/read-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/core/read-</a><br>preference/)。要注意的是，每个复制集最多可拥有 50 名成员。</p>
<h4 id="从节点-Secondary"><a href="#从节点-Secondary" class="headerlink" title="从节点 Secondary"></a>从节点 Secondary</h4><p>从节点中存储的是主节点的数据副本。从节点将主节点中的 oplog<br>操作应用于自身，从而实现数据同步。要注意的是，这个“数据同步”的操作是异步进行的。下图描述了由三个成员组成的复制集的数据同步关系：<br><img src="https://images.gitbook.cn/fc05f7b0-be88-11e9-b3d9-13b3b1d36699" alt="在这里插入图片描述"><br>子节点会同步主节点上的操作，以实现数据同步。另外，各节点之间通过心跳（Heartbeat）来判断是否可用，假如某个节点在 10 秒内没有相应其他节点发出的<br>Heartbeat，那么它将会被标记为“掉线”，意为不可用或不可访问。</p>
<h3 id="复制的基石—操作日志"><a href="#复制的基石—操作日志" class="headerlink" title="复制的基石—操作日志"></a>复制的基石—操作日志</h3><p>上面提到，从节点的数据同步操作其实是执行主节点中执行过的操作。所有从节点都会拷贝主节点上的<br>[<code>local.oplog.rs</code>](<a href="https://docs.mongodb.com/manual/reference/local-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/local-</a><br>database/#local.oplog.rs) 文件，即 oplog。oplog 记录主节点中的改动操作，但不记录读取操作。oplog<br>是一个特殊的上限集合，它支持基于顺序插入和检索文档的高吞吐操作。上限集合的大小是固定的，在达到最大记录数之后，如果再有新的记录传入，它会覆盖掉最早的记录。</p>
<p>从 MongoDB4.0 开始，我们可以使用<br><a href="https://docs.mongodb.com/manual/reference/command/replSetResizeOplog/#dbcmd.replSetResizeOplog" target="_blank" rel="noopener"><code>oplogSizeMB</code>](https://docs.mongodb.com/manual/reference/configuration-<br>options/#replication.oplogSizeMB) 在创建时设置 oplog 的大小，或者使用<br>[<code>replSetResizeOplog</code></a><br>使其能够突破上限集合的限制。假设我们想要将 oplog 的大小设置为 <code>16000</code> 兆字节，对应命令如下：</p>
<p>​<br>    db.adminCommand({replSetResizeOplog: 1, size: 16000})</p>
<p>当第一次启用复制集，且未指定 oplog 大小时，MongoDB 将会创建一个默认大小的 oplog。oplog<br>的大小与操作系统和存储引擎相关，以下默认大小规则适用于类 Unix 操作系统和 Windows 操作系统：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>默认的 oplog 大小</th>
<th>下限</th>
<th>上限</th>
</tr>
</thead>
<tbody><tr>
<td>内存存储引擎</td>
<td>物理内存的 5%</td>
<td>50 MB</td>
<td>50 GB</td>
</tr>
<tr>
<td>WiredTiger 存储引擎</td>
<td>可用磁盘空间的 5%</td>
<td>990 MB</td>
<td>50 GB</td>
</tr>
<tr>
<td>MMAPv1 存储引擎</td>
<td>可用磁盘空间的 5%</td>
<td>990 MB</td>
<td>50 GB</td>
</tr>
</tbody></table>
<p>对于 64 位的 macOS，oplog 的大小是 192M 的物理内存或磁盘空间，上述三种存储引擎的默认值均相同。</p>
<h3 id="主节点故障的应对机制"><a href="#主节点故障的应对机制" class="headerlink" title="主节点故障的应对机制"></a>主节点故障的应对机制</h3><p>在主节点出现故障时，整个系统应该有一个应对机制。MongoDB 为复制集提供了主节点选举和数据回滚来确保数据服务可用和避免数据丢失。</p>
<h4 id="主节点选举"><a href="#主节点选举" class="headerlink" title="主节点选举"></a>主节点选举</h4><p>当主节点被标记为“掉线”，那么就意味着复制集需要一个新的主节点，否则将会导致服务不可用。这种情况下，复制集通过选举的方式来确定哪个成员会成为主节点。除了被标记为“掉线”之外，会触发选举的情况还有以下几种：</p>
<ul>
<li>复制集中添加了新的节点；</li>
<li>初始化复制集；</li>
<li>使用 <code>rs.stepDown()</code> 或者 <code>rs.reconfig()</code> 等方法维护复制集。</li>
</ul>
<p>下图描述了因为主节点“掉线”引起的选举：<br><img src="https://images.gitbook.cn/13d05c50-be89-11e9-bb6f-13203c9ddaa7" alt="在这里插入图片描述"><br>这是一个由三个成员组成的复制集，主节点“掉线”后，就需要在两个从节点中选出一个作为新的主节点。要注意的是，在选举完成之前，复制集无法处理写操作。在选出新的主节点之后，复制集的功能就会恢复正常。选举采用投票制，每个复制集最多只能拥有<br>7 名投票成员，这 7 个成员最多拥有 1 票。下图描述了由 9 个成员组成的复制集选举票权：<br><img src="https://images.gitbook.cn/25309a50-be89-11e9-8cae-739b42a884cb" alt="在这里插入图片描述"><br>绿色背景的节点表示节点可用，灰色背景表示节点“掉线”。votes<br>代表票权，对应的数值代表初始票数。如果投票成员数量为偶数，就有可能会造成多个节点的票数相同，甚至陷入无限选举的泥潭。为了避免这种情况，我们就需要增加一个仲裁（Arbiter）节点。仲裁节点拥有投票权，但它没有存储数据副本，也不能成为主节点。新增仲裁节点后，票数就会从偶数变成奇数。</p>
<p>默认情况下，从标记主节点“掉线”到选举出新的主节点的时间不会超过 12 秒，但 MongoDB 也提供了可修改的配置来调整该时间。</p>
<h4 id="数据回滚"><a href="#数据回滚" class="headerlink" title="数据回滚"></a>数据回滚</h4><p>当主节点发生故障，并选举出新的主节点时，MongoDB<br>将会在之前的主节点上执行回滚写操作。当“掉线”的主节点重新连接时，它将会以从节点的身份加入到复制集中，并回滚写操作，以便与其他成员的数据保持一致。MongoDB<br>4.0 版本对数据回滚进行了一些调整：</p>
<ul>
<li>回滚操作会在后台索引构建完成后进行；</li>
<li>不限制回滚的数据量；</li>
<li>回滚时间默认为 24 小时，且可以配置。</li>
</ul>
<p>4.0 版本之前，回滚的最大数据量为 300 兆字节，超过上限的数据量需要进行手动干预；回滚时间默认为 30 分钟，且不可配置。</p>
<h3 id="复制集部署实践"><a href="#复制集部署实践" class="headerlink" title="复制集部署实践"></a>复制集部署实践</h3><p>我们将介绍由三个成员组成的复制集部署过程，本次部署演示使用 MongoDB 官方的 Docker<br>镜像，并且不启用访问控制。如果想要了解有访问控制的复制集部署知识，可查阅官方文档 [Deploy New Replica Set With Keyfile<br>Access Control](<a href="https://docs.mongodb.com/manual/tutorial/deploy-replica-set-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/deploy-replica-set-</a><br>with-keyfile-access-control/#deploy-repl-set-with-auth)。</p>
<blockquote>
<p>注意：本次部署演示将在同一台计算机上启动多个 Docker 镜像，但实际工作中则是在多台不同的云服务器上部署 MongoDB。</p>
</blockquote>
<h4 id="部署复制集"><a href="#部署复制集" class="headerlink" title="部署复制集"></a>部署复制集</h4><p>在开始学习本节之前，请确保按照附章 <a href="http://docs.docker.com/v17.09/engine/installation/" target="_blank" rel="noopener">Docker<br>官方文档</a> 的指引安装 Docker。</p>
<p>首先，我们需要从 DockerHub 中拉取 MongoDB 官方提供的 mongo 服务镜像。在版本选择方面，我们选择最新版，即<br><code>latest</code>。对应命令如下：</p>
<p>​<br>    $ docker pull mongo:latest</p>
<p>将镜像拉取到本地后，分别使用 <code>run</code> 命令启动三个容器。启动时，我们需要为容器指定名称，以便后期使用，同时还需要指定复制集的名称，并设置容器的<br><code>bind_ip</code> 。对应命令如下：</p>
<p>​<br>    $ docker run –name mongoFir -d mongo:latest –replSet “mongoRepas” –bind_ip_all</p>
<pre><code>$ docker run --name mongoSec -d mongo:latest --replSet &quot;mongoRepas&quot; --bind_ip_all

$ docker run --name mongoThr -d mongo:latest --replSet &quot;mongoRepas&quot; --bind_ip_all </code></pre><p>这里将容器分别命名为 <code>mongoFir</code>、<code>mongoSec</code> 和 <code>mongoThr</code>，复制集的名称指定为 <code>mongoRepas</code>，并解除 mongo<br>对于<code>bind_ip</code> 的限制。由于在启动时未绑定 IP，所以我们需要使用 <code>grep</code> 命令找到每个容器对应的 IP。对应命令如下：</p>
<p>​<br>    $ docker inspect mongoFir | grep IPAddress</p>
<p>命令执行后，终端返回信息如下：</p>
<p>​<br>    “SecondaryIPAddresses”: null,<br>                “IPAddress”: “172.17.0.2”,<br>                        “IPAddress”: “172.17.0.2”</p>
<p>返回结果说明容器 <code>mongoFir</code> 绑定的 IP 为 <code>172.17.0.2</code>，mongo 服务的默认端口为 27017，所以名为 <code>mongoFir</code><br>的容器中的 mongo 服务完整地址为 <code>172.17.0.2:27017</code>。接着依次查找容器 <code>mongoSec</code> 和 <code>mongoThr</code> 对应的<br>mongo 服务地址。最终，三个容器对应的 mongo 服务地址依次如下：</p>
<p>​<br>    172.17.0.2:27017<br>    172.17.0.3:27017<br>    172.17.0.4:27017</p>
<p>容器启动成功后，就可以开始初始化复制集的工作了。首先，连接任意一个容器的 MongoShell，例如容器 <code>mongoFir</code>。对应命令如下：</p>
<p>​<br>    $ docker exec -it mongoFir mongo</p>
<p>命令执行后，就会连接上容器 <code>mongoFir</code> 的 MongoShell。然后在 MongoShell 中执行复制集初始化的命令：</p>
<p>​<br>    &gt; rs.initiate({<br>            _id: “mongoRepas”,<br>            members:[<br>                {_id: 0, host: “172.17.0.2”},<br>                {_id: 1, host: “172.17.0.3”},<br>                {_id: 2, host: “172.17.0.4”}<br>            ]<br>    })</p>
<p>在初始化复制集的时候指定了复制集的名称，并制定了成员的 <code>_id</code> 和对应的 IP 地址。命令执行后，MongoShell 输出如下文档：</p>
<p>​<br>    {<br>        “ok” : 1,<br>        “operationTime” : Timestamp(1564287051, 1),<br>        “$clusterTime” : {<br>            “clusterTime” : Timestamp(1564287051, 1),<br>            “signature” : {<br>                “hash” : BinData(0,”AAAAAAAAAAAAAAAAAAAAAAAAAAA=”),<br>                “keyId” : NumberLong(0)<br>            }<br>        }<br>    }</p>
<p>返回结果中的 <code>ok: 1</code> 代表复制集初始化成功。此时，MongoShell 的命令行标识符从 <code>&gt;</code> 变为<br><code>mongoRepas:SECONDARY&gt;</code>，即复制集的 Shell。在复制集 Shell 中使用 <code>rs.status()</code><br>命令查看当前复制集的状态信息，命令执行后输出如下内容：</p>
<p>​<br>    {<br>        “set” : “mongoRepas”,<br>        “date” : ISODate(“2019-07-28T04:36:02.341Z”),<br>        …<br>        “members” : [<br>            {<br>                “_id” : 0,<br>                “name” : “172.17.0.2:27017”,<br>                “health” : 1,<br>                “state” : 2,<br>                “stateStr” : “SECONDARY”,<br>                “uptime” : 3178,<br>                “optime” : {<br>                    “ts” : Timestamp(1564288553, 1),<br>                    “t” : NumberLong(3)<br>                },<br>                “optimeDate” : ISODate(“2019-07-28T04:35:53Z”),<br>                “syncingTo” : “172.17.0.3:27017”,<br>                “syncSourceHost” : “172.17.0.3:27017”,<br>                “syncSourceId” : 1,<br>                “infoMessage” : “”,<br>                “configVersion” : 1,<br>                “self” : true,<br>                “lastHeartbeatMessage” : “”<br>            },<br>            {<br>                “_id” : 1,<br>                “name” : “172.17.0.3:27017”,<br>                “health” : 1,<br>                “state” : 1,<br>                “stateStr” : “PRIMARY”,<br>                “uptime” : 1511,<br>                “optime” : {<br>                    “ts” : Timestamp(1564288553, 1),<br>                    “t” : NumberLong(3)<br>                },<br>                “optimeDurable” : {<br>                    “ts” : Timestamp(1564288553, 1),<br>                    “t” : NumberLong(3)<br>                },<br>                “optimeDate” : ISODate(“2019-07-28T04:35:53Z”),<br>                “optimeDurableDate” : ISODate(“2019-07-28T04:35:53Z”),<br>                “lastHeartbeat” : ISODate(“2019-07-28T04:36:01.077Z”),<br>                “lastHeartbeatRecv” : ISODate(“2019-07-28T04:36:02.234Z”),<br>                “pingMs” : NumberLong(0),<br>                “lastHeartbeatMessage” : “”,<br>                “syncingTo” : “”,<br>                “syncSourceHost” : “”,<br>                “syncSourceId” : -1,<br>                “infoMessage” : “”,<br>                “electionTime” : Timestamp(1564287718, 1),<br>                “electionDate” : ISODate(“2019-07-28T04:21:58Z”),<br>                “configVersion” : 1<br>            },<br>            {<br>                “_id” : 2,<br>                “name” : “172.17.0.4:27017”,<br>                “health” : 1,<br>                “state” : 2,<br>                “stateStr” : “SECONDARY”,<br>                “uptime” : 1511,<br>                “optime” : {<br>                    “ts” : Timestamp(1564288553, 1),<br>                    “t” : NumberLong(3)<br>                },<br>                “optimeDurable” : {<br>                    “ts” : Timestamp(1564288553, 1),<br>                    “t” : NumberLong(3)<br>                },<br>                “optimeDate” : ISODate(“2019-07-28T04:35:53Z”),<br>                “optimeDurableDate” : ISODate(“2019-07-28T04:35:53Z”),<br>                “lastHeartbeat” : ISODate(“2019-07-28T04:36:01.078Z”),<br>                “lastHeartbeatRecv” : ISODate(“2019-07-28T04:36:01.229Z”),<br>                “pingMs” : NumberLong(0),<br>                “lastHeartbeatMessage” : “”,<br>                “syncingTo” : “172.17.0.3:27017”,<br>                “syncSourceHost” : “172.17.0.3:27017”,<br>                “syncSourceId” : 1,<br>                “infoMessage” : “”,<br>                “configVersion” : 1<br>            }<br>        ],<br>        “ok” : 1,<br>        “operationTime” : Timestamp(1564288553, 1),<br>        “$clusterTime” : {<br>            “clusterTime” : Timestamp(1564288553, 1),<br>            “signature” : {<br>                “hash” : BinData(0,”AAAAAAAAAAAAAAAAAAAAAAAAAAA=”),<br>                “keyId” : NumberLong(0)<br>            }<br>        }<br>    }</p>
<p>结果文档的各字段含义如下：</p>
<table>
<thead>
<tr>
<th>字段名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>set</td>
<td>复制集名称</td>
</tr>
<tr>
<td>date</td>
<td>复制集创建时间</td>
</tr>
<tr>
<td>member</td>
<td>复制集成员数组</td>
</tr>
<tr>
<td>_id</td>
<td>成员 ID</td>
</tr>
<tr>
<td>name</td>
<td>成员名称</td>
</tr>
<tr>
<td>health</td>
<td>成员健康状况，1 代表健康</td>
</tr>
<tr>
<td>stateStr</td>
<td>成员身份</td>
</tr>
</tbody></table>
<p>从返回结果得知：</p>
<ul>
<li>复制集名称为 <code>mongoRepas</code>;</li>
<li>复制集创建时间为 <code>ISODate(&quot;2019-07-28T04:36:02.341Z&quot;)</code>；</li>
<li><code>_id</code> 为 <code>2</code> 的节点为主节点，其他两个节点为从节点；</li>
<li>三个节点都是健康的。</li>
</ul>
<h4 id="管理复制集成员"><a href="#管理复制集成员" class="headerlink" title="管理复制集成员"></a>管理复制集成员</h4><p>接下来，我们将学习如何添加或删除复制集中的成员。</p>
<h5 id="添加新成员"><a href="#添加新成员" class="headerlink" title="添加新成员"></a>添加新成员</h5><p>这里讨论的是为已存在的复制集添加新成员，对于“重新添加”已删除的成员这种操作，我们可以也将其理解为添加新成员。题外话：如果“重新添加”的成员数据相对较新，那么它的数据同步速度会比新成员的速度快。</p>
<p>上面提到过，一个复制集最多只能拥有七个投票成员。如果在添加新成员之前，目标复制集已经有了七个有投票权的成员，那么我们必须将新添加的成员设置为无投票权，或者删除掉目标复制集中的某个有投票权的成员，再将新添加的成员设置为有投票权的成员。</p>
<p>启动将要成为新成员的 MongoDB 后，在主节点的 Shell 中执行 <code>rs.add()</code> 命令即可实现新节点的添加。假设我们需要为复制集<br><code>repas</code> 添加一个无投票权的新成员。首先，我们需要启动一个 MongoDB 容器，并将其命名为 <code>mongoFou</code>。对应命令如下：</p>
<p>​<br>    $ docker run –name mongoFou -d mongo:latest –replSet “mongoRepas” –bind_ip_all</p>
<p>接着查看 <code>mongoFou</code> 的 IP 地址。对应命令如下：</p>
<p>​<br>    $ docker inspect mongoFou | grep IPAddress<br>    “SecondaryIPAddresses”: null,<br>                “IPAddress”: “172.17.0.5”,<br>                        “IPAddress”: “172.17.0.5”,</p>
<p>接下来，我们就可以为复制集添加新成员了。要注意的是，成员添加操作只能在主节点上进行，如果在从节点上执行 <code>rs.add()</code> 命令，将会得到如下错误提示：</p>
<p>​<br>    {<br>        “operationTime” : Timestamp(1564288008, 1),<br>        “ok” : 0,<br>        “errmsg” : “replSetReconfig should only be run on PRIMARY, but my state is SECONDARY; use the &quot;force&quot; argument to override”,<br>        “code” : 10107,<br>        “codeName” : “NotMaster”,<br>        “$clusterTime” : {<br>            “clusterTime” : Timestamp(1564288008, 1),<br>            “signature” : {<br>                “hash” : BinData(0,”AAAAAAAAAAAAAAAAAAAAAAAAAAA=”),<br>                “keyId” : NumberLong(0)<br>            }<br>        }<br>    }</p>
<p>如果忘记了哪个节点是主节点，可以通过 <code>rs.status()</code> 查看当前复制集的节点身份，确定主节点后（假设主节点为 <code>mongoSec</code>），使用<br><code>docker exec -it mongoSec mongo</code> 命令连接主节点 MongoShell，然后执行如下命令：</p>
<p>​<br>    &gt; rs.add({host: “172.17.0.5:27017”, priority: 0, votes: 0})</p>
<p>该命令表示将 <code>host</code> 信息为 <code>172.17.0.5:27017</code> 的 mongo 服务添加到复制集中。命令执行后，返回如下文档：</p>
<p>​<br>    {<br>        “ok” : 1,<br>        “operationTime” : Timestamp(1564288848, 1),<br>        “$clusterTime” : {<br>            “clusterTime” : Timestamp(1564288848, 1),<br>            “signature” : {<br>                “hash” : BinData(0,”AAAAAAAAAAAAAAAAAAAAAAAAAAA=”),<br>                “keyId” : NumberLong(0)<br>            }<br>        }<br>    }</p>
<p><code>ok: 1</code> 代表成员添加成功。除此之外，我们还可以通过查看复制集的状态信息来判断成员是否添加成功。在此示例中，现有节点的数量为 4（之前为<br>3），就代表新成员添加成功。</p>
<h5 id="新增一个仲裁节点"><a href="#新增一个仲裁节点" class="headerlink" title="新增一个仲裁节点"></a>新增一个仲裁节点</h5><p>前面提到过，设置仲裁节点是为了避免选举时出现无限循环的情况。也就是说，当复制集的成员数量为偶数时，我们就需要在复制集中添加一个仲裁节点。启动将要成为仲裁节点的<br>MongoDB 后，在主节点的 MongoShell 中执行 <code>rs.addArb()</code> 命令即可实现仲裁节点的添加。首先，我们需要启动一个 MongoDB<br>容器，并将其命名为 <code>mongoFiv</code>。对应命令如下：</p>
<p>​<br>    $ docker run –name mongoFiv -d mongo:latest –replSet “mongoRepas” –bind_ip_all</p>
<p>接着查看 <code>mongoFiv</code> 的 IP 地址。对应命令如下：</p>
<p>​<br>    $ docker inspect mongoFiv | grep IPAddress<br>    “SecondaryIPAddresses”: null,<br>                “IPAddress”: “172.17.0.6”,<br>                        “IPAddress”: “172.17.0.6”,</p>
<p>在主节点的 MongoShell 中执行如下命令：</p>
<p>​<br>    &gt; rs.addArb(“172.17.0.6:27017”)</p>
<p>该命令代表为复制集添加一个仲裁节点，该节点的 <code>host</code> 信息为 <code>172.17.0.6:27017</code>。命令执行后，返回如下文档：</p>
<p>​<br>    {<br>        “ok” : 1,<br>        “operationTime” : Timestamp(1564289369, 1),<br>        “$clusterTime” : {<br>            “clusterTime” : Timestamp(1564289369, 1),<br>            “signature” : {<br>                “hash” : BinData(0,”AAAAAAAAAAAAAAAAAAAAAAAAAAA=”),<br>                “keyId” : NumberLong(0)<br>            }<br>        }<br>    }</p>
<p><code>ok: 1</code> 代表仲裁节点添加成功。除此之外，我们还可以通过查看复制集的状态信息来判断成员是否添加成功。在此示例中，<code>name</code> 值为<br><code>172.17.0.6</code> 的成员的 <code>stateStr</code> 值为 <code>ARBITER</code> 就代表仲裁节点添加成功。</p>
<h5 id="从复制集中删除一个成员"><a href="#从复制集中删除一个成员" class="headerlink" title="从复制集中删除一个成员"></a>从复制集中删除一个成员</h5><p>MongoBD 提供了 <code>rs.remove()</code> 方法用于从复制集中删除指定成员。假设我们希望从复制集 <code>repas</code> 中删除从节点<br><code>mongoFou</code>。对应命令如下：</p>
<p>​<br>    &gt; rs.remove(“172.17.0.5:27017”)</p>
<p>命令执行后，结果文档如下：</p>
<p>​<br>    {<br>        “ok” : 1,<br>        “operationTime” : Timestamp(1564290025, 1),<br>        “$clusterTime” : {<br>            “clusterTime” : Timestamp(1564290025, 1),<br>            “signature” : {<br>                “hash” : BinData(0,”AAAAAAAAAAAAAAAAAAAAAAAAAAA=”),<br>                “keyId” : NumberLong(0)<br>            }<br>        }<br>    }</p>
<p>要注意的是，如果删除指定成员后导致复制集重新选举，那么 MongoShell<br>有可能会断开链接连接，稍后自动重连。另外，即使命令执行成功，MongoShell 也有可能会显示类似 <code>DBClientCursor::init
call()failed</code> 这样的错误。</p>
<blockquote>
<p>提示：对复制集成员的操作必须在主节点的 MogoShell 中执行，在从节点的 MongoShell 中执行会得到错误提示。</p>
</blockquote>
<h3 id="复制集小结"><a href="#复制集小结" class="headerlink" title="复制集小结"></a>复制集小结</h3><p>复制集是提高数据系统可用性的有效手段，它以数据冗余和选举的方式确保数据服务可用。</p>
<h2 id="综合篇-分片、数据备份与访问控制"><a href="#综合篇-分片、数据备份与访问控制" class="headerlink" title="综合篇 分片、数据备份与访问控制"></a>综合篇 分片、数据备份与访问控制</h2><p>经过前面几篇的学习，我们已经掌握了 MongoDB 的基本使用，这些知识能够满足日常开发的需求。本篇我们将学习 MongoDB<br>中的分片、访问控制和数据备份等知识，这将使我们更好地管理 MongoDB 服务。</p>
<h3 id="了解-MongoDB-中的分片"><a href="#了解-MongoDB-中的分片" class="headerlink" title="了解 MongoDB 中的分片"></a>了解 MongoDB 中的分片</h3><p>MongoDB 服务的性能有可能会受到业务增长的影响，例如高频的查询会导致 CPU<br>占用率居高不下，高吞吐的需求会挑战单个服务器的性能等。面对这种问题，通常有两种解决办法：</p>
<ul>
<li>垂直扩展：堆砌单一服务器的硬件以提升其性能，例如增加内存、使用更强的 CPU或增加磁盘数量。</li>
<li>水平扩展：增加服务器数量以提升整体性能。</li>
</ul>
<p>垂直扩展和水平扩展各有缺点，例如垂直扩展会受到单机性能上限的困扰，并且会降低容灾能力；水平扩展虽然不会受到性能上限的困扰，但增加了运维复杂度和成本。MongoBD<br>推荐的解决办法是通过分片进行水平扩展。</p>
<h4 id="分片概述"><a href="#分片概述" class="headerlink" title="分片概述"></a>分片概述</h4><p>MongoDB 中的分片是一种多机分散存储数据的方法，这种方法被用于解决单机难以应对超大数据量或超高吞吐操作的问题，多机组成的的协同工作组称为分片集群。</p>
<p>分片集群由以下几个部分组成：</p>
<ul>
<li>分片：每个分片包含分片数据的子集，每个分片可以是单个 mongo 服务，也可以部署为复制集。</li>
<li>mongos：充当查询路由器，将客户端的操作转发给分片集群。</li>
<li>配置服务器：存储集群的元数据和配置，配置服务器必须是复制集。</li>
</ul>
<p>下图描述了分片集群的组成和它们之间的关系：<br><img src="https://images.gitbook.cn/3fc4a640-be89-11e9-9891-77a2f5d7a812" alt="在这里插入图片描述"></p>
<p>MongoDB<br>使用分片键对集合进行划分，划分好的数据将散布在多台机器上。分片键由集合中的一个或多个不可变字段组成，且一个分片集合只能拥有一个分片键。要注意的是，集合分片之后，分片键和分片键的值都是不可改变的，即无法为集合选择其他分片键，也无法更新分片键字段的值。分片键的选择很重要，它的选择将会影响分片集群的性能和可伸缩性。要注意的是，MongoDB<br>在集合级别实现分片，而不是数据库级别。</p>
<h4 id="散列分片与范围分片"><a href="#散列分片与范围分片" class="headerlink" title="散列分片与范围分片"></a>散列分片与范围分片</h4><p>MongoDB<br>使用与集合相关的分片键将集合数据分成块，每个块都由分片数据构成。每个块都有一个基于分片键的左闭右开的区间，每个分片可以含有多个块。MongoDB<br>提供了散列分片和范围分片这两种划分块的方式。</p>
<h5 id="散列分片"><a href="#散列分片" class="headerlink" title="散列分片"></a>散列分片</h5><p>散列分片将单个字段的散列值作为分片键，这种方式使得数据分布更均匀。下图描述了散列分片的块划分方式：<br><img src="https://images.gitbook.cn/5615b150-be89-11e9-bb6f-13203c9ddaa7" alt="在这里插入图片描述"><br>上图中，<code>x</code> 为分片键值，<code>Chunk</code> 代表块。分片键值相近的文档会散布在不同的块中，而不是同一个块或相邻的块。</p>
<p>假设使用一个单调递增的值 <code>X</code> （例如 <code>ObjectId</code>）作为集合的分片键，那么散列分片的结果如下图所示：<br><img src="https://images.gitbook.cn/6b3652b0-be89-11e9-8cae-739b42a884cb" alt="在这里插入图片描述"><br>散列分片的语法格式如下：</p>
<p>​<br>    sh.shardCollection( “database.collection”, { <field> : “hashed” } )</field></p>
<h5 id="范围分片"><a href="#范围分片" class="headerlink" title="范围分片"></a>范围分片</h5><p>顾名思义，范围分片就是块的划分是根据分片键值确定的连续范围，分片键值相近的文档可能会被划分到同一个块或者分片中。这种连续的范围分片查询效率较高，但写入性能很有可能会因为选择了不合适的分片键的降低。下图描述了范围分片的块划分方式：<br><img src="https://images.gitbook.cn/7b812910-be89-11e9-b3d9-13b3b1d36699" alt="在这里插入图片描述"><br>上图中，<code>x</code> 为分片键值，<code>Chunk</code> 代表块。<code>x &lt; minKey &lt; -75</code> 的文档将会被划分到 <code>Chunk 1</code> 中，<code>x &lt; 175 &lt;
maxKey</code> 的文档将会被划分到 <code>Chunk 4</code> 中，其他块的划分将依此规则类推。下图描述了范围分片的结果：<br><img src="https://images.gitbook.cn/88cfaf60-be89-11e9-b3d9-13b3b1d36699" alt="在这里插入图片描述"><br>如果范围分片使用的是单调变化的分片键，那么结果就完全不同。下图描述了使用单调变化的分片键的范围分片结果：<br><img src="https://images.gitbook.cn/9f344270-be89-11e9-9891-77a2f5d7a812" alt="在这里插入图片描述"><br>由于值 <code>X</code> 始终在增加，因此具有上限（ <code>maxKey</code><br>）的块接收大多数写入。这将会降低分片集群的优势，也就是上面提到的“分片键的选择将会影响分片集群的性能”。</p>
<p>范围分片是 MongoDB 默认的分片方式。范围分片的语法格式如下：</p>
<p>​<br>    sh.shardCollection( “database.collection”, { <shard key> } )</shard></p>
<p>MongoDB 允许混用分片集合和非分片集合，分片集合散布在多台服务器中，非分片集合存储在主分片上。下图描述了不同服务器上的集合关系：<br><img src="https://images.gitbook.cn/b41b3630-be89-11e9-9891-77a2f5d7a812" alt="在这里插入图片描述"><br>其中，<code>collection 1</code> 表示分片集合，<code>collection 2</code> 表示非分片集合。客户端必须借助 mongos<br>路由才能与分片集群中的集合进行交互，这里的集合包括分片集合和非分片集合。下图描述了客户端、mongos 路由和分片集群的交互流程：<br><img src="https://images.gitbook.cn/c291e8d0-be89-11e9-bb6f-13203c9ddaa7" alt="在这里插入图片描述"><br>客户端可以通过 MongoShell 或者对应的数据库驱动连接到 mongos 路由。</p>
<h4 id="块的拆分和迁移"><a href="#块的拆分和迁移" class="headerlink" title="块的拆分和迁移"></a>块的拆分和迁移</h4><p>MongoDB 中，块的默认大小为 <code>64</code> 兆字节。MongoDB 允许调整块的大小，但大小限制为 <code>1 &lt;= chunksize &lt;=
1024</code>。假设我们希望调整块的大小，首先我们应该切换到 <code>config</code> 数据库，对应示例如下：</p>
<p>​<br>    &gt; use config</p>
<p>然后使用 <code>save()</code> 方法更改 <code>chunksize</code> 的值，对应示例如下：</p>
<p>​<br>    &gt; db.settings.save( {_id:”chunksize”, value: <sizeinmb>})</sizeinmb></p>
<p>其中，<code>&lt;sizeInMB&gt;</code> 为块的大小。当块超出指定大小或者块中的文档数超出时，MongoDB<br>就会根据块的分片键值拆分块，即将一个过大的块拆分成多个块。大多数时候，触发块拆分的操作是插入或更新。下图描述了块的拆分过程：<br><img src="https://images.gitbook.cn/d5e1c1d0-be89-11e9-b3d9-13b3b1d36699" alt="在这里插入图片描述"><br>在分片集合 <code>A</code> 中有一个容量超过指定块大小的块（该块大小为 <code>64.2MB</code>），它将会被一分为二，以满足 MongoDB<br>对块大小的限制。要注意的是，拆分有可能会导致分片的分布不均。在这种情况下，MongoDB 的平衡器会跨分片重新分配块，这种行为叫做块迁移。</p>
<p>平衡器是管理块迁移的后台进程，如果最大分片和最小分片中块的数量差值超过迁移阈值，平衡器就会开始块的迁移工作，以确保数据均匀分布。迁移阈值与块的总数相关，具体关联关系如下：</p>
<table>
<thead>
<tr>
<th>块的数量</th>
<th>迁移阈值</th>
</tr>
</thead>
<tbody><tr>
<td>少于 20</td>
<td>2</td>
</tr>
<tr>
<td>20～79</td>
<td>4</td>
</tr>
<tr>
<td>80 以及以上</td>
<td>8</td>
</tr>
</tbody></table>
<p>下图描述了平衡器迁移块的过程：<br><img src="https://images.gitbook.cn/e78a2c60-be89-11e9-8cae-739b42a884cb" alt="在这里插入图片描述"><br>分片集合 <code>B</code> 中的一个块将会被迁移到分片集合 <code>C</code> 中。要注意的是，<code>chunksize</code><br>越小，拆分和迁移就会越多，数据分布也会更均匀，但过多的拆分和迁移也是不合理的。</p>
<p>以上就是本篇对分片的理论介绍，更多关于分片的知识和操作可参考官方文档<br><a href="https://docs.mongodb.com/manual/sharding/" target="_blank" rel="noopener">Sharding</a>。</p>
<h3 id="认证与访问控制"><a href="#认证与访问控制" class="headerlink" title="认证与访问控制"></a>认证与访问控制</h3><p>数据安全是一个很重要的知识点，我们将在本篇学习 MongoDB 提供的多种安全功能，例如认证、访问控制和加密等。</p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>认证指的是服务端验证客户端的身份，启用访问控制后，MongoDB<br>会验证所有客户端的身份以确定其访问权限。虽然认证和访问控制是紧密相连的，但认证与访问控制是不同的，认证用于确认用户的身份，而访问控制则验证用户对资源的访问和操作。</p>
<p>MongoDB 支持的认证机制如下：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/core/security-scram/#scram" target="_blank" rel="noopener">SCRAM</a>，默认机制；</li>
<li>证书身份验证；</li>
<li>LADAP 代理身份，MongoDB 企业版独有；</li>
<li>Kerberos 身份验证，MongoDB 企业版独有；</li>
</ul>
<p>本文我们讨论的是 MongoDB 默认的 SCRAM 认证机制。SCRAM 英文全称为 Salted Challenge Response<br>Authentication Mechanism，是一种基于用户名和密码的身份验证机制。</p>
<p>除了验证客户段的身份之外，MongoDB 还支持复制集和分片集群的成员进行内部身份认证。</p>
<p>MongoDB 对客户端身份的验证其实是对用户的身份进行验证，即认证是基于用户的。我们可以使用 <code>db.createUser()</code><br>方法添加用户，并通过为用户分配角色实现授权。从 MongoDB 4.0 开始，用户在创建时会获得一个具有唯一值的 <code>userId</code>。如果开启了<br>MongoDB 的访问控制，那么创建的第一个用户必须分配 <code>userAdmin</code> 或 <code>userAdminAnyDatabase</code><br>角色，以便它有权创建其他用户。</p>
<h4 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h4><p>MongoDB 使用基于角色的访问控制来管理对 MongoDB<br>系统的访问。角色被授予访问资源或指定操作的权限，每个权限都可以在角色中明确指定，也可以继承其他角色的权限。拥有者可以为用户授予一个或多个角色，分配了角色的用户将获得该角色的所有权限。</p>
<p>MongoDB 提供了很多的内置角色，这些角色已经拥有了数据库系统中常用的权限，如果它们无法满足需求，我们还可以自定义角色和权限。MongoDB<br>中的内置角色有以下几类：</p>
<table>
<thead>
<tr>
<th>角色类别</th>
<th>内置角色</th>
</tr>
</thead>
<tbody><tr>
<td>数据库用户角色</td>
<td><code>read</code> 、<code>readWrite</code></td>
</tr>
<tr>
<td>数据库管理角色</td>
<td><code>dbAdmin</code>、<code>dbOwner</code>、<code>userAdmin</code></td>
</tr>
<tr>
<td>集群管理角色</td>
<td><code>clusterAdmin</code>、 <code>clusterManager</code>、<code>clusterMonitor</code>、<code>hostManager</code></td>
</tr>
<tr>
<td>备份和恢复角色</td>
<td><code>backup</code>、<code>restore</code></td>
</tr>
<tr>
<td>全数据库角色</td>
<td></td>
</tr>
<tr>
<td><code>readAnyDatabase</code>、<code>readWriteAnyDatabase</code>、<code>userAdminAnyDatabase</code>、<code>dbAdminAnyDatabase</code></td>
<td></td>
</tr>
<tr>
<td>超级用户角色</td>
<td><code>root</code></td>
</tr>
<tr>
<td>内部角色</td>
<td><code>__system</code></td>
</tr>
</tbody></table>
<p>每个内置角色对应有多个操作权，这些操作权允许角色访问文档资源或执行操作。例如 <code>read</code> 角色拥有如下操作权：</p>
<ul>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#changeStream" target="_blank" rel="noopener"><code>changeStream</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#collStats" target="_blank" rel="noopener"><code>collStats</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#dbHash" target="_blank" rel="noopener"><code>dbHash</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#dbStats" target="_blank" rel="noopener"><code>dbStats</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#find" target="_blank" rel="noopener"><code>find</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#killCursors" target="_blank" rel="noopener"><code>killCursors</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#listIndexes" target="_blank" rel="noopener"><code>listIndexes</code></a></li>
<li><a href="https://docs.mongodb.com/manual/reference/privilege-actions/#listCollections" target="_blank" rel="noopener"><code>listCollections</code></a></li>
</ul>
<p>这些操作权为角色 <code>read</code> 提供了读取权限，例如 <code>listIndexes</code> 操作权允许角色使用 <code>listIndexes</code> 命令。其他角色，例如<br><code>readWrite</code>、<code>restore</code> 和 <code>userAdmin</code>等对应的操作权可查阅官方文档 [Built-In<br>Roles](<a href="https://docs.mongodb.com/manual/reference/built-in-" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/built-in-</a><br>roles/)。每个操作权对应的描述可查阅官方文档 <a href="https://docs.mongodb.com/manual/reference/privilege-actions/" target="_blank" rel="noopener">Privilege<br>actions</a><br>，此处不再赘述。</p>
<h4 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h4><p>开启访问控制的前提之一是创建一个管理员用户，否则开启访问控制后将会导致无法通过认证或无法执行操作。创建管理员用户很简单，切换到 <code>admin</code><br>数据库，并使用 <code>db.createUser()</code> 即可，但要记得为用户分配权限。对应示例如下：</p>
<p>​<br>    &gt; use admin<br>    &gt; db.createUser({<br>    … user: “Asyncins”,<br>    … pwd: “123456”,<br>    … roles: [{<br>    … role: “userAdminAnyDatabase”, db: “admin”},<br>    … “readWriteAnyDatabase”]<br>    … })</p>
<p>命令执行后，返回如下内容：</p>
<p>​<br>    Successfully added user: {<br>        “user” : “Asyncins”,<br>        “roles” : [<br>            {<br>                “role” : “userAdminAnyDatabase”,<br>                “db” : “admin”<br>            },<br>            “readWriteAnyDatabase”<br>        ]<br>    }</p>
<p>返回结果显示用户 <code>Asyncins</code> 已创建成功。</p>
<h4 id="启用访问控制"><a href="#启用访问控制" class="headerlink" title="启用访问控制"></a>启用访问控制</h4><p>默认情况下，MongoDB 不启用访问控制。如果我们需要，可以使用在配置文件 <code>mongod.conf</code> 中开启。</p>
<blockquote>
<p>提示：在开启访问控制前，请按照上面的指引创建管理员用户。</p>
</blockquote>
<p>在开篇中提到过，<code>mongod.conf</code> 的完整路径为 <code>/usr/local/etc/mongod.conf</code>，用 Vim 编辑器打开它：</p>
<p>​<br>    $ vim /usr/local/etc/mongod.conf </p>
<p>文件完整内容如下：</p>
<p>​<br>    systemLog:<br>      destination: file<br>      path: /usr/local/var/log/mongodb/mongo.log<br>      logAppend: true<br>    storage:<br>      dbPath: /usr/local/var/mongodb<br>    net:<br>      bindIp: 127.0.0.1</p>
<p>要开启访问控制，只需要在配置中将 <code>security.authorization</code> 打开即可，即在文件中添加以下内容：</p>
<p>​<br>    security:<br>       authorization: enabled</p>
<p>文件保存后，退出 MongoShell。我们可以让 MongoDB 在前台运行，也可以把它当作系统服务启动。前台启动的示例如下：</p>
<p>​<br>    $ mongod –auth –port 27017 –dbpath /usr/local/var/mongodb</p>
<p>要注意的是，启动示例中的 <code>dbpath</code> 路径是配置文件 <code>mongod.conf</code> 中设置的路径。我们可以在连接 MongoShell<br>时验证身份，对应示例如下：</p>
<p>​<br>    $ mongo –port 27017 -u “Asyncins” –authenticationDatabase “admin” -p</p>
<p>命令执行后，终端会提示输入密码，此时输入之前设定的 <code>123456</code> 即可。我们可以通过命令验证当前用户的权限，示例如下：</p>
<p>​<br>    &gt; show tables</p>
<p>如果 MongoShell 返回集合列表，就代表用户身份验证通过。我们尝试使用无权用户或匿名用户连接 MongoShell<br>并查看集合列表，看看会发生什么。此时打开另外一个终端窗口，并执行以下命令：</p>
<p>​<br>    $ mongo</p>
<p>命令执行后，终端输入内容如下：</p>
<p>​<br>    MongoDB shell version v4.0.10<br>    connecting to: mongodb://127.0.0.1:27017/?gssapiServiceName=mongodb<br>    Implicit session: session { “id” : UUID(“580ebfe6-ab68-4c6d-ad40-fbfaaa30f408”) }<br>    MongoDB server version: 4.0.10</p>
<p>这代表已经成功连接了 MongoShell，接着执行查看集合列表的命令：</p>
<p>​<br>    &gt; show tables<br>    Warning: unable to run listCollections, attempting to approximate collection names by parsing connectionStatus</p>
<p>这次并没有返回集合列表，而是给出一个 <code>Warning</code> 级别的提示。提示无法执行 <code>listCollections</code><br>命令，即该匿名用户无对应权限。这说明访问控制已生效。</p>
<h4 id="创建其他用户并分配权限"><a href="#创建其他用户并分配权限" class="headerlink" title="创建其他用户并分配权限"></a>创建其他用户并分配权限</h4><p>上面已经创建了管理员用户，并开启了访问控制。接下来我们将学习如何创建其他用户，并通过分配角色的方式为其授权。假设要创建一个名为 <code>rust</code><br>的用户，且只分配读取 <code>test</code> 数据库的权限。要完成这个任务，首先要登录管理员用户，接着进入到 <code>test</code> 数据库中创建<br><code>rust</code>。用户创建的对应示例如下：</p>
<p>​<br>    &gt; use test<br>    &gt; db.createUser(<br>      {<br>        user: “rust”,<br>        pwd: “133”,<br>        roles: [ { role: “read”, db: “test” }]<br>      }<br>    )</p>
<p>命令执行后，MongoShell 输出如下内容：</p>
<p>​<br>    Successfully added user: {<br>        “user” : “rust”,<br>        “roles” : [<br>            {<br>                “role” : “read”,<br>                “db” : “test”<br>            }<br>        ]<br>    }</p>
<p>返回结果说明用户 <code>rust</code> 创建成功，接下来我们验证一下 <code>rust</code> 用户的权限。退出当前 MongoShell，并使用新用户 <code>rust</code><br>登录，对应示例如下：</p>
<p>​<br>    $ mongo –port 27017 -u “rust” –authenticationDatabase “test” -p</p>
<p>按提示输入密码后，就连上了 MongoShell。此时使用查询命令：</p>
<p>​<br>    &gt; db.inven.find()<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c162”), “name” : “詹姆斯”, “number” : 6, “attribute” : { “h” : 203, “w” : 222, “p” : “前锋” }, “status” : “A” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c163”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c164”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c165”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c166”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p>说明用户具有查询权限。但是当我们执行写操作时，就会得到没有权限的提示，对应示例如下：</p>
<p>​<br>    &gt; db.ssv.insert({_id: 1, name: “ssv”})<br>    WriteCommandError({<br>        “ok” : 0,<br>        “errmsg” : “not authorized on test to execute command { insert: &quot;ssv&quot;, ordered: true, lsid: { id: UUID(&quot;a19c72a8-2301-4fb3-a39d-5161900242a1&quot;) }, $db: &quot;test&quot; }”,<br>        “code” : 13,<br>        “codeName” : “Unauthorized”<br>    })</p>
<p>刚才我们测试的是读写权限，实际上在创建 <code>rust</code> 用户时，我们限定了该用户只能访问 <code>test</code><br>数据库。如果切换到其他数据库，那么它连读取权限都没有，对应示例如下：</p>
<p>​<br>    &gt; use admin<br>    switched to db admin<br>    &gt; show tables<br>    Warning: unable to run listCollections, attempting to approximate collection names by parsing connectionStatus</p>
<h3 id="数据备份和还原"><a href="#数据备份和还原" class="headerlink" title="数据备份和还原"></a>数据备份和还原</h3><p>在生产环境中使用 MongoDB 时，我们应该备份数据，以便在发生数据丢失事件时恢复数据。MongoDB 提供了四种可用备份方法：</p>
<ul>
<li>用 Atlas 备份数据，即使用 MongoDB 官方的云服务进行备份。这种方式可以增量备份数据，确保备份的数据仅比生产环境的数据落后几秒钟；</li>
<li>用 MongoDB Cloud Manager 备份数据。这种方式通过读取 oplog 实现数据备份，还能够能够备份复制集和分片集群中的数据；</li>
<li>通过复制底层数据文件进行备份。这种方式通过复制 MongoDB 的基础数据文件来实现数据备份，备份的前提是必须启用日志功能；</li>
<li>使用 mongodump 备份数据。mongodump 读取 MongoDB 中的数据并保存为 BSON 文件，是备份和恢复小型数据库的简单而有效的方式，但不适合备份较大的数据库。要注意的是，用这种方式备份后的数据，在还原后必须重建索引；</li>
</ul>
<p>上述几种备份还原方式各有优劣，本篇我们只讨论 mongodump 备份。mongodump 可以为整个<br>MongoDB、指定数据库或指定集合创建备份，甚至可以使用查询语句实现备份集合的指定内容。</p>
<h4 id="备份本地数据"><a href="#备份本地数据" class="headerlink" title="备份本地数据"></a>备份本地数据</h4><p>使用 <code>mongodump</code> 备份数据，指定备份数据的输出目录</p>
<p>​<br>    $ mongodump –out /Users/async/Documents/Testing/mongobackup</p>
<p>还可以备份指定数据库中的指定集合：</p>
<p>​<br>    $ mongodump –db test –collection inven –out /Users/async/Documents/Testing/mongo_test_invenbackup</p>
<p>命令执行后，返回如下信息：</p>
<p>​<br>    2019-07-29T23:04:47.273+0800    writing test.inven to<br>    2019-07-29T23:04:47.276+0800    done dumping test.inven (5 documents)</p>
<p>信息显示备份的是 <code>test</code> 数据库中的集合 <code>inven</code>，备份的文档数为 <code>5</code>。指定的备份目录将会保存一份 JSON 文件和一份 BSON<br>文件。其中，JSON 文件保存的是本次备份的元数据，文件内容如下：</p>
<p>​<br>    {“options”:{},”indexes”:[{“v”:2,”key”:{“<em>id”:1},”name”:”_id</em>“,”ns”:”test.inven”},{“v”:2,”key”:{“number”:1.0},”name”:”number_1”,”ns”:”test.inven”},{“v”:2,”key”:{“number”:-1.0},”name”:”number_-1”,”ns”:”test.inven”}],”uuid”:”83e27b2b35d0476d84b8788b4cf3591f”}</p>
<p>BSON 文件保存的是本次备份的数据，即数据被保存为二进制格式。</p>
<h4 id="还原本地数据"><a href="#还原本地数据" class="headerlink" title="还原本地数据"></a>还原本地数据</h4><p>在学习数据的还原之前，我们先删除集合 <code>inven</code>，对应命令如下：</p>
<p>​<br>    &gt; db.inven.drop()<br>    true</p>
<p>返回结果为 <code>true</code> 代表删除成功。为了确保它真的被删除了，我们可以使用 <code>show tables</code> 查看集合列表，如果 <code>inven</code><br>并不在其中，说明它已经被我们已经删除了。接下来使用 <code>mongorestore</code> 恢复数据，在备份文件的同级目录唤起终端，并输入还原命令：</p>
<p>​<br>    $ mongorestore ./mongo_test_invenbackup/</p>
<p>命令执行后，终端输入如下信息：</p>
<p>​<br>    2019-07-29T23:17:12.907+0800    preparing collections to restore from<br>    2019-07-29T23:17:12.907+0800    don’t know what to do with file “mongo_test_invenbackup/.DS_Store”, skipping…<br>    2019-07-29T23:17:12.909+0800    reading metadata for test.inven from mongo_test_invenbackup/test/inven.metadata.json<br>    2019-07-29T23:17:12.938+0800    restoring test.inven from mongo_test_invenbackup/test/inven.bson<br>    2019-07-29T23:17:12.940+0800    restoring indexes for collection test.inven from metadata<br>    2019-07-29T23:17:12.976+0800    finished restoring test.inven (5 documents)<br>    2019-07-29T23:17:12.977+0800    done</p>
<p>出现 <code>done</code> 说明数据已经还原成功。我们可以到数据库中使用 <code>show tables</code> 命令对还原操作进行验证：</p>
<p>​<br>    &gt; show tables<br>    inven<br>    …</p>
<p>集合 <code>inven</code> 出现在集合列表中，说明还原成功。我们还可以使用 <code>db.inven.find()</code> 命令验证数据的完整性：</p>
<p>​<br>    &gt; db.inven.find()<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c162”), “name” : “詹姆斯”, “number” : 6, “attribute” : { “h” : 203, “w” : 222, “p” : “前锋” }, “status” : “A” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c163”), “name” : “韦德”, “number” : 3, “attribute” : { “h” : 193, “w” : 220, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c164”), “name” : “科比”, “number” : 24, “attribute” : { “h” : 198, “w” : 212, “p” : “得分后卫” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c165”), “name” : “姚明”, “number” : 11, “attribute” : { “h” : 226, “w” : 308, “p” : “中锋” }, “status” : “R” }<br>    { “_id” : ObjectId(“5d38688e2ac0ecb464f2c166”), “name” : “乔丹”, “number” : 23, “attribute” : { “h” : 198, “w” : 216, “p” : “得分后卫” }, “status” : “R” }</p>
<p>这说明数据也是完整的，本次本地的数据备份与还原演示到此结束。</p>
<h4 id="远程备份与还原"><a href="#远程备份与还原" class="headerlink" title="远程备份与还原"></a>远程备份与还原</h4><p>除了备份本地数据之外，我们还可以备份远程服务器上的数据，备份时我们可能需要提供用户身份信息（如果未开启访问控制则不需要）。假设我们需要为<br><code>mg.porters.vip</code> 服务器上已开启访问控制的 MongoDB 进行备份对应的目录。备份命令如下：</p>
<p>​<br>    $ mongodump –host mg.porters.vip –port 27017 –username user –password “123456” – out /opt/backup/mongodump-20190729</p>
<p>命令执行后，指定的数据将会备份到 <code>/opt/backup/mongodump-20190729</code> 目录。当我们需要还原数据的时候，运行以下命令：</p>
<p>​<br>    $ mongorestore –host mg.porters.vip –port 27017 –username user –password “123456” /opt/backup/mongodump-20190729</p>
<p>命令执行后，指定目录的数据将会被还原到 MongoDB 中。</p>
<p>至此，MongoDB 数据备份与还原的 mongodump 演示结束，更多关于备份与还原的知识可查阅官方文档 <a href="https://docs.mongodb.com/manual/core/backups/" target="_blank" rel="noopener">MongDB Backup<br>Methods</a>。</p>
<hr>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>经过几篇的学习，相信你已经对 MongoDB 不再陌生。想要掌握<br>MongoDB，还需要更多的实践操作。如果在实践中遇到问题，建议翻阅官方文档或者加入作者微信群一起讨论。作者微信号：zenrusts，加我好友拉你入群。</p>
<hr>
<p>本文首发于 GitChat，未经授权不得转载，转载需与 GitChat 联系。</p>
<h2 id="更多资源下载交流请加微信：Morstrong-加入永久会员-网盘更新更快捷！"><a href="#更多资源下载交流请加微信：Morstrong-加入永久会员-网盘更新更快捷！" class="headerlink" title="更多资源下载交流请加微信：Morstrong,加入永久会员,网盘更新更快捷！"></a>更多资源下载交流请加微信：Morstrong,加入永久会员,网盘更新更快捷！</h2><h1 id="本资源由微信公众号：光明顶一号，提供支持"><a href="#本资源由微信公众号：光明顶一号，提供支持" class="headerlink" title="本资源由微信公众号：光明顶一号，提供支持"></a>本资源由微信公众号：光明顶一号，提供支持</h1>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/09/04/MongoDB/超高性价比的MongoDB零基础快速入门实战教程/">http://yoursite.com/2019/09/04/MongoDB/超高性价比的MongoDB零基础快速入门实战教程/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/MongoDB/"># MongoDB</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/09/04/JVM/JVM问题诊断快速入门/">JVM问题诊断快速入门</a>
            
            
            <a class="next" rel="next" href="/2019/09/04/Mysql/SQL常见面试题解析/">SQL常见面试题</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
