<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>2小时带你实战Dubbo分布式服务调度 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ferrymana&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ferrymana&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">2小时带你实战Dubbo分布式服务调度</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 3, 2019&nbsp;&nbsp;16:31:18</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/dubbo/">dubbo</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="深度学习-Dubbo"><a href="#深度学习-Dubbo" class="headerlink" title="深度学习 Dubbo"></a>深度学习 Dubbo</h2><p><a href="/gitchat/author/5b8a9c01ab7d1e2cb083c1d2"><img src="https://images.gitbook.cn/b17d5490-adef-11e8-b483-e79b276a9d5b" alt><img src="https://images.gitbook.cn/cvip.png" alt></a></p>
<p><a href="/gitchat/author/5b8a9c01ab7d1e2cb083c1d2">灵动的艺术</a></p>
<p><a href="/m/mazi/author/5b8a9c01ab7d1e2cb083c1d2/question">向作者提问</a></p>
<p>CSDN博客专家：<a href="https://summer.blog.csdn.net/" target="_blank" rel="noopener">https://summer.blog.csdn.net/</a><br>GitHub开源博主：<a href="https://github.com/Jaysong2012" target="_blank" rel="noopener">https://github.com/Jaysong2012</a> 欢迎大家围观。</p>
<p><a href="/gitchat/activity/5c3c82925fa34d4e40e00397">查看本场Chat</a></p>
<blockquote>
<p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源 Java RPC<br>框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
</blockquote>
<p>Apache 如是评价这个由阿里巴巴捐赠给 Apache 并成为 Apache 顶级项目的 Java 高性能 RPC 服务框架。</p>
<p>如果到目前为止，你还不知道或者不了解 Dubbo ，请移步百度百科或者查看 Dubbo 官网 <a href="http://dubbo.apache.org" target="_blank" rel="noopener">http://dubbo.apache.org</a> ，Dubbo<br>的介绍说明，不是本课题的重点。</p>
<h3 id="Java-RMI-入门"><a href="#Java-RMI-入门" class="headerlink" title="Java RMI 入门"></a>Java RMI 入门</h3><p>Java RMI （Remote Method Invocation）- 远程方法调用。它的核心思想就是让你的客户端像使用本地调用一样调用服务端 Java<br>虚拟机中的对象方法。RMI 是面向对象语言领域对 RPC （Remote Procedure Call）的完善，它让我们无需依靠 IDL<br>的帮助来完成分布式调用，而通过依赖接口这种更简单自然的方式。</p>
<p>Java RMI 是 Java 领域创建分布式应用的技术基石。后续的 EJB 技术，以及现代的分布式服务框架，其中的基本理念依旧是 Java RMI<br>的延续。</p>
<p>一个典型的 RMI 调用将有以下几个角色组成：</p>
<ul>
<li>*<em>注册服务(registry) *</em>: 提供注册表的创建以及查找和命名远程对象的类、接口和异常；</li>
<li><strong>客户端(Client)</strong> : 远程服务调用方；</li>
<li><strong>服务端(Server)</strong> : 远程服务提供方；</li>
<li><strong>本地存根对象(Stub)</strong> : 服务端远程对象的代理对象 stub；</li>
<li><strong>服务端的骨架对象(Skeleton)</strong> : 服务端远程对象的辅助对象 skeleton。</li>
</ul>
<p>一个典型的 RMI 调用将会经历如下几个步骤：</p>
<ol>
<li>服务端向 RMI 注册服务绑定自己的地址；</li>
<li>客户端通过 RMI 注册服务获取目标地址；</li>
<li>客户端调用本地的 Stub 对象上的方法，和调用本地对象上的方法一致；</li>
<li>本地存根对象将调用信息打包，通过网络发送到服务端；</li>
<li>服务端的 Skeleton 对象收到网络请求之后，将调用信息解包；</li>
<li>然后找到真正的服务对象发起调用，并将返回结果打包通过网络发送回客户端。</li>
</ol>
<p>完整流程如下图所示： ![RMI 构建图 ](<a href="https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-" target="_blank" rel="noopener">https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-</a><br>rmi_flow.png) 图片来源：<a href="https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-" target="_blank" rel="noopener">https://www.cs.rutgers.edu/~pxk/417/notes/images/rpc-</a><br>rmi_flow.png</p>
<p>下面我们通过示例代码来看看 RMI 中的服务注册和发现。</p>
<ul>
<li><p>定义一个远程服务接口</p>
<pre><code>public interface Service extends Remote {

void sayHello(String name) throws RemoteException;</code></pre></li>
</ul>
<p>} `</p>
<ul>
<li><p>远程服务接口实现</p>
<pre><code>public class ServiceImpl implements Service{

@Override</code></pre><p>public void sayHello(String name) {</p>
<pre><code>System.out.println(&quot;hello &quot;+name);</code></pre><p>}</p>
</li>
</ul>
<p>} `</p>
<ul>
<li><p>服务端的服务注册</p>
<pre><code>    public static void main(String[] args) throws RemoteException{
    Service service = new ServiceImpl(); // 初始化服务对象实例
    // 通过 UnicastRemoteObject.exportObject 生成可以与服务端通讯的 Stub 对象
    Service stub = (Service) UnicastRemoteObject.exportObject(service, 19898); 
    //创建一个本地的 RMI 注册服务，监听端口为 1099。该注册服务运行在服务端，也可以单独启动一个注册服务的进程
    Registry registry = LocateRegistry.createRegistry(1099); 
    //将 Stub 对象绑定到注册服务上，这样，客户端可以通过 service 这个名字查找到该远程对象。
    registry.rebind(&quot;service&quot;, stub); // #4
}</code></pre></li>
</ul>
<ul>
<li><p>客户端的服务发现</p>
<pre><code>public static void main(String[] args) throws RemoteException, NotBoundException {
//在 1099 端口上获取注册服务实例
Registry registry = LocateRegistry.getRegistry(1099);
从注册服务中查找服务名为 Service 的远程对象
Service stub = (Service) registry.lookup(&quot;service&quot;);
//通过获取的 Stub 对象发起一次 RMI 调用
stub.sayHello(&quot;jaysong&quot;);</code></pre><p>}</p>
</li>
</ul>
<p>分别先后启动服务端客户端进程，我们将在客户端成功调用远程服务端提供的远程方法。</p>
<h3 id="Dubbo-基础"><a href="#Dubbo-基础" class="headerlink" title="Dubbo 基础"></a>Dubbo 基础</h3><p>Dubbo 的分布式服务框架的基本概念与 RMI 是类似的，同样是使用 Java 的 Interface<br>作为服务契约，通过注册中心来完成服务的注册和发现，远程通讯的细节也是通过代理类来屏蔽。具体来说，Dubbo 在工作时有以下四个角色参与：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Provider</td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td>Consumer</td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td>Registry</td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td>Monitor</td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td>Container</td>
<td>服务运行容器</td>
</tr>
</tbody></table>
<p>调用关系如下：</p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者；</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务；</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务；</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者；</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用；</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<p>具体系统架构图如下：<br><img src="https://cdn.yuque.com/lark/0/2018/png/13615/1527499479031-19b76c2f-29dc-4766-8dcb-9dd7c0c089f7.png" alt="dubbo"><br>图片来源：<a href="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-" target="_blank" rel="noopener">http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-</a><br>architecture.jpg</p>
<h3 id="Dubbo实战"><a href="#Dubbo实战" class="headerlink" title="Dubbo实战"></a>Dubbo实战</h3><p>Dubbo 应用一般依托于 Spring 容器（也可以是其他容器），如果我们希望深度学习<br>Dubbo，自己动手实践是必要的，为了降低大家的学习成本，我这边将以 SpringBoot 为例，Dubbo 的 SpringBoot 集成方案欢迎访问<br><a href="https://github.com/apache/incubator-dubbo-spring-boot-project" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-spring-boot-project</a><br>，上面有详细的构建说明，我这里将不赘述了。如果实在不会自己构建，欢迎使用我的 Dubbo<br>案例项目<a href="https://github.com/Jaysong2012/dubbo" target="_blank" rel="noopener">dubbo(传送门)</a>，上面有你想要的全部高级案例。</p>
<h3 id="Dubbo-集群容错"><a href="#Dubbo-集群容错" class="headerlink" title="Dubbo 集群容错"></a>Dubbo 集群容错</h3><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<p>![Dubbo 集群容错](<a href="http://dubbo.apache.org/docs/zh-" target="_blank" rel="noopener">http://dubbo.apache.org/docs/zh-</a><br>cn/user/sources/images/cluster.jpg) 图片来源： <a href="http://dubbo.apache.org/docs/zh-" target="_blank" rel="noopener">http://dubbo.apache.org/docs/zh-</a><br>cn/user/sources/images/cluster.jpg</p>
<ul>
<li><p><strong>Failover Cluster</strong> 失败自动切换，当出现失败，重试其它服务器 。通常用于读操作，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。</p>
<pre><code>@Service(version = &quot;1.0.0&quot;,protocol = {&quot;dubbo&quot;},registry = {&quot;zk&quot;,&quot;redis&quot;},retries = 3,owner = &quot;jaysong&quot;)</code></pre></li>
</ul>
<ul>
<li><p><strong>Failfast Cluster</strong> 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p>
<pre><code>@Service(version = &quot;1.0.0&quot;,protocol = {&quot;dubbo&quot;},registry = {&quot;zk&quot;},cluster = &quot;failfast&quot;,owner = &quot;jaysong&quot;)</code></pre></li>
</ul>
<ul>
<li><p><strong>Failsafe Cluster</strong> 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p>
</li>
<li><p><strong>Failback Cluster</strong> 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p>
</li>
<li><p><strong>Forking Cluster</strong> 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p>
</li>
<li><p><strong>Broadcast Cluster</strong> 广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p>
</li>
</ul>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>在集群负载均衡时，Dubbo 提供了多种均衡负载均衡策略，缺省为 random 随机调用。</p>
<ul>
<li><p><strong>Random LoadBalance</strong> 随机，按权重设置随机概率。 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</p>
<pre><code>@Service(version = &quot;1.0.0&quot;,protocol = {&quot;dubbo&quot;},registry = {&quot;zk&quot;,&quot;redis&quot;},retries = 3,owner = &quot;jaysong&quot;,loadbalance = &quot;roundrobin&quot;)</code></pre></li>
</ul>
<pre><code>    //配置每一个method的信息
MethodConfig methodConfig = new MethodConfig();
methodConfig.setName(&quot;errorTest&quot;);
methodConfig.setTimeout(1000);
methodConfig.setLoadbalance(&quot;random&quot;);
methodConfig.setRetries(1);</code></pre><ul>
<li><p><strong>RoundRobin LoadBalance</strong> 轮询，按公约后的权重设置轮询比率。 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</p>
<pre><code>//配置每一个method的信息</code></pre><p>MethodConfig methodConfig = new MethodConfig();<br>methodConfig.setName(“errorTest”);<br>methodConfig.setTimeout(1000);<br>methodConfig.setLoadbalance(“roundrobin”);<br>methodConfig.setRetries(1);</p>
</li>
<li><p><strong>LeastActive LoadBalance</strong> 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。</p>
</li>
<li><p><strong>ConsistentHash LoadBalance</strong> 一致性 Hash，相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 算法参见：<a href="http://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Consistent_hashing</a></p>
</li>
</ul>
<h3 id="Dubbo-多协议"><a href="#Dubbo-多协议" class="headerlink" title="Dubbo 多协议"></a>Dubbo 多协议</h3><p>Dubbo 允许配置多协议，在不同服务上支持不同协议或者同一服务上同时支持多种协议。</p>
<ul>
<li><strong>dubbo://</strong> Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</li>
</ul>
<p>反之，Dubbo 缺省协议不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
<p>![dubbo protocol ](<a href="http://dubbo.apache.org/docs/zh-" target="_blank" rel="noopener">http://dubbo.apache.org/docs/zh-</a><br>cn/user/sources/images/dubbo-protocol.jpg) 图片来源<br><a href="http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-protocol.jpg" target="_blank" rel="noopener">http://dubbo.apache.org/docs/zh-cn/user/sources/images/dubbo-protocol.jpg</a></p>
<ul>
<li><p><strong>rmi://</strong> RMI 协议采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式。适用于传入传出参数数据包大小混合，消费者与提供者个数差不多，可用于传文件。</p>
</li>
<li><p><strong>hessian://</strong> Hessian 协议用于集成 Hessian 的服务，Hessian 底层采用 Http 通讯，采用 Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现。适用于传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可用于传文件。 Dubbo 的 Hessian 协议可以和原生 Hessian 服务互操作，即： </p>
<ul>
<li>提供者用 Dubbo 的 Hessian 协议暴露服务，消费者直接用标准 Hessian 接口调用</li>
<li>或者提供方用标准 Hessian 暴露服务，消费方用 Dubbo 的 Hessian 协议调用。</li>
</ul>
</li>
</ul>
<p>Dubbo 其他可用的协议包括 http://<br>、webservice://、thrift://、memcached://、redis://、rest://。如果有兴趣了解，请移步<br><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/references/protocol/introduction.html</a><br>这里不在赘述。</p>
<p>我们是实际使用中，考虑到性能的需要经常需要不同的服务使用不同的协议，当然也有可能不同服务不同注册中心，这里我给大家做了详细演示。</p>
<p>​<br>    # Dubbo Application<br>    ## The default value of dubbo.application.name is ${spring.application.name}<br>    dubbo:<br>      application:<br>        name: dubbo-provider<br>      scan:<br>        base-packages: com.example.dubbo.provider.serviceImpl<br>      protocols:<br>        rmi:<br>          name: rmi<br>          port: 1088<br>          serialization: hessian2<br>        dubbo:<br>          name: dubbo<br>          port: 20880<br>          server: netty<br>          client: netty<br>          codec: dubbo<br>          serialization: hessian2<br>          charset: UTF-8<br>          threadpool: fixed<br>          threads: 100<br>          queues: 0<br>          iothreads: 9<br>          buffer: 8192<br>          accepts: 1000<br>          payload: 1048576<br>        hessian:<br>          name: hessian<br>          port: 18899<br>          serialization: hessian2<br>          payload: 10485760<br>          charset: UTF-8<br>          server: jetty<br>      registries:<br>        zk:<br>          address: zookeeper://192.168.199.8:2181<br>          default: true<br>        redis:<br>          address: redis://192.168.199.7:6379</p>
<p>如上的配置中，我们配置了 3 种不同的协议和 2 个注册中心应对不同的场景需要。</p>
<p>对应服务使用对应协议的配置如下：</p>
<p>​<br>    @Service(version = “1.0.0”,protocol = {“dubbo”},registry = {“zk”,”redis”},retries = 3,owner = “jaysong”,loadbalance = “roundrobin”)</p>
<p>​<br>​<br>    @Service(version = “1.0.0”,protocol = {“hessian”},registry = {“zk”})</p>
<h3 id="Dubbo-Admin控制台"><a href="#Dubbo-Admin控制台" class="headerlink" title="Dubbo Admin控制台"></a>Dubbo Admin控制台</h3><p>Dubbo 在阿里巴巴时代的时候有一个 dubbo-admin 的监控管理工具，Apache 时代在 Dubbo 2.6.0 版本以前都用的是 dubbo-<br>admin，可以前往 GitHub 上下载 dubbo-admin：<a href="https://github.com/apache/incubator-" target="_blank" rel="noopener">https://github.com/apache/incubator-</a><br>dubbo/tree/dubbo-2.6.0 ，或者直接下载一个 dubbo-admin.war 包，修改配置 dubbo.properties。</p>
<p>​<br>    # 保持心跳的注册中心<br>    dubbo.registry.address=zookeeper://127.0.0.1:2181<br>    # 用户名<br>    dubbo.admin.root.password=root<br>    # 密码<br>    dubbo.admin.guest.password=guest</p>
<p>然后直接在 Tomcat 等 Web 容器中运行，运行效果如下： <img src="https://images.gitbook.cn/89b9c210-2219-11e9-926b-057f0d535356" alt="dubbo-
admin"></p>
<p>Dubbo 2.6.0 版本以后，Apache 升级了dubbo-amdin 提供了 incubator-dubbo-ops 管理控制台运维工具使用。</p>
<p>当然很多功能都还在不断的版本迭代升级中（需要优化的点还很多）。可以到 <a href="https://github.com/apache/incubator-dubbo-" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo-</a><br>ops<br>这里下载最新的，当然我也集成到我的项目里了([传送门](<a href="https://github.com/Jaysong2012/dubbo/tree/master/dubbo-" target="_blank" rel="noopener">https://github.com/Jaysong2012/dubbo/tree/master/dubbo-</a><br>admin))。</p>
<p>运行步骤如下：</p>
<ul>
<li><p>修改 application.properties 中的心跳注册中心地址为你自己使用的注册中心地址；</p>
<pre><code>admin.registry.address=zookeeper://127.0.0.1:2181</code></pre><p>admin.config-center=zookeeper://127.0.0.1:2181<br>admin.metadata.address=zookeeper://127.0.0.1:2181</p>
</li>
<li><p>运行 dubbo-admin-backend 项目（spring boot 工程），默认使用 8080 端口，如果端口冲突，可以自行修改；</p>
</li>
<li><p>启动 dubbo-admin-frontend 项目（Node.js Vue 工程，需要安装Node.js），启动步骤如下：</p>
<pre><code># 安装依赖</code></pre><p>npm install</p>
<h1 id="启动项目，默认运行在-8081-端口"><a href="#启动项目，默认运行在-8081-端口" class="headerlink" title="启动项目，默认运行在 8081 端口"></a>启动项目，默认运行在 8081 端口</h1><p>npm run dev</p>
</li>
</ul>
<p>此时访问 <a href="http://localhost:8081" target="_blank" rel="noopener">http://localhost:8081</a> ，你将看到如下管理控制台运维页面。 <img src="https://images.gitbook.cn/545ccca0-221b-11e9-a919-ebf6dfb50acb" alt="dubbo-
ops"></p>
<p>例如，我们查看一个服务的明细: ![detail](<a href="https://images.gitbook.cn/cec6b0a0-221b-11e9-b5ff-" target="_blank" rel="noopener">https://images.gitbook.cn/cec6b0a0-221b-11e9-b5ff-</a><br>bf211fdb8da1)</p>
<p>其他，它可以提供的功能包括:<br><img src="https://images.gitbook.cn/b3891e40-221b-11e9-a919-ebf6dfb50acb" alt="fun"></p>
<p>这里我就不一一演示了，都很简单，大家自己摸索。</p>
<hr>
<p>本文首发于 GitChat，未经授权不得转载，转载需与 GitChat 联系。</p>
<p>12</p>
<p>写评论</p>
<p><a href="/m/mazi/author/5b8a9c01ab7d1e2cb083c1d2/question">向作者提问</a></p>
<h2 id="更多资源下载交流请加微信：Morstrong"><a href="#更多资源下载交流请加微信：Morstrong" class="headerlink" title="更多资源下载交流请加微信：Morstrong"></a>更多资源下载交流请加微信：Morstrong</h2><h1 id="本资源由微信公众号：光明顶一号，分享-一个用技术共享精品付费资源的公众号！"><a href="#本资源由微信公众号：光明顶一号，分享-一个用技术共享精品付费资源的公众号！" class="headerlink" title="本资源由微信公众号：光明顶一号，分享,一个用技术共享精品付费资源的公众号！"></a>本资源由微信公众号：光明顶一号，分享,一个用技术共享精品付费资源的公众号！</h1>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/09/03/Dubbo/深度学习Dubbo/">http://yoursite.com/2019/09/03/Dubbo/深度学习Dubbo/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/dubbo/"># dubbo</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/09/04/Mysql/SQL常见面试题解析/">SQL常见面试题</a>
            
            
            <a class="next" rel="next" href="/2019/08/31/数据结构算法/玩转数据结构慕课网/AVL树/">第七章  AVL树</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
