<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    
    
    <title>第七章  Redis复制与优化 | Hexo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Redis">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.css">
    <link rel="stylesheet" href="/css/style.css?v=1.4.3">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">John Doe</h5>
          <a href="mailto:1047629166@qq.com" title="1047629166@qq.com" class="mail">
            
              <span>1</span>
            
              <span>0</span>
            
              <span>4</span>
            
              <span>7</span>
            
              <span>6</span>
            
              <span>2</span>
            
              <span>9</span>
            
              <span>1</span>
            
              <span>6</span>
            
              <span>6</span>
            
              <span>@</span>
            
              <span>q</span>
            
              <span>q</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/codefine" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                HOME
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                CATEGORIES
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                TAGS
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                ARCHIVES
              </a>
            </li>
        
            <li class="">
              <a href="/custom"  >
                <i class="icon icon-lg icon-plus-square"></i>
                CUSTOM
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>第七章  Redis复制与优化</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">第七章  Redis复制与优化</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-08-05T11:59:28.489Z" itemprop="datePublished" class="page-time">
  2019-08-05
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Redis/">Redis</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">第七章  Redis复制与优化</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-08-05 19:59:28" datetime="2019-08-05T11:59:28.489Z"  itemprop="datePublished">2019-08-05</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Redis/">Redis</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h4 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h4><ul>
<li>命令实现：</li>
<li><figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-120947.png" title="image-20190805200946298" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-120947.png" alt="image-20190805200946298" title class></a>
                <p>image-20190805200946298</p>
            </figure>

</li>
</ul>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-121008.png" title="image-20190805201007180" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-121008.png" alt="image-20190805201007180" title class></a>
                <p>image-20190805201007180</p>
            </figure>

<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-121042.png" title="image-20190805201041289" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-121042.png" alt="image-20190805201041289" title class></a>
                <p>image-20190805201041289</p>
            </figure>

<hr>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-121055.png" title="image-20190805201054605" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-121055.png" alt="image-20190805201054605" title class></a>
                <p>image-20190805201054605</p>
            </figure>

<hr>
<hr>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-123558.png" title="image-20190805203557445" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-123558.png" alt="image-20190805203557445"></a></p>
<hr>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-123700.png" title="image-20190805203658640" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-123700.png" alt="image-20190805203658640" title class></a>
                <p>image-20190805203658640</p>
            </figure>

<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-124032.png" title="image-20190805204030842" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-124032.png" alt="image-20190805204030842" title class></a>
                <p>image-20190805204030842</p>
            </figure>

<h1 id="redis系列：主从复制"><a href="#redis系列：主从复制" class="headerlink" title="redis系列：主从复制"></a>redis系列：主从复制</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>这篇文章主要讲述Redis的主从复制功能。会依次从环境搭建、功能测试和原理分析几个方面进行介绍。</p>
<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h1><p>服务器架构图如下</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131754.png" title="image-20190805211753888" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131754.png" alt="image-20190805211753888" title class></a>
                <p>image-20190805211753888</p>
            </figure>



<p>启动主服务器101，使用<code>info replication</code>命令查看状态，可以看到role为master（也就是角色为主主服务器），connected_salaves的值为0（从服务器数量为0）</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131809.png" title="image-20190805211808251" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131809.png" alt="image-20190805211808251" title class></a>
                <p>image-20190805211808251</p>
            </figure>



<p>接下来用修改配置文件的方式将102机器加入的主从复制当中</p>
<p>然后再用命令的方式同样将103机器加入的主从复制当中。</p>
<h2 id="2-1-用修改配置文件的方式将102机器加入到主从"><a href="#2-1-用修改配置文件的方式将102机器加入到主从" class="headerlink" title="2.1 用修改配置文件的方式将102机器加入到主从"></a>2.1 用修改配置文件的方式将102机器加入到主从</h2><p>ip地址为192.168.17.102的机器的Redis配置文件增加slaveof 192.168.17.101 6379<br>启动102的redis，状态如下</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131822.png" title="image-20190805211821924" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131822.png" alt="image-20190805211821924" title class></a>
                <p>image-20190805211821924</p>
            </figure>



<p>可以看到role变为slave（角色为从服务器），master_host（主服务器IP地址）为192.168.17.101，master_port（主服务器端口）为6379。<br>此时101主服务器的主从状态如下,可以看到connected_salaves的值变为1，以及增加了一行slave0（从服务器的状态）</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131832.png" title="image-20190805211831926" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131832.png" alt="image-20190805211831926" title class></a>
                <p>image-20190805211831926</p>
            </figure>



<h2 id="2-2-用命令的方式将103机器加入到主从"><a href="#2-2-用命令的方式将103机器加入到主从" class="headerlink" title="2.2 用命令的方式将103机器加入到主从"></a>2.2 用命令的方式将103机器加入到主从</h2><p>未执行slaveof命令的主从状态如下</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131843.png" title="image-20190805211841628" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131843.png" alt="image-20190805211841628" title class></a>
                <p>image-20190805211841628</p>
            </figure>



<p>开始执行slaveof命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.17.103:6379&gt; slaveof 192.168.17.101 6379</span><br><span class="line">OK</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再次查看状态，可以看到角色已经变成从服务器</p>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131853.png" title="image-20190805211852175" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131853.png" alt="image-20190805211852175"></a></p>
<p>现在再来看看主服务器的状态，可以看到从服务器数量变成2，又多了一条从服务器的信息</p>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131904.png" title="image-20190805211904051" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131904.png" alt="image-20190805211904051"></a></p>
<p>到这里主从环境就搭好了，现在来测试一波</p>
<h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><p>现在主服务器101输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.17.101:6379&gt; set 101 101</span><br><span class="line">OK</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后在从服务器102上查看所有的键，发现有键101，接着设置键102</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">192.168.17.102:6379&gt; keys *</span><br><span class="line">1) &quot;101&quot;</span><br><span class="line">192.168.17.102:6379&gt; get 101</span><br><span class="line">&quot;101&quot;</span><br><span class="line">192.168.17.102:6379&gt; set 102 102</span><br><span class="line">(error) READONLY You can&apos;t write against a read only slave.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>发现出现错误<code>(error) READONLY You can&#39;t write against a read only slave.</code> 后面在讲述出错原因</p>
<p>现在在从服务器103上查看所有的键，发现也有<code>101</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.17.103:6379&gt; keys *</span><br><span class="line">1) &quot;101&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>再向主服务器101输入命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.17.101:6379&gt; set ip ip</span><br><span class="line">OK</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后到从服务器103上查看所有的键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">192.168.17.103:6379&gt; keys *</span><br><span class="line">1) &quot;101&quot;</span><br><span class="line">2) &quot;ip&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>可以看到多了一个键，说明主服务的数据同步到了从服务器上，操作过程看下图</p>
<p><a rel=第七章  Redis复制与优化 href="https://user-gold-cdn.xitu.io/2018/8/2/164f835be97005e3?imageslim" title="img" data-fancybox="images"><img src="https://user-gold-cdn.xitu.io/2018/8/2/164f835be97005e3?imageslim" alt="img"></a></p>
<h2 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h2><h3 id="2-4-1-error-READONLY-You-can’t-write-against-a-read-only-slave"><a href="#2-4-1-error-READONLY-You-can’t-write-against-a-read-only-slave" class="headerlink" title="2.4.1 (error) READONLY You can’t write against a read only slave."></a>2.4.1 (error) READONLY You can’t write against a read only slave.</h3><p>出现错误<code>(error) READONLY You can&#39;t write against a read only slave.</code> 是因为 从节点默认是只读的，如需修改可以再配置文件中修改下面这个属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slave-read-only yes</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-主服务器设置密码"><a href="#2-4-2-主服务器设置密码" class="headerlink" title="2.4.2 主服务器设置密码"></a>2.4.2 主服务器设置密码</h3><p>当主服务设置密码时，配置文件需要增加如需参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3 实现原理"></a>3 实现原理</h1><p>当我在从服务器103上输入slaveof命令时，出现如下日志</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131927.png" title="image-20190805211926657" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131927.png" alt="image-20190805211926657" title class></a>
                <p>image-20190805211926657</p>
            </figure>



<p>总的来说主从复制功能的详细步骤可以分为7个步骤：</p>
<ol>
<li>设置主服务器的地址和端口</li>
<li>建立套接字连接</li>
<li>发送PING命令</li>
<li>身份验证</li>
<li>发送端口信息</li>
<li>同步</li>
<li>命令传播</li>
</ol>
<p>接下来分别叙述每个步骤</p>
<h2 id="3-1设置主服务器的地址和端口"><a href="#3-1设置主服务器的地址和端口" class="headerlink" title="3.1设置主服务器的地址和端口"></a>3.1设置主服务器的地址和端口</h2><p>主从复制的第一步就是设置主服务器的地址和端口，当输入slaveof命令或者在配置文件中配置信息时，从服务器会将主服务器的ip地址和端口号保存到服务器状态的属性里面。</p>
<h2 id="3-2-建立套接字连接"><a href="#3-2-建立套接字连接" class="headerlink" title="3.2 建立套接字连接"></a>3.2 建立套接字连接</h2><p>在slaveof命令执行之后，从服务器会根据设置的ip和端口，向主服务器简历socket连接。</p>
<h2 id="3-3-发送PING命令"><a href="#3-3-发送PING命令" class="headerlink" title="3.3 发送PING命令"></a>3.3 发送PING命令</h2><p>socket连接成功后，从服务器会发送一PING命令给主服务器。</p>
<p>这时候PING命令可以检查socket的读写状态是否正常，还可以检查主服务器能否正常处理命令请求。</p>
<p>从服务器在发送PING命令时可能遇上的情况如下图</p>
<p><a rel=第七章  Redis复制与优化 href="data:image/svg+xml;utf8,%3C?xml%20version=%221.0%22?%3E%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22%20width=%22483%22%20height=%22299%22%3E%3C/svg%3E" title="图片来自Redis设计与实现" data-fancybox="images"><img src="data:image/svg+xml;utf8,%3C?xml%20version=%221.0%22?%3E%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22%20width=%22483%22%20height=%22299%22%3E%3C/svg%3E" alt="图片来自Redis设计与实现"></a></p>
<h2 id="3-4-身份验证"><a href="#3-4-身份验证" class="headerlink" title="3.4 身份验证"></a>3.4 身份验证</h2><p>从服务器收到主服务器的PONG回复后，会检查从服务器是否设置masterauth，设置则进行身份验证，未设置则跳过该步骤。从服务器在身份验证时可能遇上的情况如下</p>
<p><a rel=第七章  Redis复制与优化 href="data:image/svg+xml;utf8,%3C?xml%20version=%221.0%22?%3E%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22%20width=%22632%22%20height=%22560%22%3E%3C/svg%3E" title="图片来自Redis设计与实现" data-fancybox="images"><img src="data:image/svg+xml;utf8,%3C?xml%20version=%221.0%22?%3E%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20version=%221.1%22%20width=%22632%22%20height=%22560%22%3E%3C/svg%3E" alt="图片来自Redis设计与实现"></a></p>
<h2 id="3-5-发送端口信息"><a href="#3-5-发送端口信息" class="headerlink" title="3.5 发送端口信息"></a>3.5 发送端口信息</h2><p>身份验证通过后，从服务器会向主服务器发送自己的监听端口号。主服务器收到之后会将端口号记录到从服务器对应的状态属性中。在主服务器调用<code>info replication</code>可以看到从服务器的port，如下</p>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131939.png" title="image-20190805211938131" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131939.png" alt="image-20190805211938131"></a></p>
<h2 id="3-6-同步"><a href="#3-6-同步" class="headerlink" title="3.6 同步"></a>3.6 同步</h2><p>发送端口信息之后，从服务器会向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库同步至主服务器数据库当前的状态。</p>
<p>同步这块内容会在后面详细描述</p>
<h2 id="3-7-命令传播"><a href="#3-7-命令传播" class="headerlink" title="3.7 命令传播"></a>3.7 命令传播</h2><p>当完成同步操作之后，主从服务器便会进入命令传播阶段。这时候主从服务器的数据是一致的，当主服务器有新的写命令时，会将改命令发送给从服务器，从服务器接收命令并执行便可以保证与主服务器的数据保持一致。<br>那么Redis是如何保证主从服务器一致处于连接状态以及命令是否丢失？<br>答：命令传播阶段，从服务器会利用心跳检测机制定时的向主服务发送消息。<br>从服务器发送的命令如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>replication_offset表示从服务器当前的复制偏移量<br>接下来看看心跳机制</p>
<h3 id="3-7-1-心跳检测机制"><a href="#3-7-1-心跳检测机制" class="headerlink" title="3.7.1 心跳检测机制"></a>3.7.1 心跳检测机制</h3><p>心跳检测机制的作用有三个：</p>
<ol>
<li>检查主从服务器的网络连接状态</li>
<li>辅助实现min-slaves选项</li>
<li>检测命令丢失</li>
</ol>
<h4 id="3-7-1-1-检查主从服务器的网络连接状态"><a href="#3-7-1-1-检查主从服务器的网络连接状态" class="headerlink" title="3.7.1.1 检查主从服务器的网络连接状态"></a>3.7.1.1 检查主从服务器的网络连接状态</h4><p>主服务器信息中可以看到所属的从服务器的连接信息，state表示从服务器状态，offset表示复制偏移量，lag表示延迟值（几秒之前有过心跳检测机制）</p>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131952.png" title="image-20190805211951647" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-131952.png" alt="image-20190805211951647"></a></p>
<h4 id="3-7-1-2-辅助实现min-slaves选项"><a href="#3-7-1-2-辅助实现min-slaves选项" class="headerlink" title="3.7.1.2 辅助实现min-slaves选项"></a>3.7.1.2 辅助实现min-slaves选项</h4><p>Redis.conf配置文件中有下方两个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 未达到下面两个条件时，写操作就不会被执行</span><br><span class="line"># 最少包含的从服务器</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># 延迟值</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果将两个参数的注释取消，那么如果从服务器的数量少于3个，或者三个从服务器的延迟（lag）大于等于10秒时，主服务器都会拒绝执行写命令。</p>
<h4 id="3-7-1-3-检测命令丢失"><a href="#3-7-1-3-检测命令丢失" class="headerlink" title="3.7.1.3 检测命令丢失"></a>3.7.1.3 检测命令丢失</h4><p>在从服务器的连接信息中可以看到复制偏移量，如果此时主服务器的复制偏移量与从服务器的复制偏移量不一致时，主服务器会补发缺失的数据。</p>
<h1 id="4-同步原理"><a href="#4-同步原理" class="headerlink" title="4 同步原理"></a>4 同步原理</h1><p>同步分为全量重同步和部分重同步。那么是什么决定采取全量重同步还是部分重同步操作？</p>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132005.png" title="image-20190805212004746" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132005.png" alt="image-20190805212004746"></a></p>
<h2 id="4-1-全量重同步"><a href="#4-1-全量重同步" class="headerlink" title="4.1 全量重同步"></a>4.1 全量重同步</h2><p>全量重同步的步骤如下</p>
<ol>
<li>主节点收到从服务器的全量重同步请求时，主服务器便开始执行bgsave命令，同时用一个缓冲区记录从现在开始执行的所有写命令。</li>
<li>当主服务器的bgsave命令执行完毕后，会将生成的RDB文件发送给从服务器。从服务器接收到RDB文件时，会将数据文件保存到硬盘，然后加载到内存中。</li>
<li>主服务器将缓冲区所有缓存的命令发送到从服务器，从服务器接收并执行这些命令，将从服务器同步至主服务器相同的状态。</li>
</ol>
<h2 id="4-2-部分重同步"><a href="#4-2-部分重同步" class="headerlink" title="4.2 部分重同步"></a>4.2 部分重同步</h2><p>要想了解部分重同步的步骤，需要先了解部分重同步所需要的几个属性</p>
<ol>
<li>复制偏移量</li>
<li>复制缓冲区</li>
<li>运行ID</li>
</ol>
<h3 id="4-2-1-复制偏移量"><a href="#4-2-1-复制偏移量" class="headerlink" title="4.2.1 复制偏移量"></a>4.2.1 复制偏移量</h3><p>从主服务器的复制信息可以看到从服务器slave0和slave1都有一个参数offset，这个参数就是从服务器的复制偏移量。master_repl_offset这个参数就是主服务器的偏移量。如下图</p>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132016.png" title="image-20190805212015720" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132016.png" alt="image-20190805212015720"></a></p>
<p>主服务器的复制偏移量保存向从服务器发送过的字节数据。<br>从服务器的复制偏移量保存着从主服务器接收的字节数据。<br>通过对比主服务器和从服务器的复制偏移量就可以知道命令是否丢失，丢失则补发复制偏移量相差的字节命令。<br>那么这些字节数据是存放在哪里的呢？</p>
<h3 id="4-2-2-复制缓冲区"><a href="#4-2-2-复制缓冲区" class="headerlink" title="4.2.2 复制缓冲区"></a>4.2.2 复制缓冲区</h3><p>这些字节数据都是存放在主服务器的复制缓冲区里的。复制缓冲区是一个固定长度（fixed-size）先进先出（FIFO）的队列，默认大小为1MB。默认大小可以对下方的参数进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># repl-backlog-size 1mb</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>那么复制缓冲区的数据是什么时候加入进去的呢？</p>
<p>答：在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区。</p>
<p><a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132027.png" title="image-20190805212026304" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132027.png" alt="image-20190805212026304"></a></p>
<p>复制缓冲区里面会保存着一部分最传播的写命令和每个字节相应的复制偏移量。</p>
<p>由于复制缓冲区的大小是有限制的，所以保存的数据也是有限制的。如果从服务器与主服务器的复制偏移量相差的数据大于复制缓冲去存储的数据时，同样不会执行部分重同步。</p>
<p>举个例子，主服务器的复制偏移量为20000、缓冲区能保存的数据只有5000，从服务器的复制偏移量为10000。这时从服务器与主服务器复制偏移量10000，而缓冲区只有5000，那么还是会执行全量重同步。如果相差的复制偏移量小于5000，才会执行部分重同步。</p>
<h3 id="4-2-3-运行ID"><a href="#4-2-3-运行ID" class="headerlink" title="4.2.3 运行ID"></a>4.2.3 运行ID</h3><p>每个Redis服务器启动时，都会有自动生成自己的运行ID。<br>当从服务器对主服务器进行初次复制时，主服务器会发送自己的运行ID给从服务器。<br>当从服务器断线重连时，会将之前主服务器的运行ID发送给当前连接的主服务器。这时候会出现下面两种情况</p>
<ol>
<li>运行ID和主服务器一致，主服务器可以尝试执行部分重同步操作。</li>
<li>运行ID和主服务器不一致，说明之前连接的主服务器与这次连接不同，开始执行全量重同步操作。</li>
</ol>
<h1 id="5-相关配置"><a href="#5-相关配置" class="headerlink" title="5 相关配置"></a>5 相关配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">################################# REPLICATION #################################</span><br><span class="line"></span><br><span class="line"># slaveof &lt;主服务器ip&gt; &lt;主服务器端口&gt;</span><br><span class="line"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line"></span><br><span class="line"># masterauth &lt;主服务器Redis密码&gt;</span><br><span class="line"># masterauth &lt;master-password&gt;</span><br><span class="line"></span><br><span class="line"># 当slave丢失master或者同步正在进行时，如果发生对slave的服务请求</span><br><span class="line"># yes则slave依然正常提供服务</span><br><span class="line"># no则slave返回client错误：&quot;SYNC with master in progress&quot;</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 指定slave是否只读</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 无硬盘复制功能</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 无硬盘复制功能间隔时间</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># 从服务器发送PING命令给主服务器的周期</span><br><span class="line"># repl-ping-slave-period 10</span><br><span class="line"></span><br><span class="line"># 超时时间</span><br><span class="line"># repl-timeout 60</span><br><span class="line"></span><br><span class="line"># 是否禁用socket的NO_DELAY选项</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 设置主从复制容量大小，这个backlog 是一个用来在 slaves 被断开连接时存放 slave 数据的 buffer</span><br><span class="line"># repl-backlog-size 1mb</span><br><span class="line"></span><br><span class="line"># master 不再连接 slave时backlog的存活时间。</span><br><span class="line"># repl-backlog-ttl 3600</span><br><span class="line"></span><br><span class="line"># slave的优先级</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 未达到下面两个条件时，写操作就不会被执行</span><br><span class="line"># 最少包含的从服务器</span><br><span class="line"># min-slaves-to-write 3</span><br><span class="line"># 延迟值</span><br><span class="line"># min-slaves-max-lag 10</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>主从的配置文件：[<a href="https://github.com/rainbowda/learnWay/tree/master/learnRedis/replication，有需要可以下载。" target="_blank" rel="noopener">https://github.com/rainbowda/learnWay/tree/master/learnRedis/replication，有需要可以下载。</a></p>
<p>Redis的主从复制功能就介绍到这里了。虽然说主从解决了读写分离，读数据的负载均衡，但是一旦某个节点出现故障，不能自动回复，主从切换等功能。所以就有了哨兵的功能。</p>
<h1 id="深入学习Redis（3）：主从复制"><a href="#深入学习Redis（3）：主从复制" class="headerlink" title="深入学习Redis（3）：主从复制"></a><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面的两篇文章中，分别介绍了<a href="https://www.cnblogs.com/kismetv/p/8654978.html" target="_blank" rel="noopener">Redis的内存模型</a>和<a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">Redis的持久化</a>。</p>
<p>在Redis的持久化中曾提到，Redis高可用的方案包括持久化、主从复制（及读写分离）、哨兵和集群。其中持久化侧重解决的是Redis数据的单机备份问题（从内存到硬盘的备份）；而主从复制则侧重解决数据的多机热备。此外，主从复制还可以实现负载均衡和故障恢复。</p>
<p>这篇文章中，将详细介绍Redis主从复制的方方面面，包括：如何使用主从复制、主从复制的原理（重点是全量复制和部分复制、以及心跳机制）、实际应用中需要注意的问题（如数据不一致问题、复制超时问题、复制缓冲区溢出问题）、主从复制相关的配置（重点是repl-timeout、client-output-buffer-limit slave）等。</p>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://www.cnblogs.com/kismetv/p/8654978.html" target="_blank" rel="noopener">深入学习Redis（1）：Redis内存模型</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制
</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9609938.html" target="_blank" rel="noopener">深入学习Redis（4）：哨兵</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="https://www.cnblogs.com/kismetv/p/9236731.html#t1" target="_blank" rel="noopener">一、主从复制概述</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html#t2" target="_blank" rel="noopener">二、如何使用主从复制</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t21" target="_blank" rel="noopener">1.    建立复制</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t22" target="_blank" rel="noopener">2.    实例</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t23" target="_blank" rel="noopener">3.    断开复制</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html#t3" target="_blank" rel="noopener">三、主从复制的实现原理</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t31" target="_blank" rel="noopener">1.    连接建立阶段</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t32" target="_blank" rel="noopener">2.    数据同步阶段</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t33" target="_blank" rel="noopener">3.    命令传播阶段</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html#t4" target="_blank" rel="noopener">四、【数据同步阶段】全量复制和部分复制</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t41" target="_blank" rel="noopener">1.    全量复制</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t42" target="_blank" rel="noopener">2.    部分复制</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t43" target="_blank" rel="noopener">3.    psync命令的执行</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t44" target="_blank" rel="noopener">4.    部分复制演示</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html#t5" target="_blank" rel="noopener">五、【命令传播阶段】心跳机制</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t51" target="_blank" rel="noopener">1.    主-&gt;从：PING</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t52" target="_blank" rel="noopener">2.    从-&gt;主：REPLCONF ACK</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html#t6" target="_blank" rel="noopener">六、应用中的问题</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t61" target="_blank" rel="noopener">1.    读写分离及其中的问题</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t62" target="_blank" rel="noopener">2.    复制超时问题</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t63" target="_blank" rel="noopener">3.    复制中断问题</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t64" target="_blank" rel="noopener">4.    各场景下复制的选择及优化技巧</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t65" target="_blank" rel="noopener">5.    复制相关的配置</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t66" target="_blank" rel="noopener">6.    单机内存大小限制</a></p>
<p>​    <a href="https://www.cnblogs.com/kismetv/p/9236731.html#t67" target="_blank" rel="noopener">7.    info Replication</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9236731.html#t7" target="_blank" rel="noopener">七、总结</a></p>
<h1 id="一、主从复制概述"><a href="#一、主从复制概述" class="headerlink" title="一、主从复制概述"></a>一、主从复制概述</h1><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用</strong></p>
<p>主从复制的作用主要包括：</p>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ol>
<h1 id="二、如何使用主从复制"><a href="#二、如何使用主从复制" class="headerlink" title="二、如何使用主从复制"></a>二、如何使用主从复制</h1><p>为了更直观的理解主从复制，在介绍其内部原理之前，先说明我们需要如何操作才能开启主从复制。</p>
<h2 id="1-建立复制"><a href="#1-建立复制" class="headerlink" title="1. 建立复制"></a>1. 建立复制</h2><p>需要注意，<strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p>
<p>从节点开启主从复制，有3种方式：</p>
<p>（1）配置文件</p>
<p>在从服务器的配置文件中加入：slaveof <masterip> <masterport></masterport></masterip></p>
<p>（2）启动命令</p>
<p>redis-server启动命令后加入 –slaveof <masterip> <masterport></masterport></masterip></p>
<p>（3）客户端命令</p>
<p>Redis服务器启动后，直接通过客户端执行命令：slaveof <masterip> <masterport>，则该Redis实例成为从节点。</masterport></masterip></p>
<p>上述3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p>
<h2 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h2><h3 id="准备工作：启动两个节点"><a href="#准备工作：启动两个节点" class="headerlink" title="准备工作：启动两个节点"></a>准备工作：启动两个节点</h3><p>方便起见，实验所使用的主从节点是在一台机器上的不同Redis实例，其中主节点监听6379端口，从节点监听6380端口；从节点监听的端口号可以在配置文件中修改：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132039.png" title="image-20190805212038956" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132039.png" alt="image-20190805212038956" title class></a>
                <p>image-20190805212038956</p>
            </figure>

<p>启动后可以看到：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132046.png" title="image-20190805212045985" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132046.png" alt="image-20190805212045985" title class></a>
                <p>image-20190805212045985</p>
            </figure>

<p>两个Redis节点启动后（分别称为6379节点和6380节点），默认都是主节点。</p>
<h3 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h3><p>此时在6380节点执行slaveof命令，使之变为从节点：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132054.png" title="image-20190805212053324" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132054.png" alt="image-20190805212053324" title class></a>
                <p>image-20190805212053324</p>
            </figure>

<h3 id="观察效果"><a href="#观察效果" class="headerlink" title="观察效果"></a>观察效果</h3><p>下面验证一下，在主从复制建立后，主节点的数据会复制到从节点中。</p>
<p>（1）首先在从节点查询一个不存在的key：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011248863-775666084.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011248863-775666084.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p>（2）然后在主节点中增加这个key：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132103.png" title="image-20190805212101976" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132103.png" alt="image-20190805212101976" title class></a>
                <p>image-20190805212101976</p>
            </figure>

<p>（3）此时在从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011302404-417931505.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011302404-417931505.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p>（4）然后在主节点删除这个key：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132109.png" title="image-20190805212109135" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132109.png" alt="image-20190805212109135" title class></a>
                <p>image-20190805212109135</p>
            </figure>

<p>（5）此时在从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132116.png" title="image-20190805212116246" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132116.png" alt="image-20190805212116246" title class></a>
                <p>image-20190805212116246</p>
            </figure>

<h2 id="3-断开复制"><a href="#3-断开复制" class="headerlink" title="3. 断开复制"></a>3. 断开复制</h2><p>通过slaveof <masterip> <masterport>命令建立主从复制关系以后，可以通过slaveof no one断开。需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</masterport></masterip></p>
<p>从节点执行slaveof no one后，打印日志如下所示；可以看出断开复制后，从节点又变回为主节点。</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132122.png" title="image-20190805212122087" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132122.png" alt="image-20190805212122087" title class></a>
                <p>image-20190805212122087</p>
            </figure>

<p>主节点打印日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132127.png" title="image-20190805212126798" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132127.png" alt="image-20190805212126798" title class></a>
                <p>image-20190805212126798</p>
            </figure>

<h1 id="三、主从复制的实现原理"><a href="#三、主从复制的实现原理" class="headerlink" title="三、主从复制的实现原理"></a>三、主从复制的实现原理</h1><p>上面一节中，介绍了如何操作可以建立主从关系；本小节将介绍主从复制的实现原理。</p>
<p>主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段；下面分别进行介绍。</p>
<h2 id="1-连接建立阶段"><a href="#1-连接建立阶段" class="headerlink" title="1. 连接建立阶段"></a>1. 连接建立阶段</h2><p>该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</p>
<h3 id="步骤1：保存主节点信息"><a href="#步骤1：保存主节点信息" class="headerlink" title="步骤1：保存主节点信息"></a>步骤1：保存主节点信息</h3><p>从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</p>
<p>需要注意的是，<strong>slaveof**</strong>是异步命令，从节点完成主节点ip<strong><strong>和port</strong></strong>的保存后，向发送slaveof<strong><strong>命令的客户端直接返回OK</strong></strong>，实际的复制操作在这之后才开始进行。**</p>
<p>这个过程中，可以看到从节点打印日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132133.png" title="image-20190805212132686" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132133.png" alt="image-20190805212132686" title class></a>
                <p>image-20190805212132686</p>
            </figure>

<h3 id="步骤2：建立socket连接"><a href="#步骤2：建立socket连接" class="headerlink" title="步骤2：建立socket连接"></a>步骤2：建立socket连接</h3><p>从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，则：</p>
<p>从节点：为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p>
<p>主节点：接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，<strong>并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</strong></p>
<p>这个过程中，从节点打印日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132138.png" title="image-20190805212137946" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132138.png" alt="image-20190805212137946" title class></a>
                <p>image-20190805212137946</p>
            </figure>

<h3 id="步骤3：发送ping命令"><a href="#步骤3：发送ping命令" class="headerlink" title="步骤3：发送ping命令"></a>步骤3：发送ping命令</h3><p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：检查socket连接是否可用，以及主节点当前是否能够处理请求。</p>
<p>从节点发送ping命令后，可能出现3种情况：</p>
<p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p>
<p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p>
<p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p>
<p>在主节点返回pong情况下，从节点打印日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132143.png" title="image-20190805212143066" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132143.png" alt="image-20190805212143066" title class></a>
                <p>image-20190805212143066</p>
            </figure>

<h3 id="步骤4：身份验证"><a href="#步骤4：身份验证" class="headerlink" title="步骤4：身份验证"></a>步骤4：身份验证</h3><p>如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p>
<p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p>
<h3 id="步骤5：发送从节点端口信息"><a href="#步骤5：发送从节点端口信息" class="headerlink" title="步骤5：发送从节点端口信息"></a>步骤5：发送从节点端口信息</h3><p>身份验证之后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</p>
<h2 id="2-数据同步阶段"><a href="#2-数据同步阶段" class="headerlink" title="2. 数据同步阶段"></a>2. 数据同步阶段</h2><p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。</p>
<p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制，下面会有一章专门讲解这两种复制方式以及psync命令的执行过程，这里不再详述。</p>
<p>需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p>
<h2 id="3-命令传播阶段"><a href="#3-命令传播阶段" class="headerlink" title="3. 命令传播阶段"></a>3. 命令传播阶段</h2><p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。由于心跳机制的原理涉及部分复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。</p>
<p><strong>延迟与不一致</strong></p>
<p>需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p>
<p>repl-disable-tcp-nodelay no：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY；默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p>
<p>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p>
<h1 id="四、【数据同步阶段】全量复制和部分复制"><a href="#四、【数据同步阶段】全量复制和部分复制" class="headerlink" title="四、【数据同步阶段】全量复制和部分复制"></a>四、【数据同步阶段】全量复制和部分复制</h1><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；在Redis2.8及以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。后文介绍以Redis2.8及以后版本为例。</p>
<ol>
<li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li>
<li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li>
</ol>
<h2 id="1-全量复制"><a href="#1-全量复制" class="headerlink" title="1. 全量复制"></a>1. 全量复制</h2><p>Redis通过psync命令进行全量复制的过程如下：</p>
<p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p>
<p>（2）主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</p>
<p>（3）主节点的bgsave执行完成后，将RDB文件发送给从节点；<strong>从节点首先清除自己的旧数据，然后载入接收的**</strong>RDB<strong>**文件</strong>，将数据库状态更新至主节点执行bgsave时的数据库状态</p>
<p>（4）主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p>
<p>（5）如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态</p>
<p>下面是执行全量复制时，主从节点打印的日志；可以看出日志内容与上述步骤是完全对应的。</p>
<p>主节点的打印日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132153.png" title="image-20190805212150939" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132153.png" alt="image-20190805212150939" title class></a>
                <p>image-20190805212150939</p>
            </figure>

<p>从节点打印日志如下图所示：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132155.png" title="image-20190805212155008" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132155.png" alt="image-20190805212155008" title class></a>
                <p>image-20190805212155008</p>
            </figure>

<p>其中，有几点需要注意：从节点接收了来自主节点的89260个字节的数据；从节点在载入主节点的数据之前要先将老数据清除；从节点在同步完数据后，调用了bgrewriteaof。</p>
<p>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p>
<p>（1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；关于bgsave的性能问题，可以参考 <a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a></p>
<p>（2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</p>
<p>（3）从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</p>
<h2 id="2-部分复制"><a href="#2-部分复制" class="headerlink" title="2. 部分复制"></a>2. 部分复制</h2><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p>
<p>部分复制的实现，依赖于三个重要的概念：</p>
<h3 id="（1）复制偏移量"><a href="#（1）复制偏移量" class="headerlink" title="（1）复制偏移量"></a>（1）复制偏移量</h3><p>主节点和从节点分别维护一个复制偏移量（offset），代表的是<strong>主节点向从节点传递的字节数</strong>；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p>
<p>offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
<h3 id="（2）复制积压缓冲区"><a href="#（2）复制积压缓冲区" class="headerlink" title="（2）复制积压缓冲区"></a>（2）复制积压缓冲区</h3><p>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p>
<p>在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p>
<p>由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p>
<p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p>
<ul>
<li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li>
<li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li>
</ul>
<h3 id="（3）服务器运行ID-runid"><a href="#（3）服务器运行ID-runid" class="headerlink" title="（3）服务器运行ID(runid)"></a>（3）服务器运行ID(runid)</h3><p>每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。通过info Server命令，可以查看节点的runid：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132218.png" title="image-20190805212218251" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132218.png" alt="image-20190805212218251" title class></a>
                <p>image-20190805212218251</p>
            </figure>

<p>主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p>
<ul>
<li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li>
<li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li>
</ul>
<h2 id="3-psync命令的执行"><a href="#3-psync命令的执行" class="headerlink" title="3. psync命令的执行"></a>3. psync命令的执行</h2><p>在了解了复制偏移量、复制积压缓冲区、节点运行id之后，本节将介绍psync命令的参数和返回值，从而说明psync命令执行过程中，主从节点是如何确定使用全量复制还是部分复制的。</p>
<p>psync命令的执行过程可以参见下图（图片来源：《Redis设计与实现》）：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132213.png" title="imag![image-20190805212212118" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132213.png" alt="imag![image-20190805212212118" title class></a>
                <p>imag![image-20190805212212118</p>
            </figure>

<p>（1）首先，从节点根据当前状态，决定如何调用psync命令：</p>
<ul>
<li>如果从节点之前未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制；</li>
<li>如果从节点之前执行了slaveof，则发送命令为psync <runid> <offset>，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。</offset></runid></li>
</ul>
<p>（2）主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：</p>
<ul>
<li>如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；</li>
<li>如果主节点版本够新，且runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li>
<li>如果主节点版本够新，但是runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC <runid> <offset>，表示要进行全量复制，其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</offset></runid></li>
</ul>
<h2 id="4-部分复制演示"><a href="#4-部分复制演示" class="headerlink" title="4. 部分复制演示"></a>4. 部分复制演示</h2><p>在下面的演示中，网络中断几分钟后恢复，断开连接的主从节点进行了部分复制；为了便于模拟网络中断，本例中的主从节点在局域网中的两台机器上。</p>
<p><strong>网络中断</strong></p>
<p>网络中断一段时间后，主节点和从节点都会发现失去了与对方的连接（关于主从节点对超时的判断机制，后面会有说明）；此后，从节点便开始执行对主节点的重连，由于此时网络还没有恢复，重连失败，从节点会一直尝试重连。</p>
<p>主节点日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132229.png" title="image-20190805212228333" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132229.png" alt="image-20190805212228333" title class></a>
                <p>image-20190805212228333</p>
            </figure>

<p>从节点日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132225.png" title="image-20190805212224168" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132225.png" alt="image-20190805212224168" title class></a>
                <p>image-20190805212224168</p>
            </figure>

<p><strong>网络恢复</strong></p>
<p>网络恢复后，从节点连接主节点成功，并请求进行部分复制，主节点接收请求后，二者进行部分复制以同步数据。</p>
<p>主节点日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132239.png" title="image-20190805212238819" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132239.png" alt="image-20190805212238819" title class></a>
                <p>image-20190805212238819</p>
            </figure>

<p>从节点日志如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132234.png" title="image-20190805212233961" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-132234.png" alt="image-20190805212233961" title class></a>
                <p>image-20190805212233961</p>
            </figure>

<h1 id="五、【命令传播阶段】心跳机制"><a href="#五、【命令传播阶段】心跳机制" class="headerlink" title="五、【命令传播阶段】心跳机制"></a>五、【命令传播阶段】心跳机制</h1><p>在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p>
<h2 id="1-主-gt-从：PING"><a href="#1-主-gt-从：PING" class="headerlink" title="1.主-&gt;从：PING"></a>1.主-&gt;从：PING</h2><p>每隔指定的时间，<strong>主节点会向从节点发送**</strong>PING<strong>**命令</strong>，这个PING命令的作用，主要是为了让从节点进行超时判断。</p>
<p>PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p>
<p>关于该PING命令究竟是由主节点发给从节点，还是相反，有一些争议；因为在Redis的官方文档中，对该参数的注释中说明是从节点向主节点发送PING命令，如下图所示：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011653835-25800141.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011653835-25800141.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p>但是根据该参数的名称(含有ping-slave)，以及代码实现，我认为该PING命令是主节点发给从节点的。相关代码如下：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011700171-401488218.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011700171-401488218.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<h2 id="2-从-gt-主：REPLCONF-ACK"><a href="#2-从-gt-主：REPLCONF-ACK" class="headerlink" title="2. 从-&gt;主：REPLCONF ACK"></a>2. 从-&gt;主：REPLCONF ACK</h2><p>在命令传播阶段，<strong>从节点会向主节点发送**</strong>REPLCONF ACK<strong>**命令，</strong>频率是每秒1次；命令格式为：REPLCONF ACK {offset}，其中offset指从节点保存的复制偏移量。REPLCONF ACK命令的作用包括：</p>
<p>（1）实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1，如下图所示：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011708219-1385546367.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011708219-1385546367.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p>（2）检测命令丢失：从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。<strong>注意，**</strong>offset<strong>**和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</strong></p>
<p>（3）辅助保证从节点的数量和延迟：Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p>
<h1 id="六、应用中的问题"><a href="#六、应用中的问题" class="headerlink" title="六、应用中的问题"></a>六、应用中的问题</h1><h2 id="1-读写分离及其中的问题"><a href="#1-读写分离及其中的问题" class="headerlink" title="1. 读写分离及其中的问题"></a>1. 读写分离及其中的问题</h2><p>在主从复制基础上实现的读写分离，可以实现Redis的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高Redis服务器的并发量。下面介绍在使用Redis读写分离时，需要注意的问题。</p>
<h3 id="（1）延迟与不一致问题"><a href="#（1）延迟与不一致问题" class="headerlink" title="（1）延迟与不一致问题"></a>（1）延迟与不一致问题</h3><p>前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。</p>
<p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的slave-serve-stale-data参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。</p>
<h3 id="（2）数据过期问题"><a href="#（2）数据过期问题" class="headerlink" title="（2）数据过期问题"></a>（2）数据过期问题</h3><p>在单机版Redis中，存在两种删除策略：</p>
<ul>
<li>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li>
<li>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li>
</ul>
<p>在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p>
<p>Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p>
<h3 id="（3）故障切换问题"><a href="#（3）故障切换问题" class="headerlink" title="（3）故障切换问题"></a>（3）故障切换问题</h3><p>在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p>
<h3 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h3><p>在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p>
<h2 id="2-复制超时问题"><a href="#2-复制超时问题" class="headerlink" title="2. 复制超时问题"></a>2. 复制超时问题</h2><p>主从节点复制超时是导致复制中断的最重要的原因之一，本小节单独说明超时问题，下一小节说明其他会导致复制中断的问题。</p>
<p><strong>超时判断意义</strong></p>
<p>在复制连接建立过程中及之后，主从节点都有机制判断连接是否超时，其意义在于：</p>
<p>（1）如果主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；此外连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，有助于保证数据安全（配合前面讲到的min-slaves-to-write等参数）。</p>
<p>（2）如果从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致。</p>
<p><strong>判断机制</strong></p>
<p>主从复制超时判断的核心，在于repl-timeout参数，该参数规定了超时时间的阈值（默认60s），对于主节点和从节点同时有效；主从节点触发超时的条件分别如下：</p>
<p>（1）主节点：每秒1次调用复制定时函数replicationCron()，在其中判断当前时间距离上次收到各个从节点REPLCONF ACK的时间，是否超过了repl-timeout值，如果超过了则释放相应从节点的连接。</p>
<p>（2）从节点：从节点对超时的判断同样是在复制定时函数中判断，基本逻辑是：</p>
<ul>
<li>如果当前处于连接建立阶段，且距离上次收到主节点的信息的时间已超过repl-timeout，则释放与主节点的连接；</li>
<li>如果当前处于数据同步阶段，且收到主节点的RDB文件的时间超时，则停止数据同步，释放连接；</li>
<li>如果当前处于命令传播阶段，且距离上次收到主节点的PING命令或数据的时间已超过repl-timeout值，则释放与主节点的连接。</li>
</ul>
<p>主从节点判断连接超时的相关源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`/* Replication cron function, called 1 time per second. */``void` `replicationCron(``void``) &#123;``    ``static` `long` `long` `replication_cron_loops = 0;` `    ``/* Non blocking connection timeout? */``    ``if` `(server.masterhost &amp;&amp;``        ``(server.repl_state == REDIS_REPL_CONNECTING ||``         ``slaveIsInHandshakeState()) &amp;&amp;``         ``(``time``(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)``    ``&#123;``        ``redisLog(REDIS_WARNING,``&quot;Timeout connecting to the MASTER...&quot;``);``        ``undoConnectWithMaster();``    ``&#125;` `    ``/* Bulk transfer I/O timeout? */``    ``if` `(server.masterhost &amp;&amp; server.repl_state == REDIS_REPL_TRANSFER &amp;&amp;``        ``(``time``(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)``    ``&#123;``        ``redisLog(REDIS_WARNING,``&quot;Timeout receiving bulk data from MASTER... If the problem persists try to set the &apos;repl-timeout&apos; parameter in redis.conf to a larger value.&quot;``);``        ``replicationAbortSyncTransfer();``    ``&#125;` `    ``/* Timed out master when we are an already connected slave? */``    ``if` `(server.masterhost &amp;&amp; server.repl_state == REDIS_REPL_CONNECTED &amp;&amp;``        ``(``time``(NULL)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)``    ``&#123;``        ``redisLog(REDIS_WARNING,``&quot;MASTER timeout: no data nor PING received...&quot;``);``        ``freeClient(server.master);``    ``&#125;` `    ``//此处省略无关代码……` `    ``/* Disconnect timedout slaves. */``    ``if` `(listLength(server.slaves)) &#123;``        ``listIter li;``        ``listNode *ln;``        ``listRewind(server.slaves,&amp;li);``        ``while``((ln = listNext(&amp;li))) &#123;``            ``redisClient *slave = ln-&gt;value;``            ``if` `(slave-&gt;replstate != REDIS_REPL_ONLINE) ``continue``;``            ``if` `(slave-&gt;flags &amp; REDIS_PRE_PSYNC) ``continue``;``            ``if` `((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)``            ``&#123;``                ``redisLog(REDIS_WARNING, ``&quot;Disconnecting timedout slave: %s&quot;``,``                    ``replicationGetSlaveName(slave));``                ``freeClient(slave);``            ``&#125;``        ``&#125;``    ``&#125;` `    ``//此处省略无关代码……` `&#125;`</span><br></pre></td></tr></table></figure>

<p>　　</p>
<p><strong>需要注意的坑</strong></p>
<p>下面介绍与复制阶段连接超时有关的一些实际问题：</p>
<p>（1）数据同步阶段：在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。</p>
<p>（2）命令传播阶段：如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。</p>
<p>（3）慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。</p>
<h2 id="3-复制中断问题"><a href="#3-复制中断问题" class="headerlink" title="3. 复制中断问题"></a>3. 复制中断问题</h2><p>主从节点超时是复制中断的原因之一，除此之外，还有其他情况可能导致复制中断，其中最主要的是复制缓冲区溢出问题。</p>
<h3 id="复制缓冲区溢出"><a href="#复制缓冲区溢出" class="headerlink" title="复制缓冲区溢出"></a>复制缓冲区溢出</h3><p>前面曾提到过，在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：bgsave生成RDB文件、RDB文件由主节点发往从节点、从节点清空老数据并载入RDB文件中的数据。当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制-&gt;复制缓冲区溢出导致连接中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致连接中断……的循环。</p>
<p>复制缓冲区的大小由client-output-buffer-limit slave {hard limit} {soft limit} {soft seconds}配置，默认值为client-output-buffer-limit slave 256MB 64MB 60，其含义是：如果buffer大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。该参数是可以通过config set命令动态配置的（即不重启Redis也可以生效）。</p>
<p>当复制缓冲区溢出时，主节点打印日志如下所示：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012000540-1190099498.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012000540-1190099498.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p><strong>需要注意的是，复制缓冲区是客户端输出缓冲区的一种，主节点会为每一个从节点分别分配复制缓冲区；而复制积压缓冲区则是一个主节点只有一个，无论它有多少个从节点。</strong></p>
<h2 id="4-各场景下复制的选择及优化技巧"><a href="#4-各场景下复制的选择及优化技巧" class="headerlink" title="4. 各场景下复制的选择及优化技巧"></a>4. 各场景下复制的选择及优化技巧</h2><p>在介绍了Redis复制的种种细节之后，现在我们可以来总结一下，在下面常见的场景中，何时使用部分复制，以及需要注意哪些问题。</p>
<h3 id="（1）第一次建立复制"><a href="#（1）第一次建立复制" class="headerlink" title="（1）第一次建立复制"></a>（1）第一次建立复制</h3><p>此时全量复制不可避免，但仍有几点需要注意：如果主节点的数据量较大，应该尽量避开流量的高峰期，避免造成阻塞；如果有多个从节点需要建立对主节点的复制，可以考虑将几个从节点错开，避免主节点带宽占用过大。此外，如果从节点过多，也可以调整主从复制的拓扑结构，由一主多从结构变为树状结构（中间的节点既是其主节点的从节点，也是其从节点的主节点）；但使用树状结构应该谨慎：虽然主节点的直接从节点减少，降低了主节点的负担，但是多层从节点的延迟增大，数据一致性变差；且结构复杂，维护相当困难。</p>
<h3 id="（2）主节点重启"><a href="#（2）主节点重启" class="headerlink" title="（2）主节点重启"></a>（2）主节点重启</h3><p>主节点重启可以分为两种情况来讨论，一种是故障导致宕机，另一种则是有计划的重启。</p>
<p><strong>主节点宕机</strong></p>
<p>主节点宕机重启后，runid会发生变化，因此不能进行部分复制，只能全量复制。</p>
<p>实际上在主节点宕机的情况下，应进行故障转移处理，将其中的一个从节点升级为主节点，其他从节点从新的主节点进行复制；且故障转移应尽量的自动化，后面文章将要介绍的哨兵便可以进行自动的故障转移。</p>
<p><strong>安全重启：debug reload</strong></p>
<p>在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得runid发生变化，可能导致不必要的全量复制。</p>
<p>为了解决这个问题，Redis提供了debug reload的重启方式：<strong>重启后，主节点的**</strong>runid<strong><strong>和offset</strong></strong>都不受影响，**避免了全量复制。</p>
<p>如下图所示，debug reload重启后runid和offset都未受影响：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012018427-1532559550.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012018427-1532559550.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p>但debug reload是一柄双刃剑：它会清空当前内存中的数据，重新从RDB文件中加载，这个过程会导致主节点的阻塞，因此也需要谨慎。</p>
<h3 id="（3）从节点重启"><a href="#（3）从节点重启" class="headerlink" title="（3）从节点重启"></a>（3）从节点重启</h3><p>从节点宕机重启后，其保存的主节点的runid会丢失，因此即使再次执行slaveof，也无法进行部分复制。</p>
<h3 id="（4）网络中断"><a href="#（4）网络中断" class="headerlink" title="（4）网络中断"></a>（4）网络中断</h3><p>如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论。</p>
<p>第一种情况：网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发repl-timeout）；此时只需要通过REPLCONF ACK来补充丢失的数据即可。</p>
<p>第二种情况：网络问题时间很长，主从节点判断超时（触发了repl-timeout），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围；此时主从节点无法进行部分复制，只能进行全量复制。为了尽可能避免这种情况的发生，应该根据实际情况适当调整复制积压缓冲区的大小；此外及时发现并修复网络中断，也可以减少全量复制。</p>
<p>第三种情况：介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中；此时主从节点可以进行部分复制。</p>
<h2 id="5-复制相关的配置"><a href="#5-复制相关的配置" class="headerlink" title="5. 复制相关的配置"></a>5. 复制相关的配置</h2><p>这一节总结一下与复制有关的配置，说明这些配置的作用、起作用的阶段，以及配置方法等；通过了解这些配置，一方面加深对Redis复制的了解，另一方面掌握这些配置的方法，可以优化Redis的使用，少走坑。</p>
<p>配置大致可以分为主节点相关配置、从节点相关配置以及与主从节点都有关的配置，下面分别说明。</p>
<h3 id="（1）与主从节点都有关的配置"><a href="#（1）与主从节点都有关的配置" class="headerlink" title="（1）与主从节点都有关的配置"></a>（1）与主从节点都有关的配置</h3><p>首先介绍最特殊的配置，它决定了该节点是主节点还是从节点：</p>
<p>1)   slaveof <masterip> <masterport>：Redis启动时起作用；作用是建立复制关系，开启了该配置的Redis服务器在启动后成为从节点。该注释默认注释掉，即Redis服务器默认都是主节点。</masterport></masterip></p>
<p>2)   repl-timeout 60：与各个阶段主从节点连接超时判断有关，见前面的介绍。</p>
<h3 id="（2）主节点相关配置"><a href="#（2）主节点相关配置" class="headerlink" title="（2）主节点相关配置"></a>（2）主节点相关配置</h3><p>1)   repl-diskless-sync no：作用于全量复制阶段，控制主节点是否使用diskless复制（无盘复制）。所谓diskless复制，是指在全量复制时，主节点不再先把数据写入RDB文件，而是直接写入slave的socket中，整个过程中不涉及硬盘；diskless复制在磁盘IO很慢而网速很快时更有优势。需要注意的是，截至Redis3.0，diskless复制处于实验阶段，默认是关闭的。</p>
<p>2)   repl-diskless-sync-delay 5：该配置作用于全量复制阶段，当主节点使用diskless复制时，该配置决定主节点向从节点发送之前停顿的时间，单位是秒；只有当diskless复制打开时有效，默认5s。之所以设置停顿时间，是基于以下两个考虑：(1)向slave的socket的传输一旦开始，新连接的slave只能等待当前数据传输结束，才能开始新的数据传输 (2)多个从节点有较大的概率在短时间内建立主从复制。</p>
<p>3)   client-output-buffer-limit slave 256MB 64MB 60：与全量复制阶段主节点的缓冲区大小有关，见前面的介绍。</p>
<p>4)   repl-disable-tcp-nodelay no：与命令传播阶段的延迟有关，见前面的介绍。</p>
<p>5)   masterauth <master-password>：与连接建立阶段的身份验证有关，见前面的介绍。</master-password></p>
<p>6)   repl-ping-slave-period 10：与命令传播阶段主从节点的超时判断有关，见前面的介绍。</p>
<p>7)   repl-backlog-size 1mb：复制积压缓冲区的大小，见前面的介绍。</p>
<p>8)   repl-backlog-ttl 3600：当主节点没有从节点时，复制积压缓冲区保留的时间，这样当断开的从节点重新连进来时，可以进行全量复制；默认3600s。如果设置为0，则永远不会释放复制积压缓冲区。</p>
<p>9)   min-slaves-to-write 3与min-slaves-max-lag 10：规定了主节点的最小从节点数目，及对应的最大延迟，见前面的介绍。</p>
<h3 id="（3）从节点相关配置"><a href="#（3）从节点相关配置" class="headerlink" title="（3）从节点相关配置"></a>（3）从节点相关配置</h3><p>1)   slave-serve-stale-data yes：与从节点数据陈旧时是否响应客户端命令有关，见前面的介绍。</p>
<p>2)   slave-read-only yes：从节点是否只读；默认是只读的。由于从节点开启写操作容易导致主从节点的数据不一致，因此该配置尽量不要修改。</p>
<h2 id="6-单机内存大小限制"><a href="#6-单机内存大小限制" class="headerlink" title="6. 单机内存大小限制"></a>6. 单机内存大小限制</h2><p>在 <a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a> 一文中，讲到了fork操作对Redis单机内存大小的限制。实际上在Redis的使用中，限制单机内存大小的因素非常之多，下面总结一下在主从复制中，单机内存过大可能造成的影响：</p>
<p>（1）切主：当主节点宕机时，一种常见的容灾策略是将其中一个从节点提升为主节点，并将其他从节点挂载到新的主节点上，此时这些从节点只能进行全量复制；如果Redis单机内存达到10GB，一个从节点的同步时间在几分钟的级别；如果从节点较多，恢复的速度会更慢。如果系统的读负载很高，而这段时间从节点无法提供服务，会对系统造成很大的压力。</p>
<p>（2）从库扩容：如果访问量突然增大，此时希望增加从节点分担读负载，如果数据量过大，从节点同步太慢，难以及时应对访问量的暴增。</p>
<p>（3）缓冲区溢出：（1）和（2）都是从节点可以正常同步的情形（虽然慢），但是如果数据量过大，导致全量复制阶段主节点的复制缓冲区溢出，从而导致复制中断，则主从节点的数据同步会全量复制-&gt;复制缓冲区溢出导致复制中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致复制中断……的循环。</p>
<p>（4）超时：如果数据量过大，全量复制阶段主节点fork+保存RDB文件耗时过大，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入全量复制-&gt;超时导致复制中断-&gt;重连-&gt;全量复制-&gt;超时导致复制中断……的循环。</p>
<p>此外，主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大：最好只使用50%-65%的内存，留下30%-45%的内存用于执行bgsave命令和创建复制缓冲区等。</p>
<h2 id="7-info-Replication"><a href="#7-info-Replication" class="headerlink" title="7. info Replication"></a>7. info Replication</h2><p>在Redis客户端通过info Replication可以查看与复制相关的状态，对于了解主从节点的当前状态，以及解决出现的问题都会有帮助。</p>
<p>主节点：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012051376-2011129261.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012051376-2011129261.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p>从节点：</p>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012057112-2012438265.png" title="img" data-fancybox="images"><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628012057112-2012438265.png" alt="img" title class></a>
                <p>img</p>
            </figure>

<p>对于从节点，上半部分展示的是其作为从节点的状态，从connectd_slaves开始，展示的是其作为潜在的主节点的状态。</p>
<p>info Replication中展示的大部分内容在文章中都已经讲述，这里不再详述。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>下面回顾一下本文的主要内容：</p>
<p>1、主从复制的作用：宏观的了解主从复制是为了解决什么样的问题，即数据冗余、故障恢复、读负载均衡等。</p>
<p>2、主从复制的操作：即slaveof命令。</p>
<p>3、主从复制的原理：主从复制包括了连接建立阶段、数据同步阶段、命令传播阶段；其中数据同步阶段，有全量复制和部分复制两种数据同步方式；命令传播阶段，主从节点之间有PING和REPLCONF ACK命令互相进行心跳检测。</p>
<p>4、应用中的问题：包括读写分离的问题（数据不一致问题、数据过期问题、故障切换问题等）、复制超时问题、复制中断问题等，然后总结了主从复制相关的配置，其中repl-timeout、client-output-buffer-limit slave等对解决Redis主从复制中出现的问题可能会有帮助。</p>
<p>主从复制虽然解决或缓解了数据冗余、故障恢复、读负载均衡等问题，但其缺陷仍很明显：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制；这些问题的解决，需要哨兵和集群的帮助，我将在后面的文章中介绍，欢迎关注。</p>
<hr>
<hr>
<hr>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><ul>
<li>slave会通过被复制同步master上面的数据，形成数据副本</li>
<li>当master节点宕机时，slave可以升级为master节点承担写操作。</li>
<li>允许有一主多从，slave可以承担读操作，提高读性能，master承担写操作。即达到读写分离</li>
</ul>
<h2 id="二、简单性质"><a href="#二、简单性质" class="headerlink" title="二、简单性质"></a>二、简单性质</h2><ul>
<li>一个master可以有多个slave</li>
<li>每个slave只能有一个master</li>
<li>每个slave也可以有自己的多个slave</li>
<li>数据流是单向的，从master到slave</li>
</ul>
<h2 id="三、创建主从的方式"><a href="#三、创建主从的方式" class="headerlink" title="三、创建主从的方式"></a>三、创建主从的方式</h2><h3 id="1-slaveof命令"><a href="#1-slaveof命令" class="headerlink" title="1.slaveof命令"></a>1.slaveof命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在希望成为slave的节点中执行以下命令</span><br><span class="line">slaveof $&#123;masterIP&#125; $&#123;masterPort&#125;</span><br></pre></td></tr></table></figure>

<p>此过程会异步地将master节点中的数据全量地复制到当前节点中</p>
<h3 id="2-通过配置实现"><a href="#2-通过配置实现" class="headerlink" title="2.通过配置实现"></a>2.通过配置实现</h3><table>
<thead>
<tr>
<th align="center">配置项</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">salveof ${masterIP}  ${masterPort}</td>
<td align="center">设置当前节点作为其他节点的slave节点</td>
</tr>
<tr>
<td align="center">slave-read-only yes</td>
<td align="center">设置当前slave节点是只读的，不会执行写操作</td>
</tr>
</tbody></table>
<h3 id="3-取消主从的方式"><a href="#3-取消主从的方式" class="headerlink" title="3.取消主从的方式"></a>3.取消主从的方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#在不希望作为slave的节点中执行以下命令</span><br><span class="line">salveof no one</span><br></pre></td></tr></table></figure>

<p>执行完成之后，该节点的数据不会被清除。而是不会再同步master中的数据</p>
<h3 id="4-查看当前节点是否主从"><a href="#4-查看当前节点是否主从" class="headerlink" title="4.查看当前节点是否主从"></a>4.查看当前节点是否主从</h3><ul>
<li>info replication</li>
</ul>
<h1 id="run-id与偏移量"><a href="#run-id与偏移量" class="headerlink" title="run_id与偏移量"></a>run_id与偏移量</h1><h3 id="1-run-id"><a href="#1-run-id" class="headerlink" title="1.run_id"></a>1.run_id</h3><p>run_id是Redis 服务器的随机标识符，用于 Sentinel 和集群，服务重启后就会改变；</p>
<p>当slave节点复制时发现和之前的 run_id 不同时，将会对数据进行全量同步。</p>
<p>查看runid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 info server | grep run</span><br><span class="line">run_id:345dda992e5064bc80e01f96ea90f729b722b2ea</span><br></pre></td></tr></table></figure>

<h3 id="2-偏移量"><a href="#2-偏移量" class="headerlink" title="2.偏移量"></a>2.偏移量</h3><p>通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。</p>
<ul>
<li>参与复制的主从节点都会维护自身的复制偏移量。主节点（master）在处理完写命令后，会把命令的字节长度做累加记录，统计信息在info replication中的master_repl_offset指标中。</li>
<li>从节点每秒上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量</li>
<li>从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。统计在info replication中的slave_repl_offset指标中</li>
</ul>
<h1 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h1><h2 id="一、全量复制流程"><a href="#一、全量复制流程" class="headerlink" title="一、全量复制流程"></a>一、全量复制流程</h2><h3 id="1-slave-gt-master-psync-1"><a href="#1-slave-gt-master-psync-1" class="headerlink" title="1.slave -&gt; master : psync  ?  -1"></a>1.slave -&gt; master : psync  ?  -1</h3><ul>
<li>? 代表当前slave节点不知道master节点的runid</li>
<li>-1代表当前slave节点的偏移量为-1</li>
</ul>
<h3 id="2-master-gt-slave-FULLRESYNC-runId-offset"><a href="#2-master-gt-slave-FULLRESYNC-runId-offset" class="headerlink" title="2.master -&gt; slave : +FULLRESYNC runId offset"></a>2.master -&gt; slave : +FULLRESYNC runId offset</h3><ul>
<li>master通知slave节点需要进行全量复制</li>
<li>runId：master发送自身节点的runId给slave节点</li>
<li>offset：master发送自身节点的offset给slave节点</li>
</ul>
<h3 id="3-slave-save-masterInfo"><a href="#3-slave-save-masterInfo" class="headerlink" title="3.slave : save masterInfo"></a>3.slave : save masterInfo</h3><ul>
<li>slave节点保存master节点的相关信息（runId与偏移量）</li>
</ul>
<h3 id="4-master-bgsave"><a href="#4-master-bgsave" class="headerlink" title="4.master : bgsave"></a>4.master : bgsave</h3><ul>
<li>master节点通过bgsave命令进行RDB操作</li>
</ul>
<h3 id="5-master-gt-slave-send-RDB"><a href="#5-master-gt-slave-send-RDB" class="headerlink" title="5.master -&gt; slave : send RDB"></a>5.master -&gt; slave : send RDB</h3><ul>
<li>master将bgsave完的RDB结果发送给slave节点</li>
</ul>
<h3 id="6-master-gt-slave-send-buffer"><a href="#6-master-gt-slave-send-buffer" class="headerlink" title="6.master -&gt; slave : send buffer"></a>6.master -&gt; slave : send buffer</h3><ul>
<li>master在执行写操作时，会将写命令写入repl_back_buffer中</li>
<li>为了维护bgsave过程中执行的写操作命令，并同步给slave，master将期间的buffer发送给slave。</li>
</ul>
<h3 id="7-slave-flush-old-data"><a href="#7-slave-flush-old-data" class="headerlink" title="7.slave : flush old data"></a>7.slave : flush old data</h3><ul>
<li>slave节点将之前的数据全部清空</li>
</ul>
<h3 id="8-load-RDB"><a href="#8-load-RDB" class="headerlink" title="8.load RDB"></a>8.load RDB</h3><ul>
<li>slave节点加载RDB</li>
</ul>
<h2 id="二、全量复制的开销"><a href="#二、全量复制的开销" class="headerlink" title="二、全量复制的开销"></a>二、全量复制的开销</h2><ul>
<li>bgsave时间</li>
<li>RDB文件网络传输时间</li>
<li>slave节点清空数据时间</li>
<li>slave节点加载RDB的时间</li>
<li>可能的AOF重写时间，当加载完RDB之后，如果开启了AOF重写，需要重写AOF，以保证AOF最新</li>
</ul>
<h2 id="三、全量复制的高版本优化"><a href="#三、全量复制的高版本优化" class="headerlink" title="三、全量复制的高版本优化"></a>三、全量复制的高版本优化</h2><p>在redis4.0中，优化了psync，简称psync2，实现了即使redis实例重启的情况下也能实现部分同步</p>
<h1 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h1><h2 id="一、部分复制流程"><a href="#一、部分复制流程" class="headerlink" title="一、部分复制流程"></a>一、部分复制流程</h2><h3 id="1-slave-gt-master-Connection-lost"><a href="#1-slave-gt-master-Connection-lost" class="headerlink" title="1.slave -&gt; master : Connection lost"></a>1.slave -&gt; master : Connection lost</h3><ul>
<li>由于网络抖动等原因，slave对master的网络连接发生中断</li>
</ul>
<h3 id="2-slave-gt-master-Connection-to-master"><a href="#2-slave-gt-master-Connection-to-master" class="headerlink" title="2.slave -&gt; master : Connection to master"></a>2.slave -&gt; master : Connection to master</h3><ul>
<li>slave重新建立与master节点的连接</li>
</ul>
<h3 id="3-slave-gt-master-psync-runId-offset"><a href="#3-slave-gt-master-psync-runId-offset" class="headerlink" title="3.slave -&gt; master : psync runId offset"></a>3.slave -&gt; master : psync runId offset</h3><ul>
<li>slave节点发送master节点的runId以及自身的offset</li>
</ul>
<h3 id="4-master-gt-slave-：CONTINUE"><a href="#4-master-gt-slave-：CONTINUE" class="headerlink" title="4.master -&gt; slave ：CONTINUE"></a>4.master -&gt; slave ：CONTINUE</h3><ul>
<li>在第③步中，master节点校验offset，在当前buffer的范围中，则将反馈从节点CONTINUE表示部分复制。</li>
<li>如果offset不在当前buffer的范围中，则将反馈从节点FULLRESYNC表示需要全量复制</li>
<li>buffer的大小默认为1MB，由repl_back_buffer维护</li>
</ul>
<h3 id="5-master-gt-slave-send-partial-data"><a href="#5-master-gt-slave-send-partial-data" class="headerlink" title="5.master -&gt; slave : send partial data"></a>5.master -&gt; slave : send partial data</h3><ul>
<li>发送部分数据给slave节点让slave节点完成部分复制</li>
</ul>
<h1 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h1><h2 id="一、slave宕机故障"><a href="#一、slave宕机故障" class="headerlink" title="一、slave宕机故障"></a>一、slave宕机故障</h2><ul>
<li>会影响redis服务的整体读性能，对系统可用性没有影响，将slave节点重新启动并执行slaveof即可。</li>
</ul>
<h2 id="二、master宕机故障"><a href="#二、master宕机故障" class="headerlink" title="二、master宕机故障"></a>二、master宕机故障</h2><ul>
<li>redis将无法执行写请求，只有slave节点能执行读请求，影响了系统的可用性</li>
<li>方法1：<ul>
<li>随机找一个节点，执行slaveof no one，使其成为master节点</li>
<li>然后对其他slave节点执行slaveof newMatserIp newMasterPort</li>
</ul>
</li>
<li>方法2：<ul>
<li>马上重启master节点，它将会重新成为master</li>
</ul>
</li>
</ul>
<h1 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h1><h2 id="一、读写分离"><a href="#一、读写分离" class="headerlink" title="一、读写分离"></a>一、读写分离</h2><ul>
<li>含义：master只承担写请求，读请求分摊到slave节点执行</li>
<li>可能遇到的问题<ul>
<li>复制数据延迟<ul>
<li>当写操作从master同步到slave的时候，会有很短的延迟</li>
<li>当网络原因或者slave阻塞时，会有比较长的延迟</li>
<li>在这种情况下，可以通过配置一个事务中的读写都在主库得已实现</li>
<li>可以通过偏移量对这类问题进行监控</li>
</ul>
</li>
<li>读到过期数据（在v3.2中已经解决）<ul>
<li>删除过期数据的策略1：操作key的时候校验该key是否过期，如果已经过期，则删除</li>
<li>删除过期数据的策略2：redis内部有一个定时任务定时检查key有没有过期，如果采样的速度比不上过期数据的产生速度，会导致很多过期数据没有被删除。</li>
<li>在redis集群中，有一个约定，slave节点只能读取数据，而不能操作数据</li>
</ul>
</li>
<li>从节点故障</li>
</ul>
</li>
</ul>
<h2 id="二、配置不一致"><a href="#二、配置不一致" class="headerlink" title="二、配置不一致"></a>二、配置不一致</h2><ul>
<li>maxmemory不一致：可能会丢失数据<ul>
<li>例如master配置为4G，从节点配置为2G。</li>
</ul>
</li>
<li>数据结构优化参数（例如hash-max-ziplist-entries)：导致内存不一致</li>
</ul>
<h2 id="三、规避全量复制"><a href="#三、规避全量复制" class="headerlink" title="三、规避全量复制"></a>三、规避全量复制</h2><ul>
<li>第一次全量复制<ul>
<li>第一次不可避免</li>
<li>小主节点，低峰处理（夜间）</li>
</ul>
</li>
<li>节点运行ID不匹配<ul>
<li>主节点重启（运行ID变化）</li>
<li>可以使用故障转移进行处理，例如哨兵或集群。</li>
</ul>
</li>
<li>复制积压缓冲区不足<ul>
<li>如果offset在缓冲区之内，则可以完成部分复制，否则需要全量复制</li>
<li>可以增大复制缓冲区的大小：rel_backlog_size，默认1M，可以提升为10MB</li>
</ul>
</li>
</ul>
<h2 id="四、规避复制风暴"><a href="#四、规避复制风暴" class="headerlink" title="四、规避复制风暴"></a>四、规避复制风暴</h2><h3 id="1-单主节点复制风暴"><a href="#1-单主节点复制风暴" class="headerlink" title="1.单主节点复制风暴"></a>1.单主节点复制风暴</h3><ul>
<li>问题：主节点重启，多从节点复制</li>
<li>解决：更换复制拓扑，由(m-s1,s2,s3)的模式改成（m-s1-s1a,s1b)的模式，可以减轻master的压力</li>
</ul>
<h3 id="2-单机器复制风暴"><a href="#2-单机器复制风暴" class="headerlink" title="2.单机器复制风暴"></a>2.单机器复制风暴</h3><ul>
<li>如下图：机器宕机后，大量全量复制</li>
<li>解决：主节点分散多机器</li>
</ul>
<hr>
<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-230643.png" title="image-20190806070642691" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-230643.png" alt="image-20190806070642691" title class></a>
                <p>image-20190806070642691</p>
            </figure>

<figure class="image-box">
                <a rel=第七章  Redis复制与优化 href="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-230850.png" title="image-20190806070849190" data-fancybox="images"><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-230850.png" alt="image-20190806070849190" title class></a>
                <p>image-20190806070849190</p>
            </figure>


        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2019-08-05T23:08:54.675Z" itemprop="dateUpdated">2019-08-06 07:08:54</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2019/08/05/Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化/" target="_blank" rel="external">http://yoursite.com/2019/08/05/Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化/</a>
        
    </div>
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="John Doe">
            John Doe
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/08/05/Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化/&title=《第七章  Redis复制与优化》 — Hexo&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/08/05/Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化/&title=《第七章  Redis复制与优化》 — Hexo&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2019/08/06/Redis/慕课网redis从入门到高可用/第八章 RedisSentinel/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">第八章 Redis 哨兵模式</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2019/08/05/数据结构算法/玩转数据结构慕课网/第六章 二分搜索树/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">第六章 二分搜索树</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Redis主从复制"><span class="post-toc-number">1.</span> <span class="post-toc-text">Redis主从复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#两种方式"><span class="post-toc-number">1.0.0.1.</span> <span class="post-toc-text">两种方式</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#redis系列：主从复制"><span class="post-toc-number">2.</span> <span class="post-toc-text">redis系列：主从复制</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-简介"><span class="post-toc-number">3.</span> <span class="post-toc-text">1 简介</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#2-准备工作"><span class="post-toc-number">4.</span> <span class="post-toc-text">2 准备工作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-1-用修改配置文件的方式将102机器加入到主从"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">2.1 用修改配置文件的方式将102机器加入到主从</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-2-用命令的方式将103机器加入到主从"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">2.2 用命令的方式将103机器加入到主从</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-3-测试"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">2.3 测试</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-4-其他"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">2.4 其他</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-1-error-READONLY-You-can’t-write-against-a-read-only-slave"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">2.4.1 (error) READONLY You can’t write against a read only slave.</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-4-2-主服务器设置密码"><span class="post-toc-number">4.4.2.</span> <span class="post-toc-text">2.4.2 主服务器设置密码</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#3-实现原理"><span class="post-toc-number">5.</span> <span class="post-toc-text">3 实现原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-1设置主服务器的地址和端口"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">3.1设置主服务器的地址和端口</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-2-建立套接字连接"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">3.2 建立套接字连接</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-3-发送PING命令"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">3.3 发送PING命令</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-4-身份验证"><span class="post-toc-number">5.4.</span> <span class="post-toc-text">3.4 身份验证</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-5-发送端口信息"><span class="post-toc-number">5.5.</span> <span class="post-toc-text">3.5 发送端口信息</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-6-同步"><span class="post-toc-number">5.6.</span> <span class="post-toc-text">3.6 同步</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-7-命令传播"><span class="post-toc-number">5.7.</span> <span class="post-toc-text">3.7 命令传播</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-7-1-心跳检测机制"><span class="post-toc-number">5.7.1.</span> <span class="post-toc-text">3.7.1 心跳检测机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-7-1-1-检查主从服务器的网络连接状态"><span class="post-toc-number">5.7.1.1.</span> <span class="post-toc-text">3.7.1.1 检查主从服务器的网络连接状态</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-7-1-2-辅助实现min-slaves选项"><span class="post-toc-number">5.7.1.2.</span> <span class="post-toc-text">3.7.1.2 辅助实现min-slaves选项</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-7-1-3-检测命令丢失"><span class="post-toc-number">5.7.1.3.</span> <span class="post-toc-text">3.7.1.3 检测命令丢失</span></a></li></ol></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#4-同步原理"><span class="post-toc-number">6.</span> <span class="post-toc-text">4 同步原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-1-全量重同步"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">4.1 全量重同步</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-2-部分重同步"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">4.2 部分重同步</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-1-复制偏移量"><span class="post-toc-number">6.2.1.</span> <span class="post-toc-text">4.2.1 复制偏移量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-2-复制缓冲区"><span class="post-toc-number">6.2.2.</span> <span class="post-toc-text">4.2.2 复制缓冲区</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-2-3-运行ID"><span class="post-toc-number">6.2.3.</span> <span class="post-toc-text">4.2.3 运行ID</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#5-相关配置"><span class="post-toc-number">7.</span> <span class="post-toc-text">5 相关配置</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#结语"><span class="post-toc-number">8.</span> <span class="post-toc-text">结语</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#深入学习Redis（3）：主从复制"><span class="post-toc-number">9.</span> <span class="post-toc-text">深入学习Redis（3）：主从复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#系列文章"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">系列文章</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#目录"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">目录</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#一、主从复制概述"><span class="post-toc-number">10.</span> <span class="post-toc-text">一、主从复制概述</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二、如何使用主从复制"><span class="post-toc-number">11.</span> <span class="post-toc-text">二、如何使用主从复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-建立复制"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">1. 建立复制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-实例"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">2. 实例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#准备工作：启动两个节点"><span class="post-toc-number">11.2.1.</span> <span class="post-toc-text">准备工作：启动两个节点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#建立复制"><span class="post-toc-number">11.2.2.</span> <span class="post-toc-text">建立复制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#观察效果"><span class="post-toc-number">11.2.3.</span> <span class="post-toc-text">观察效果</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-断开复制"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">3. 断开复制</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#三、主从复制的实现原理"><span class="post-toc-number">12.</span> <span class="post-toc-text">三、主从复制的实现原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-连接建立阶段"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">1. 连接建立阶段</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#步骤1：保存主节点信息"><span class="post-toc-number">12.1.1.</span> <span class="post-toc-text">步骤1：保存主节点信息</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#步骤2：建立socket连接"><span class="post-toc-number">12.1.2.</span> <span class="post-toc-text">步骤2：建立socket连接</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#步骤3：发送ping命令"><span class="post-toc-number">12.1.3.</span> <span class="post-toc-text">步骤3：发送ping命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#步骤4：身份验证"><span class="post-toc-number">12.1.4.</span> <span class="post-toc-text">步骤4：身份验证</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#步骤5：发送从节点端口信息"><span class="post-toc-number">12.1.5.</span> <span class="post-toc-text">步骤5：发送从节点端口信息</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-数据同步阶段"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">2. 数据同步阶段</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-命令传播阶段"><span class="post-toc-number">12.3.</span> <span class="post-toc-text">3. 命令传播阶段</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#四、【数据同步阶段】全量复制和部分复制"><span class="post-toc-number">13.</span> <span class="post-toc-text">四、【数据同步阶段】全量复制和部分复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-全量复制"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">1. 全量复制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-部分复制"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">2. 部分复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（1）复制偏移量"><span class="post-toc-number">13.2.1.</span> <span class="post-toc-text">（1）复制偏移量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（2）复制积压缓冲区"><span class="post-toc-number">13.2.2.</span> <span class="post-toc-text">（2）复制积压缓冲区</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（3）服务器运行ID-runid"><span class="post-toc-number">13.2.3.</span> <span class="post-toc-text">（3）服务器运行ID(runid)</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-psync命令的执行"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">3. psync命令的执行</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-部分复制演示"><span class="post-toc-number">13.4.</span> <span class="post-toc-text">4. 部分复制演示</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#五、【命令传播阶段】心跳机制"><span class="post-toc-number">14.</span> <span class="post-toc-text">五、【命令传播阶段】心跳机制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-主-gt-从：PING"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">1.主-&gt;从：PING</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-从-gt-主：REPLCONF-ACK"><span class="post-toc-number">14.2.</span> <span class="post-toc-text">2. 从-&gt;主：REPLCONF ACK</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#六、应用中的问题"><span class="post-toc-number">15.</span> <span class="post-toc-text">六、应用中的问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#1-读写分离及其中的问题"><span class="post-toc-number">15.1.</span> <span class="post-toc-text">1. 读写分离及其中的问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（1）延迟与不一致问题"><span class="post-toc-number">15.1.1.</span> <span class="post-toc-text">（1）延迟与不一致问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（2）数据过期问题"><span class="post-toc-number">15.1.2.</span> <span class="post-toc-text">（2）数据过期问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（3）故障切换问题"><span class="post-toc-number">15.1.3.</span> <span class="post-toc-text">（3）故障切换问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（4）总结"><span class="post-toc-number">15.1.4.</span> <span class="post-toc-text">（4）总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#2-复制超时问题"><span class="post-toc-number">15.2.</span> <span class="post-toc-text">2. 复制超时问题</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#3-复制中断问题"><span class="post-toc-number">15.3.</span> <span class="post-toc-text">3. 复制中断问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#复制缓冲区溢出"><span class="post-toc-number">15.3.1.</span> <span class="post-toc-text">复制缓冲区溢出</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#4-各场景下复制的选择及优化技巧"><span class="post-toc-number">15.4.</span> <span class="post-toc-text">4. 各场景下复制的选择及优化技巧</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（1）第一次建立复制"><span class="post-toc-number">15.4.1.</span> <span class="post-toc-text">（1）第一次建立复制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（2）主节点重启"><span class="post-toc-number">15.4.2.</span> <span class="post-toc-text">（2）主节点重启</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（3）从节点重启"><span class="post-toc-number">15.4.3.</span> <span class="post-toc-text">（3）从节点重启</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（4）网络中断"><span class="post-toc-number">15.4.4.</span> <span class="post-toc-text">（4）网络中断</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#5-复制相关的配置"><span class="post-toc-number">15.5.</span> <span class="post-toc-text">5. 复制相关的配置</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（1）与主从节点都有关的配置"><span class="post-toc-number">15.5.1.</span> <span class="post-toc-text">（1）与主从节点都有关的配置</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（2）主节点相关配置"><span class="post-toc-number">15.5.2.</span> <span class="post-toc-text">（2）主节点相关配置</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#（3）从节点相关配置"><span class="post-toc-number">15.5.3.</span> <span class="post-toc-text">（3）从节点相关配置</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#6-单机内存大小限制"><span class="post-toc-number">15.6.</span> <span class="post-toc-text">6. 单机内存大小限制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#7-info-Replication"><span class="post-toc-number">15.7.</span> <span class="post-toc-text">7. info Replication</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#七、总结"><span class="post-toc-number">16.</span> <span class="post-toc-text">七、总结</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#主从复制"><span class="post-toc-number">17.</span> <span class="post-toc-text">主从复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、作用"><span class="post-toc-number">17.1.</span> <span class="post-toc-text">一、作用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、简单性质"><span class="post-toc-number">17.2.</span> <span class="post-toc-text">二、简单性质</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、创建主从的方式"><span class="post-toc-number">17.3.</span> <span class="post-toc-text">三、创建主从的方式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-slaveof命令"><span class="post-toc-number">17.3.1.</span> <span class="post-toc-text">1.slaveof命令</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-通过配置实现"><span class="post-toc-number">17.3.2.</span> <span class="post-toc-text">2.通过配置实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-取消主从的方式"><span class="post-toc-number">17.3.3.</span> <span class="post-toc-text">3.取消主从的方式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-查看当前节点是否主从"><span class="post-toc-number">17.3.4.</span> <span class="post-toc-text">4.查看当前节点是否主从</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#run-id与偏移量"><span class="post-toc-number">18.</span> <span class="post-toc-text">run_id与偏移量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-run-id"><span class="post-toc-number">18.0.1.</span> <span class="post-toc-text">1.run_id</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-偏移量"><span class="post-toc-number">18.0.2.</span> <span class="post-toc-text">2.偏移量</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#全量复制"><span class="post-toc-number">19.</span> <span class="post-toc-text">全量复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、全量复制流程"><span class="post-toc-number">19.1.</span> <span class="post-toc-text">一、全量复制流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-slave-gt-master-psync-1"><span class="post-toc-number">19.1.1.</span> <span class="post-toc-text">1.slave -&gt; master : psync  ?  -1</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-master-gt-slave-FULLRESYNC-runId-offset"><span class="post-toc-number">19.1.2.</span> <span class="post-toc-text">2.master -&gt; slave : +FULLRESYNC runId offset</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-slave-save-masterInfo"><span class="post-toc-number">19.1.3.</span> <span class="post-toc-text">3.slave : save masterInfo</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-master-bgsave"><span class="post-toc-number">19.1.4.</span> <span class="post-toc-text">4.master : bgsave</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-master-gt-slave-send-RDB"><span class="post-toc-number">19.1.5.</span> <span class="post-toc-text">5.master -&gt; slave : send RDB</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6-master-gt-slave-send-buffer"><span class="post-toc-number">19.1.6.</span> <span class="post-toc-text">6.master -&gt; slave : send buffer</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#7-slave-flush-old-data"><span class="post-toc-number">19.1.7.</span> <span class="post-toc-text">7.slave : flush old data</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#8-load-RDB"><span class="post-toc-number">19.1.8.</span> <span class="post-toc-text">8.load RDB</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、全量复制的开销"><span class="post-toc-number">19.2.</span> <span class="post-toc-text">二、全量复制的开销</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、全量复制的高版本优化"><span class="post-toc-number">19.3.</span> <span class="post-toc-text">三、全量复制的高版本优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#部分复制"><span class="post-toc-number">20.</span> <span class="post-toc-text">部分复制</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、部分复制流程"><span class="post-toc-number">20.1.</span> <span class="post-toc-text">一、部分复制流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-slave-gt-master-Connection-lost"><span class="post-toc-number">20.1.1.</span> <span class="post-toc-text">1.slave -&gt; master : Connection lost</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-slave-gt-master-Connection-to-master"><span class="post-toc-number">20.1.2.</span> <span class="post-toc-text">2.slave -&gt; master : Connection to master</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3-slave-gt-master-psync-runId-offset"><span class="post-toc-number">20.1.3.</span> <span class="post-toc-text">3.slave -&gt; master : psync runId offset</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4-master-gt-slave-：CONTINUE"><span class="post-toc-number">20.1.4.</span> <span class="post-toc-text">4.master -&gt; slave ：CONTINUE</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5-master-gt-slave-send-partial-data"><span class="post-toc-number">20.1.5.</span> <span class="post-toc-text">5.master -&gt; slave : send partial data</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#故障处理"><span class="post-toc-number">21.</span> <span class="post-toc-text">故障处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、slave宕机故障"><span class="post-toc-number">21.1.</span> <span class="post-toc-text">一、slave宕机故障</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、master宕机故障"><span class="post-toc-number">21.2.</span> <span class="post-toc-text">二、master宕机故障</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#开发与运维中的问题"><span class="post-toc-number">22.</span> <span class="post-toc-text">开发与运维中的问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、读写分离"><span class="post-toc-number">22.1.</span> <span class="post-toc-text">一、读写分离</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、配置不一致"><span class="post-toc-number">22.2.</span> <span class="post-toc-text">二、配置不一致</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、规避全量复制"><span class="post-toc-number">22.3.</span> <span class="post-toc-text">三、规避全量复制</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、规避复制风暴"><span class="post-toc-number">22.4.</span> <span class="post-toc-text">四、规避复制风暴</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1-单主节点复制风暴"><span class="post-toc-number">22.4.1.</span> <span class="post-toc-text">1.单主节点复制风暴</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2-单机器复制风暴"><span class="post-toc-number">22.4.2.</span> <span class="post-toc-text">2.单机器复制风暴</span></a></li></ol></li></ol></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    

</div>

    </main>
    <footer class="footer ">
    
    <div class="top">
        
            <p>
    <span>Links：</span>
    
    <span class="blogroll-item">
        <a href="https://www.lujingtao.com" target="_blank">HOME</a>
    </span>
    
</p>

        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                John Doe &copy; 2017 - 2019
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/08/05/Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化/&title=《第七章  Redis复制与优化》 — Hexo&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/08/05/Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化/&title=《第七章  Redis复制与优化》 — Hexo&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD7ElEQVR42u3aO5KjQBAFQN3/0lp3jAW9V9UoZCTWBELQnUxEqT6vV3y8/xz59Vdnru52dc3906+uyVdbHzhw4MCBI95qfuvkWzPo+783V0arxYEDBw4chzjug2X7sDygtqE9eUoedHHgwIEDxy9wtClcu4E8YN9fjwMHDhw4fp+jPTNjfcdH+0pw4MCBA8c3OZLiYJLUzUp4yfUzxAdrpThw4MCBY9IVigqFv//3I/MdOHDgwIFjkSzljzxV2nvi/h92hwMHDhw4zgSK1ymCTQOpHW7YFBw/oOPAgQMHjjXHLFBtAuGmNZVsLB/mw4EDBw4cZznuN7Pf0qx9lQ9VzF7J5Rpw4MCBA8dRjjwstWW+PHDm4bwtI0Y0OHDgwIFjzZEPLrTpWR6kNxxPDPDhwIEDB44NRz5wli96NvpwH6TbxLIYX0j+F3DgwIEDR8mRB9Rk87PzbbDPk8NkDThw4MCB45scm1JdO1iQt5qKuYzg5eHAgQMHjlMc7U33RcC8TdW2mtrEEgcOHDhwPM2RDwTsU7VNoTCHywM2Dhw4cOB4jqMt2OU0+TWz0uE+8OPAgQMHjrMcZ8NeG/z2r6EtZV4+FwcOHDhwLDiSDWwaOW2zqk0vNyXFD104HDhw4MCx5ii+VpbhZsXEJEzOipvDThoOHDhw4Ijj2ix9SsJeEpjb1K4NvfX6ceDAgQPHIY52oK3d6n5gYvMC6kCLAwcOHDgWKdyx4tq6bNd+K28yRU01HDhw4MCx5pi1i/L0LCfLv5WXC2d7wYEDBw4cpzjytOo+XCVFunysLb/bJiP7UBzEgQMHDhwlR5vkzPjyAYW25Ne+vFd74MCBAweOkmNftpsV6dqyYDuuNwv2OHDgwIFjwzHbWPJpO6ywv+cmPOPAgQMHjrMcyYJmAwp5K2hGthnI+M8ZHDhw4MCx5kiGCdr0bBN6Z2MNLXq0Ixw4cODAMeJIxhE2baR8DGL/YvIQiwMHDhw4nuPIm0mbDWyG2HL0vMkUtbJw4MCBA8eII8/z8iLdfsggT8CSBK8oceLAgQMHjkMcm4Rnn6TNGldt8I4+xYEDBw4ca45ZIjQbEUg2P0vP2vvXZUEcOHDgwBFzvMtjM0DQlu3yIYn2h0JdHMSBAwcOHF1MrMPerLGUXzN7Me3922QSBw4cOHDkHPmD27RqT9z+CGgDbbQsHDhw4MAx4sgbOXl57hTT8NfBpkSIAwcOHDi+yJG0iFqa/RhEOx5xLNDiwIEDB45DOcu+tNeOMuR8eTHxcr4DBw4cOHCsOfYPyMPw7J6nhhg+rA0HDhw4cJyPYnXykyAmZ/LEL08IZwknDhw4cOAYcfwDAnEqXHxJiSEAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.4.3"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.4.3"></script>
<script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.2/dist/jquery.fancybox.min.js"></script>

<script type="text/javascript" src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.4.3"></script>
<script type="text/javascript" src="/js/blog.js?v=1.4.3"></script>

<!-- third-party -->






<script type="text/javascript" src="/js/plugins/local_search.js?v=1.4.3"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>







    
</body>
</html>
