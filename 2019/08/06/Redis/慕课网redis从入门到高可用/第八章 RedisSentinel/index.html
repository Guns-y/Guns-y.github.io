<!DOCTYPE html>
<html lang>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">



<title>第八章 Redis 哨兵模式 | Hexo</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Ferrymana&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Ferrymana&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">第八章 Redis 哨兵模式</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">John Doe</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 6, 2019&nbsp;&nbsp;7:04:18</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/categories/Redis/">Redis</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h1><ul>
<li>当master节点发生故障时，需要手动进行故障转移</li>
<li>写能力与存储能力受限，写能力和存储能力都依赖于master节点</li>
</ul>
<h1 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h1><p>​    在主从复制的基础上，新增多个Redis Sentinel节点，这些Sentinel不存储任何的数据。这些Sentinel节点会完成Redis的故障判断并故障转移的处理，然后通知客户端。一套Redis Sentinel集群可以监控多套Redis主从，每一套Redis主从通过master-name作为标识。</p>
<p>​    客户端不直接连接Redis服务，而连接Redis Sentinel。在Redis Sentinel中清楚哪个节点是master节点。</p>
<p>故障转移流程</p>
<ol>
<li>多个Sentinel发现并确认master有问题</li>
<li>选举出一个Sentinel作为领导</li>
<li>选出一个slave作为master</li>
<li>通知其余slave成为新的master的slave</li>
<li>通知客户端主从发生的变化</li>
<li>等待老的master复活成为新master的slave</li>
</ol>
<h1 id="Redis-Sentinel的相关配置"><a href="#Redis-Sentinel的相关配置" class="headerlink" title="Redis Sentinel的相关配置"></a>Redis Sentinel的相关配置</h1><table>
<thead>
<tr>
<th>配置</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>port ${port}</td>
<td>sentinel的端口号</td>
</tr>
<tr>
<td>dir “/redisDataPath”</td>
<td>redis的工作目录</td>
</tr>
<tr>
<td>logfile “${port}.log”</td>
<td>redis的日志文件</td>
</tr>
<tr>
<td>sentinel monitor mymaster 127.0.0.1 7000 2</td>
<td>名称为mymaster的主从 masterIP=127.0.0.1   masterPort=7000 2个sentinel发现这个master有问题后执行故障转移</td>
</tr>
<tr>
<td>sentinel down-after-milliseconds mymaster 30000</td>
<td>每个sentinel在连续ping 30000ms不通后认为有问题</td>
</tr>
<tr>
<td>sentinel parallel-syncs mymaster 1</td>
<td>在故障转移时，该名称为mymaster的集群中 同一时间点只允许1个节点进行复制</td>
</tr>
<tr>
<td>sentinel failover-timeout mymaster 180000</td>
<td>故障转移的超时时间</td>
</tr>
</tbody></table>
<h1 id="Redis-Sentinel的安装与配置"><a href="#Redis-Sentinel的安装与配置" class="headerlink" title="Redis Sentinel的安装与配置"></a>Redis Sentinel的安装与配置</h1><h3 id="1-配置开启主从节点"><a href="#1-配置开启主从节点" class="headerlink" title="1.配置开启主从节点"></a>1.配置开启主从节点</h3><ul>
<li>redis-7000.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 7000</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7000.pid</span><br><span class="line">logfile &quot;7000.log&quot;</span><br><span class="line">dir /redisDataPath</span><br></pre></td></tr></table></figure>

<ul>
<li>redis-7001.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7001</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7001.pid</span><br><span class="line">logfile &quot;7001.log&quot;</span><br><span class="line">dir /redisDataPath</span><br><span class="line">slaveof 127.0.0.1  7000</span><br></pre></td></tr></table></figure>

<ul>
<li>redis-7002.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 7002</span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis-7002.pid</span><br><span class="line">logfile &quot;7002.log&quot;</span><br><span class="line">dir /redisDataPath</span><br><span class="line">slaveof 127.0.0.1 7000</span><br></pre></td></tr></table></figure>

<h3 id="2-配置开启sentinel监控主节点（sentinel是特殊的redis）"><a href="#2-配置开启sentinel监控主节点（sentinel是特殊的redis）" class="headerlink" title="2.配置开启sentinel监控主节点（sentinel是特殊的redis）"></a>2.配置开启sentinel监控主节点（sentinel是特殊的redis）</h3><ul>
<li>redis-26379.conf（redis sentinel的默认端口是26379）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26379</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/redisDataPath&quot;</span><br><span class="line">logfile &quot;26379.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<ul>
<li>redis-26380.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26380</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/redisDataPath&quot;</span><br><span class="line">logfile &quot;26380.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<ul>
<li>redis-26381.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26381</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/redisDataPath&quot;</span><br><span class="line">logfile &quot;26381.log&quot;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 7000 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>

<h1 id="客户端接入基本原理"><a href="#客户端接入基本原理" class="headerlink" title="客户端接入基本原理"></a>客户端接入基本原理</h1><ol>
<li>客户端需要<strong>所有的sentinel节点</strong>以及对应的<strong>masterName</strong></li>
<li>客户端会遍历所有的sentinel节点，获取一个可用的sentinel节点</li>
<li>向<strong>可用的sentinel</strong>调用  <strong>sentinel get-master-addr-by-name masterName</strong>， 可用的sentinel将返回master节点信息。</li>
<li>客户端连接该master节点，调用role或者role replication，确认该节点是master节点。</li>
<li>如果master发生故障转移，sentinel是能够感知，并通过发布订阅模型将最新的master信息告知客户端</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; sentinelSet = new HashSet&lt;String&gt;() &#123;&#123;</span><br><span class="line">    add(&quot;127.0.0.1:26379&quot;);</span><br><span class="line">    add(&quot;127.0.0.1:26380&quot;);</span><br><span class="line">    add(&quot;127.0.0.1:26381&quot;);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">JedisPoolConfig poolConfig = new JedisPoolConfig();</span><br><span class="line">String masterName = &quot;myMaster&quot;;</span><br><span class="line">int timeout = 30_000; //jedis连接sentinel的超时时间</span><br><span class="line">JedisSentinelPool sentinelPool = new JedisSentinelPool(</span><br><span class="line">          masterName , sentinelSet , poolConfig , timeout);</span><br><span class="line">Jedis jedis = sentinelPool.getResource();</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure>

<h1 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h1><ul>
<li>每10秒每个sentinel对master和slave执行info<ul>
<li>发现slave节点</li>
<li>确认主从关系</li>
</ul>
</li>
<li>每2秒每个sentinel通过mster节点的channel交换信息（pub/sub)<ul>
<li>通过<strong>sentinel</strong>:hello频道交互</li>
<li>交互对节点的“看法”和自身信息</li>
</ul>
</li>
<li>每1秒每个sentinel对其他sentinel和redis执行ping</li>
</ul>
<h1 id="主观下线与客观下线"><a href="#主观下线与客观下线" class="headerlink" title="主观下线与客观下线"></a>主观下线与客观下线</h1><ul>
<li>主观下线：每个sentinel节点对Redis节点失败的看法。<ul>
<li>sentinel down-after-milliseconds masterName timeout</li>
<li>每个sentinel节点每秒会对Redis节点进行ping，当连续timeout毫秒之后还没有得到PONG，则sentinel认为redis下线。</li>
</ul>
</li>
<li>客观下线：所有sentinel节点对Redis节点失败达成共识。<ul>
<li>sentinel monitor masterName ip port quorum</li>
<li>大于等于quorum个sentinel主观认为Redis节点失败下线</li>
<li>通过sentinel is-master-down-by-addr提出自己认为Redis master下线</li>
</ul>
</li>
</ul>
<h1 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h1><ul>
<li>原因：只有sentinel节点完成故障转移</li>
<li>选举：通过 sentinel is-master-down-by-addr 命令都希望成为领导者<ul>
<li>每个主观下线的sentinel节点向其他sentinel节点发送命令，要求将它设置为领导者</li>
<li>收到命令的Sentinel节点如果没有同意其他Sentinel节点发送的命令，那么将同意该请求，否则拒绝。</li>
<li>如果该Sentinel节点发现自己的票数已经超过Sentinel集合半数且超过quorum，那么将它成为领导者</li>
<li>如果此过程有多个Sentinel节点成为了领导者，那么将等待一段时间重新进行选举</li>
</ul>
</li>
</ul>
<h1 id="故障转移（Sentinel领导者节点完成之后）"><a href="#故障转移（Sentinel领导者节点完成之后）" class="headerlink" title="故障转移（Sentinel领导者节点完成之后）"></a>故障转移（Sentinel领导者节点完成之后）</h1><ol>
<li>从slave节点中选出一个“合适的”节点作为新的master节点<ul>
<li>选择slave-priority(slave节点优先级)最高的slave节点，如果存在则返回，不存在则继续</li>
<li>选择复制偏移量最大的slave节点（复制的最完整性），如果存在则返回，不存在则继续</li>
<li>选择runId最小的slave节点</li>
</ul>
</li>
<li>对上面的slave节点执行slave no one命令让其成为master节点</li>
<li>向其余的slave节点发送命令，让它们成为新master节点的slave节点，复制规则和parallel-syncs参数有关。</li>
<li>更新对原来master节点配置为slave，并保持对其“关注”，当其恢复后命令它去复制新的master节点</li>
</ol>
<h1 id="节点运维（上线与下线）"><a href="#节点运维（上线与下线）" class="headerlink" title="节点运维（上线与下线）"></a>节点运维（上线与下线）</h1><h3 id="生产节点下线可能原因"><a href="#生产节点下线可能原因" class="headerlink" title="生产节点下线可能原因"></a>生产节点下线可能原因</h3><ul>
<li>机器下线：过保等情况</li>
<li>机器性能不足：例如CPU、内存、磁盘、网络等</li>
</ul>
<h3 id="1-主节点"><a href="#1-主节点" class="headerlink" title="1.主节点"></a>1.主节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##节点下线</span><br><span class="line">##手动进行故障转移</span><br><span class="line">sentinel failover $&#123;masterName&#125;</span><br><span class="line">##跳过主观下线、客观下线与领导者选举，领导者即为当前连接的sentinel节点</span><br><span class="line"></span><br><span class="line">##节点上线</span><br><span class="line">config set slave-priority num  #调大新增节点的优先级</span><br><span class="line">sentinel failover $&#123;masterName&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-从节点"><a href="#2-从节点" class="headerlink" title="2.从节点"></a>2.从节点</h3><p>需要区分是临时下线还是永久下线。例如需要做一些配置、AOF、RDB等方面的清理工作。</p>
<p>当上线时候，执行slaveof masterIp masterPort即可</p>
<h3 id="3-Sentinel节点"><a href="#3-Sentinel节点" class="headerlink" title="3.Sentinel节点"></a>3.Sentinel节点</h3><p>需要区分是临时下线还是永久下线。例如需要做一些配置的清理工作。</p>
<h1 id="高可用读写分离"><a href="#高可用读写分离" class="headerlink" title="高可用读写分离"></a>高可用读写分离</h1><p>可以考虑尝试扩展 JedisSentinelPool，维护master节点与slave节点池</p>
<p>并关注三条消息来维护节点池</p>
<ul>
<li>switch-master : 切换主节点（从节点晋升为主节点）</li>
<li>convert-to-slave : 切换从节点（原主节点降为从节点）</li>
<li>sdown : 主动下线</li>
</ul>
<hr>
<hr>
<hr>
<h1 id="redis系列：哨兵"><a href="#redis系列：哨兵" class="headerlink" title="redis系列：哨兵"></a>redis系列：哨兵</h1><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>Sentinel（哨兵）是Redis 的高可用性解决方案：通过哨兵可以创建一个当主服务器出现故障时自动将从服务器升级为主服务器的一个分布式系统。解决了主从复制出现故障时需要人为干预的问题。<br>这篇介绍哨兵的搭建，以及哨兵是如何进行哨兵发现和主从切换等功能。</p>
<h1 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h1><p>在原先主从的基础上，每台机器启动一个哨兵。架构图如下</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-230927.png" alt="image-20190806070925792"></p>
<h2 id="2-1-配置"><a href="#2-1-配置" class="headerlink" title="2.1 配置"></a>2.1 配置</h2><p>配置文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">port 26379</span><br><span class="line">dir &quot;/usr/soft/redis&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/usr/soft/redis/sentinel.log&quot;</span><br><span class="line"></span><br><span class="line"># 修改改成5秒</span><br><span class="line">sentinel monitor learnSentinelMaster 192.168.17.101 6379 2</span><br><span class="line">sentinel down-after-milliseconds learnSentinelMaster 5000</span><br><span class="line">sentinel config-epoch learnSentinelMaster 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="2-2-启动方式"><a href="#2-2-启动方式" class="headerlink" title="2.2 启动方式"></a>2.2 启动方式</h2><p>有两种方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/redis-sentinel sentinel.conf</span><br><span class="line">复制代码</span><br><span class="line">src/redis-server sentinel.conf --sentinel</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="3-开始搭建"><a href="#3-开始搭建" class="headerlink" title="3 开始搭建"></a>3 开始搭建</h1><p>哨兵搭建的过程如下</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-230952.png" alt></p>
<p>哨兵集群搭建完毕后，日志内容如下</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-231001.png" alt></p>
<p>启动后配置文件sentinel.conf会增加内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">port 26379</span><br><span class="line">dir &quot;/usr/soft/redis&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/usr/soft/redis/sentinel.log&quot;</span><br><span class="line"></span><br><span class="line"># 修改改成5秒</span><br><span class="line">sentinel myid b457cbbcda1991f540d56c6e8faea123a668b16c</span><br><span class="line">sentinel monitor learnSentinelMaster 192.168.17.101 6379 2</span><br><span class="line">sentinel down-after-milliseconds learnSentinelMaster 5000</span><br><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">sentinel config-epoch learnSentinelMaster 1</span><br><span class="line">sentinel leader-epoch learnSentinelMaster 0</span><br><span class="line">sentinel known-slave learnSentinelMaster 192.168.17.102 6379</span><br><span class="line">sentinel known-slave learnSentinelMaster 192.168.17.103 6379</span><br><span class="line">sentinel known-sentinel learnSentinelMaster 192.168.17.101 26379 f0230d4fdf1ffc7865852de71f16b3017cc1617c</span><br><span class="line">sentinel known-sentinel learnSentinelMaster 192.168.17.102 26379 5b1099513713310eba94e69513dba76cf0ac2222</span><br><span class="line">sentinel current-epoch 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="4-启动流程"><a href="#4-启动流程" class="headerlink" title="4 启动流程"></a>4 启动流程</h1><p>接下来看看哨兵集群启动过程中，Redis内部发生了什么。步骤如下</p>
<ol>
<li>初始化服务器</li>
<li>使用Sentinel专用代码</li>
<li>初始化Sentinel状态</li>
<li>创建连向主服务器的网络连接</li>
</ol>
<h2 id="4-1-初始化服务器"><a href="#4-1-初始化服务器" class="headerlink" title="4.1 初始化服务器"></a>4.1 初始化服务器</h2><p>Sentinel 本质上只是一个运行在特殊模式下的Redis服务器，所以初始化时和不同的Redis服务器初始化没什么较大的区别。有区别的就是哨兵服务器并不会载入RDB文件和AOF文件，还有一些命令功能哨兵服务器不使用。</p>
<h2 id="4-2-使用Sentinel专用代码"><a href="#4-2-使用Sentinel专用代码" class="headerlink" title="4.2 使用Sentinel专用代码"></a>4.2 使用Sentinel专用代码</h2><p>初始化服务器之后，哨兵服务器会将一部分普通Redis的服务器使用的代码替换成哨兵专用的代码。以下就是哨兵的命令列表，代码文件在<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fantirez%2Fredis%2Fblob%2Funstable%2Fsrc%2Fsentinel.c" target="_blank" rel="noopener">github.com/antirez/red…</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct redisCommand sentinelcmds[] = &#123;</span><br><span class="line">    &#123;&quot;ping&quot;,pingCommand,1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;sentinel&quot;,sentinelCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;subscribe&quot;,subscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;unsubscribe&quot;,unsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;psubscribe&quot;,psubscribeCommand,-2,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;punsubscribe&quot;,punsubscribeCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;publish&quot;,sentinelPublishCommand,3,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;info&quot;,sentinelInfoCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;role&quot;,sentinelRoleCommand,1,&quot;l&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;client&quot;,clientCommand,-2,&quot;rs&quot;,0,NULL,0,0,0,0,0&#125;,</span><br><span class="line">    &#123;&quot;shutdown&quot;,shutdownCommand,-1,&quot;&quot;,0,NULL,0,0,0,0,0&#125;</span><br><span class="line">&#125;;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-3-初始化Sentinel状态"><a href="#4-3-初始化Sentinel状态" class="headerlink" title="4.3 初始化Sentinel状态"></a>4.3 初始化Sentinel状态</h2><p>在应用了哨兵专用的代码之后，哨兵会初始化状态，这个哨兵状态结构包含了服务器中所有和哨兵功能有关的状态。结构体代码位置在也在entinel.c文件中，结构体代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* Main state. */</span><br><span class="line">struct sentinelState &#123;</span><br><span class="line">    char myid[CONFIG_RUN_ID_SIZE+1]; /* 当前哨兵ID. */</span><br><span class="line">    uint64_t current_epoch;         /* 当前纪元. */</span><br><span class="line">    dict *masters;      /* 存放哨兵监视的主服务器，key是主服务器的名字，value是指向主服务器的指针tances. */</span><br><span class="line">    int tilt;           /* 是否处于TILT模式? */</span><br><span class="line">    int running_scripts;    /* 目前执正在执行的脚本数量 */</span><br><span class="line">    mstime_t tilt_start_time;       /* 进入TITL开始的时间 */</span><br><span class="line">    mstime_t previous_time;         /* 最后一次执行时间处理器的时间*/</span><br><span class="line">    list *scripts_queue;            /* 包含了所有需要执行的用户脚本 */</span><br><span class="line">    char *announce_ip;  /* 当配置文件中的announce_ip不为空时，记录着这些IP地址 */</span><br><span class="line">    int announce_port;  /* 配置文件中的announce_port */</span><br><span class="line">    unsigned long simfailure_flags; /* 故障模拟 */</span><br><span class="line">    int deny_scripts_reconfig; /* 是否允许哨兵在运行时修改脚本位置? */</span><br><span class="line">&#125; sentinel;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>启动哨兵出现的日志如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line"># Redis version=4.9.103, bits=64, commit=00000000, modified=0, pid=2100, just started</span><br><span class="line"># Configuration loaded</span><br><span class="line">* Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line">* Running mode=sentinel, port=26379.</span><br><span class="line"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>哨兵id如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Sentinel ID is b457cbbcda1991f540d56c6e8faea123a668b16c</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="4-4-创建连向主服务器的网络连接"><a href="#4-4-创建连向主服务器的网络连接" class="headerlink" title="4.4 创建连向主服务器的网络连接"></a>4.4 创建连向主服务器的网络连接</h2><p>初始化哨兵的最后一步是创建连向被监视的主服务器的网络连接，哨兵将会成为主服务器的客户端。哨兵会向主服务器创建两个异步网络连接</p>
<ol>
<li>命令连接，用于向主服务器发送命令，并接受命令。</li>
<li>订阅连接，专门用于订阅主服务器的<em>sentinel</em>:hello频道。</li>
</ol>
<p>启动哨兵过程到这里就结束了，接下来将进入下个环节。</p>
<h1 id="5-获取信息"><a href="#5-获取信息" class="headerlink" title="5 获取信息"></a>5 获取信息</h1><p>获取信息阶段会获取主服务器信息和从服务器信息以及哨兵的相关信息。</p>
<h2 id="5-1-获取主服务器信息"><a href="#5-1-获取主服务器信息" class="headerlink" title="5.1 获取主服务器信息"></a>5.1 获取主服务器信息</h2><p>哨兵默认会以10s一次的频率，发送命令连接向被监视的主服务器发送INFO命令，并通过分析INFO命令的回复来获取主服务器的当前信息。</p>
<p>监控主服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># +monitor master learnSentinelMaster 192.168.17.101 6379 quorum 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过分析主服务器返回的信息，可以获取到两方面的信息</p>
<ol>
<li>主服务器本身的信息</li>
<li>从服务器的信息</li>
</ol>
<p>获取到从服务器信息之后，哨兵会更新保存主服务器实例结构的slaves字典。</p>
<h2 id="5-2-获取从服务器信息"><a href="#5-2-获取从服务器信息" class="headerlink" title="5.2 获取从服务器信息"></a>5.2 获取从服务器信息</h2><p>当哨兵发现主服务器有新的从服务器出现时，哨兵会为这个新的从服务器创建相应的实例结构之外，还会创建到从服务器的命令连接和订阅连接。</p>
<p>发现新的从服务器会出现如下日志</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* +slave slave 192.168.17.102:6379 192.168.17.102 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">* +slave slave 192.168.17.103:6379 192.168.17.103 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>在创建命令连接之后，会发送INFO命令获取信息。通过从服务器回复的信息中，可以获得以下内容</p>
<ol>
<li>从服务器的运行ID run_id</li>
<li>从服务器的角色 role</li>
<li>从服务器的IP地址 master_host，以及主服务器的端口号master_port</li>
<li>从服务器的连接状态 matser_link_status</li>
<li>从服务器的优先级 salve_pripority</li>
<li>从服务器的复制偏移量 slave_repl_offest</li>
</ol>
<p>获取到这些信息之后，会对之前创建的从服务器实例结构进行更新。</p>
<h2 id="5-3-获取其他Sentinel的信息"><a href="#5-3-获取其他Sentinel的信息" class="headerlink" title="5.3 获取其他Sentinel的信息"></a>5.3 获取其他Sentinel的信息</h2><p>在获取其他哨兵的信息之前，先要知道<code>向主服务器和从服务器发送信息</code>和<code>接收来自主服务器和从服务器的频道信息</code>。</p>
<h3 id="5-3-1-向主服务器和从服务器发送信息"><a href="#5-3-1-向主服务器和从服务器发送信息" class="headerlink" title="5.3.1 向主服务器和从服务器发送信息"></a>5.3.1 向主服务器和从服务器发送信息</h3><p>发送的命令格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello &quot;&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>PUBLISH是发布消息的命令，<code>__sentinel__:hello</code>是频道的名称，后面就是一些参数，参数信息如下</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-231015.png" alt="image-20190806071015336"></p>
<h3 id="5-3-2-接收来自主服务器和从服务器的频道信息"><a href="#5-3-2-接收来自主服务器和从服务器的频道信息" class="headerlink" title="5.3.2 接收来自主服务器和从服务器的频道信息"></a>5.3.2 接收来自主服务器和从服务器的频道信息</h3><p>当Sentinel与一个主服务器或者从服务器建立起订阅连接之后，Sentinel就会通过订阅连接，向服务器发送命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE __sentinel__:hello</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>表示哨兵订阅<code>__sentinel__:hello</code>这个频道，接收这个频道的消息。</p>
<p>其他哨兵可以通过接收这个频道的消息来发现其他哨兵的存在。</p>
<h3 id="5-3-3-发现哨兵"><a href="#5-3-3-发现哨兵" class="headerlink" title="5.3.3 发现哨兵"></a>5.3.3 发现哨兵</h3><p>通过接收<code>__sentinel__:hello</code>频道的消息可以发现其他哨兵的存在。当哨兵接收到一条来自<code>__sentinel__:hello</code>频道的消息时，会出现下方</p>
<ol>
<li>判断该消息是否是自己发送的，是则忽略这条消息</li>
<li>消息不是自己发送时，说明有新的哨兵</li>
<li>查看自己是否存有该哨兵的信息，有则更新该哨兵的信息</li>
<li>没有则创建一个新的哨兵实例结构，并保存到sentinels字典中</li>
</ol>
<blockquote>
<p>注：sentinels字典是专门保存哨兵信息的</p>
</blockquote>
<h3 id="5-3-4-创建连向其他哨兵的命令连接"><a href="#5-3-4-创建连向其他哨兵的命令连接" class="headerlink" title="5.3.4 创建连向其他哨兵的命令连接"></a>5.3.4 创建连向其他哨兵的命令连接</h3><p>当Sentinel通过频道信息发现一个新的Sentinel时，不仅会在自身的sentinels字典中为新Sentinel创建实例结构，还会创建一个连向新Sentinel的命令连接，同时新的Sentinel也会创建一个连向这个Sentinel的命令连接，最终多个Sentinel将形成一个互相连接的网络。</p>
<blockquote>
<p>注：哨兵之间不会创建订阅连接</p>
</blockquote>
<p>发现哨兵的日志如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* +sentinel sentinel f0230d4fdf1ffc7865852de71f16b3017cc1617c 192.168.17.101 26379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">* +sentinel sentinel 5b1099513713310eba94e69513dba76cf0ac2222 192.168.17.102 26379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="6-模拟101主服务器掉钱"><a href="#6-模拟101主服务器掉钱" class="headerlink" title="6 模拟101主服务器掉钱"></a>6 模拟101主服务器掉钱</h1><p>模拟101主服务器掉钱的过程如下</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-231043.png" alt="image-20190806071035932"></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164fdd8d8e1efa30?imageslim" alt="img"></p>
<p>断线重连的日志内容如下</p>
<p><img src="http://ipic-freemana-1257703707.cos.ap-shanghai.myqcloud.com/2019-08-05-230830.png" alt="img"></p>
<p>接下来开始分析断线过程中的每一步骤</p>
<ol>
<li>检测主观下线状态</li>
<li>检测客观下线状态</li>
<li>选举领头哨兵</li>
<li>故障转移</li>
</ol>
<h2 id="6-1-检测主观下线状态"><a href="#6-1-检测主观下线状态" class="headerlink" title="6.1 检测主观下线状态"></a>6.1 检测主观下线状态</h2><p>在默认情况下，Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（主，从，其他Sentinel）发送  PING命令 ，通过判断返回的内容来判断是否在线，命令分为有效回复和无效回复两种。</p>
<ul>
<li>有效回复<ul>
<li>+PING</li>
<li>-LOADING</li>
<li>-MASTERDOWN</li>
</ul>
</li>
<li>无效回复<ul>
<li>除有效回复以外的内容</li>
<li>指定时间内没有回复</li>
</ul>
</li>
</ul>
<p>配置文件中的down-after-milliseconds参数可以设置指定时间，在这个时间段内没有收到回复则判定该服务器处于主观下线状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds learnSentinelMaster 5000</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<hr>
<p>现在101客户端上输入以下命令,让服务器睡眠30秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug sleep 30</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时查看哨兵日志，等待5秒后出现以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># +sdown master learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="6-2-检测客观下线状态"><a href="#6-2-检测客观下线状态" class="headerlink" title="6.2 检测客观下线状态"></a>6.2 检测客观下线状态</h2><p>当一个哨兵将一个主服务器判断为主观下线之后，会向其他监视该主服务器的哨兵进行询问，当有足够数量的哨兵判定主服务器下线时，会执行故障转移操作 。</p>
<blockquote>
<p>注：这里不对哨兵之间互相发送的消息进行说明</p>
</blockquote>
<p>在配置中可以决定判定主服务器进入客观下线状态所需要的服务器数量，下方配置的最后一个参数就是所需的哨兵数量，这里填写的是2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor learnSentinelMaster 192.168.17.101 6379 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>下面的日志说明了主服务器101已经进入客观下线状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># +odown master learnSentinelMaster 192.168.17.101 6379 #quorum 2/2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当前纪元被更新 ，试图故障恢复</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># +new-epoch 2</span><br><span class="line"># +try-failover master learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>此时开始准备选举领头哨兵进行故障转移</p>
<h2 id="6-3-选举领头哨兵"><a href="#6-3-选举领头哨兵" class="headerlink" title="6.3 选举领头哨兵"></a>6.3 选举领头哨兵</h2><p>当主服务器被判定为客观下线之后，各个哨兵服务器将会选举出一个领头哨兵，有这个领头哨兵对下线服务器进行故障转移操作，选举领头哨兵的规则如下：</p>
<ol>
<li>所有在线的Sentinel都有被选为领头Sentinel的资格；</li>
<li>每次进行选举之后，不论选举是否成功，所有Sentinel的配置纪元都会自增一次；</li>
<li>在一个配置纪元里，所有Sentinel都有一次将某个Sentinel设置为局部领头Sentinel的机会，并且局部领头一旦设置，在这个配置纪元里就不会再更改；</li>
<li>每个发现主服务器进入客观下线的Sentinel都会要求其他Sentinel将自己设置为局部领头Sentinel；</li>
<li>当一个Sentinel向另一个Sentinel发送请求命令，并且命令中的runid不是*而是运行id时，这表示源Sentinel要求目标Sentinel将前者设置为后者的局部领头Sentinel。</li>
<li>设置局部领头Sentinel的原则是先到先得，之后所有的设置要求都会被拒绝；</li>
<li>目标Sentinel在收到命令后，会返回一条回复，回复中的leader_runid参数和leader_epoch参数分别记录了目标Sentinel的局部领头Sentinel的运行ID和配置纪元；</li>
<li>源Sentinel在收到回复后，会检查配置纪元与自己是否相等，如果相同，且leader_runid与自己相同，那么表示自己成为了目标的局部领头；</li>
<li>如果有某个Sentinel被半数以上的Sentinel设置成了局部领头Sentinel，那么它成为领头Sentinel；</li>
<li>因为领头的产生需要半数哨兵的支持，并且每个哨兵在每个配置纪元只能设置一次局部领头Sentinel，所以在一个配置纪元里面，只会出现一个领头Sentinel；</li>
<li>如果在给定时限内没有选出领头Sentinel，那么各个Sentinel将在一段时间之后再次进行选举，直到选出来。</li>
</ol>
<p>下方就是选举领头哨兵的日志内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># +vote-for-leader b457cbbcda1991f540d56c6e8faea123a668b16c 2</span><br><span class="line"># 5b1099513713310eba94e69513dba76cf0ac2222 voted for b457cbbcda1991f540d56c6e8faea123a668b16c 2</span><br><span class="line"># f0230d4fdf1ffc7865852de71f16b3017cc1617c voted for b457cbbcda1991f540d56c6e8faea123a668b16c 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h2 id="6-4-故障转移"><a href="#6-4-故障转移" class="headerlink" title="6.4 故障转移"></a>6.4 故障转移</h2><p>在选举出领头哨兵之后，领头哨兵需要执行故障转移操作，操作主要分为三个步骤</p>
<ol>
<li>选出新的主服务器</li>
<li>修改从服务器的复制目标</li>
<li>将旧的主服务器变为从服务器</li>
</ol>
<h3 id="6-4-1-选出新的主服务器"><a href="#6-4-1-选出新的主服务器" class="headerlink" title="6.4.1 选出新的主服务器"></a>6.4.1 选出新的主服务器</h3><p>此时，领头哨兵需要选出新的主服务器，然后向新的主服务器发送SLAVEOF no one命令，将这个从服务器转换为主服务器。</p>
<p>选择过程会过滤掉不符合要求的服务器：</p>
<ol>
<li>处于下线或者断线状态的从服务器</li>
<li>最近5秒内没有回复过领头哨兵的INFO信息的从服务器</li>
<li>与已下线主服务器连接断开超过（down-after-milliseconds * 10）毫秒的从服务器。（与主服务器客观下线时间进行比较）</li>
</ol>
<p>新的主服务器只选择通过上面的测试，并在上面的标准基础上排序：</p>
<ol>
<li>Slave通过Redis实例的redis.conf文件配置的slave-priority排序。优先级越低越被优先考虑。</li>
<li>如果优先级相同，检查slave的复制偏移量，并选择接收更多数据的slave。</li>
<li>如果多个slave有相同的优先级和同样的处理数据过程，就会执行一个更进一步的验证，选择一个有较短run ID的slave。run ID 对于 slave没太大用，但是非常有助于选择slave的过程，而不是随机选择slave。</li>
</ol>
<p>选出合适的从节点作为新的主节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2101:X 31 Jul 19:13:35.709 # +failover-state-select-slave master learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">2101:X 31 Jul 19:13:35.793 # +selected-slave slave 192.168.17.102:6379 192.168.17.102 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>开始讲102转换为主节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* +failover-state-send-slaveof-noone slave 192.168.17.102:6379 192.168.17.102 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">* +failover-state-wait-promotion slave 192.168.17.102:6379 192.168.17.102 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line"># +promoted-slave slave 192.168.17.102:6379 192.168.17.102 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line"># +failover-state-reconf-slaves master learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="6-4-2-修改从服务器的复制目标"><a href="#6-4-2-修改从服务器的复制目标" class="headerlink" title="6.4.2 修改从服务器的复制目标"></a>6.4.2 修改从服务器的复制目标</h3><p>当新的主服务器出现之后，领头哨兵会向其他从服务器发送slaveof 命令去复制新的主服务器。</p>
<p>下方记录了领头哨兵向从服务器发送 SALVEOF命令去复制新的主服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* +slave-reconf-sent slave 192.168.17.103:6379 192.168.17.103 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">* +slave-reconf-inprog slave 192.168.17.103:6379 192.168.17.103 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">* +slave-reconf-done slave 192.168.17.103:6379 192.168.17.103 6379 @ learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="6-4-3-将旧的主服务器变为从服务器"><a href="#6-4-3-将旧的主服务器变为从服务器" class="headerlink" title="6.4.3 将旧的主服务器变为从服务器"></a>6.4.3 将旧的主服务器变为从服务器</h3><p>这时候如果下线的主服务器重启上线了怎么办？这也是故障转移要做的最后一步，将已下线的主服务器设置为新的主服务器的从服务器。当下线的主服务器重新上线时，哨兵就会向它发送SLAVEOF命令，让他成为新的主服务器的从服务器。</p>
<p>此时101服务器上线</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -odown master learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>故障转移成功完成。所有slaves被重新配置为新master的从</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># +failover-end master learnSentinelMaster 192.168.17.101 6379</span><br><span class="line"># +switch-master learnSentinelMaster 192.168.17.101 6379 192.168.17.102 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>转换101状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* +slave slave 192.168.17.101:6379 192.168.17.101 6379 @ learnSentinelMaster 192.168.17.102 6379</span><br><span class="line"># +sdown slave 192.168.17.101:6379 192.168.17.101 6379 @ learnSentinelMaster 192.168.17.102 6379</span><br><span class="line"># -sdown slave 192.168.17.101:6379 192.168.17.101 6379 @ learnSentinelMaster 192.168.17.102 6379</span><br><span class="line">* +convert-to-slave slave 192.168.17.101:6379 192.168.17.101 6379 @ learnSentinelMaster 192.168.17.102 6379</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这时候再次查看配置文件会发现多了一行sentinel current-epoch 2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#后台启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line">bind 0.0.0.0</span><br><span class="line"></span><br><span class="line">port 26379</span><br><span class="line">dir &quot;/usr/soft/redis&quot;</span><br><span class="line">loglevel notice</span><br><span class="line">logfile &quot;/usr/soft/redis/sentinel.log&quot;</span><br><span class="line"></span><br><span class="line"># 修改改成5秒</span><br><span class="line">sentinel myid f0230d4fdf1ffc7865852de71f16b3017cc1617c</span><br><span class="line">sentinel monitor learnSentinelMaster 192.168.17.102 6379 2</span><br><span class="line">sentinel down-after-milliseconds learnSentinelMaster 5000</span><br><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">sentinel config-epoch learnSentinelMaster 2</span><br><span class="line">sentinel leader-epoch learnSentinelMaster 2</span><br><span class="line">sentinel known-slave learnSentinelMaster 192.168.17.103 6379</span><br><span class="line">sentinel known-slave learnSentinelMaster 192.168.17.101 6379</span><br><span class="line">sentinel known-sentinel learnSentinelMaster 192.168.17.103 26379 b457cbbcda1991f540d56c6e8faea123a668b16c</span><br><span class="line">sentinel known-sentinel learnSentinelMaster 192.168.17.102 26379 5b1099513713310eba94e69513dba76cf0ac2222</span><br><span class="line">sentinel current-epoch 2</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h1 id="7-相关配置"><a href="#7-相关配置" class="headerlink" title="7 相关配置"></a>7 相关配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf</span><br><span class="line"></span><br><span class="line"># 绑定IP地址</span><br><span class="line"># bind 127.0.0.1 192.168.1.1</span><br><span class="line"># 保护模式（是否禁止外部链接，除绑定的ip地址外）</span><br><span class="line"># protected-mode no</span><br><span class="line"></span><br><span class="line"># 当前Sentinel服务运行的端口</span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"># </span><br><span class="line"># sentinel announce-ip &lt;ip&gt;</span><br><span class="line"># sentinel announce-port &lt;port&gt;</span><br><span class="line"></span><br><span class="line"># Sentinel服务运行时使用的临时文件夹</span><br><span class="line">dir /tmp</span><br><span class="line"></span><br><span class="line"># 监听地址为ip:port的一个master</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"># 设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</span><br><span class="line"># sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"># 指定了Sentinel认为Redis实例已经失效所需的毫秒数</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"># 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"># 如果在该时间（ms）内未能完成故障转移操作，则认为该故障转移失败</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"># 指定sentinel检测到该监控的redis实例指向的实例异常时，调用的报警脚本。该配置项可选，但是很常用</span><br><span class="line"># sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。</span><br><span class="line"># sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<p><img src="../../../../../Users/apple/Library/Application%20Support/typora-user-images/image-20190806071656400.png" alt="image-20190806071622223"></p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>John Doe</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/2019/08/06/Redis/慕课网redis从入门到高可用/第八章 RedisSentinel/">http://yoursite.com/2019/08/06/Redis/慕课网redis从入门到高可用/第八章 RedisSentinel/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/Redis/"># Redis</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/08/09/模版技术/Thymeleaf/">Thymeleaf</a>
            
            
            <a class="next" rel="next" href="/2019/08/05/Redis/慕课网redis从入门到高可用/第七章 Redis复制的原理与优化/">第七章  Redis复制与优化</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© John Doe | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
